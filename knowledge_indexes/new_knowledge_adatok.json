[
  {
    "filename": "System1.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                     System_1.mq5 |\n//|                                                     Spencer Luck |\n//+------------------------------------------------------------------+\n\n// Importing files to use methods\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n\n// Object CTrade as trade\nCTrade trade;\n// Object CPositionInfo as pos_info\nCPositionInfo pos_info;\n\n// Inputs\ninput int JTPO_period = 27;\ninput int JTPO_price = 0;\ninput int Wad_fast_MA = 22;\ninput int Wad_slow_MA = 35;\ninput int Wad_bollinger = 20;\ninput int Wad_bollinger_dev = 2;\ninput int Wad_sens = 150;\ninput int Wad_DZP = 3000;\ninput int Schaff_period = 50;\ninput int Schaff_fast_EMA = 10;\ninput int Schaff_slow_EMA = 15;\ninput int Schaff_smooth = 3;\ninput int Schaff_price = 0;\ninput int MA_period = 6;\ninput ENUM_MA_METHOD MA_mode=MODE_SMA;\ninput int Oscar_period = 7;\ninput int Oscar_signal_period = 11;\n\n// position modifier count\nint positionmodifiercount = 0;\n\nint OnInit()\n  {\n   \n   return(INIT_SUCCEEDED);\n  }\n\nvoid OnDeinit(const int reason)\n  {\n\n  }\n\nvoid OnTick()\n  {\n\n// Restrict code to process only once per bar\n   static datetime timestamp;\n   datetime time = iTime(_Symbol,PERIOD_CURRENT,0); // Time of current candle\n   if(timestamp != time)\n     {\n      timestamp = time;\n\n\n      //ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //J_TPO\n      static int HandleJTPO = iCustom(_Symbol,PERIOD_CURRENT,\"j_tpo\",JTPO_period,JTPO_price);\n      double JTPOArray[];\n      CopyBuffer(HandleJTPO,0,1,2,JTPOArray);\n      ArraySetAsSeries(JTPOArray,true);\n      //Waddah Attar Explosion\n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",Wad_fast_MA,Wad_slow_MA,Wad_bollinger,Wad_bollinger_dev,Wad_sens,Wad_DZP,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // Candle Ratio\n      static int HandleSchaff = iCustom(_Symbol,PERIOD_CURRENT,\"Schaff Trend Cycle\",Schaff_period,Schaff_fast_EMA,Schaff_slow_EMA,Schaff_smooth,Schaff_price);\n      double SchaffArray[];\n      CopyBuffer(HandleSchaff,1,1,2,SchaffArray);\n      ArraySetAsSeries(SchaffArray,true);\n      // Simple Moving Average\n      static int HandleMA = iMA(_Symbol,PERIOD_CURRENT,MA_period,0,MA_mode,PRICE_CLOSE);\n      double ArrayMA [];\n      CopyBuffer(HandleMA,0,1,2,ArrayMA);\n      ArraySetAsSeries(ArrayMA,true);\n      //Oscar\n      static int HandleOscar = iCustom(_Symbol,PERIOD_CURRENT,\"Oscar\",Oscar_period,Oscar_signal_period);\n      //Oscar - Ratio\n      double OscarArray[];\n      CopyBuffer(HandleOscar,0,1,2,OscarArray);\n      ArraySetAsSeries(OscarArray,true);\n      //Oscar - Signal\n      double SignalArray[];\n      CopyBuffer(HandleOscar,1,1,2,SignalArray);\n      ArraySetAsSeries(SignalArray,true);\n\n\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n\n      // Buy conditions\n      bool JTPO_buy = (JTPOArray[0] > 0 && JTPOArray[1] < 0);\n      bool Schaff_buy = (SchaffArray[0] == 1);\n      bool MA_buy = (ArrayMA[0] < CloseArray[0]);\n      bool Oscar_buy = (OscarArray[0] > SignalArray[0]);\n\n\n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n      // Sell conditions\n      bool JTPO_sell = (JTPOArray[0] < 0 && JTPOArray[1] > 0);\n      bool Schaff_sell = (SchaffArray[0] == 2);\n      bool MA_sell = (ArrayMA[0] > CloseArray[0]);\n      bool Oscar_sell = (OscarArray[0] < SignalArray[0]);\n\n\n      // Exit conditions\n      bool Oscar_sell_exit = (OscarArray[0] > SignalArray[0] && OscarArray[1] < SignalArray[1]);\n      bool Oscar_buy_exit = (OscarArray[0] < SignalArray[0] && OscarArray[1] > SignalArray[1]);\n\n\n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  \n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; \n              }\n        }\n\n\n      // Managing positions, modifying second trade (moving SL)\n      // Checking how many positions are open\n\n      int current_open_positions = PositionsTotal(); // Might cause a problem with live testing.\n       \n      if (current_open_positions == 0 && positionmodifiercount == 1)\n      {\n      positionmodifiercount -= 1 ;\n      }\n       \n      if(Buy_opened && current_open_positions == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(AtrArray[0] * 1.5,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor);\n        }\n\n      if(Sell_opened && current_open_positions == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(AtrArray[0] * 1.5,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor);\n        }\n\n\n      // Exit conditions\n\n      if(Buy_opened && Oscar_buy_exit)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && Oscar_sell_exit)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Buy_opened && JTPO_sell)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && JTPO_buy)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Buy_opened && MA_sell)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && MA_buy)\n        {\n         if(pos_info.Symbol()==Symbol())\n            \n          CloseAllPositions();\n        }\n\n\n      // Placing Buy orders\n      if(JTPO_buy  && Wad_vol && Schaff_buy && MA_buy && Oscar_buy)\n        {\n         Print(\"System 16.5 indicates a buy signal\");\n         \n         // Closing open sell positions\n         if(Sell_opened)\n           {\n            if(pos_info.Symbol()==Symbol())\n               trade.PositionClose(pos_info.Ticket());\n           }\n\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         trade.Buy(Lots,_Symbol,ask,sl,tp,\"Buy1\");\n         trade.Buy(Lots,_Symbol,ask,sl,NULL,\"Buy2\");\n\n        }\n\n      // Placing Sell orders\n      if(JTPO_sell && Wad_vol && Schaff_sell && MA_sell && Oscar_sell)\n        {\n         Print(\"System 16.5 indicates a sell signal\");\n\n\n         // Closing open buy positions\n         if(Buy_opened)\n           {\n            if(pos_info.Symbol()==Symbol())\n               trade.PositionClose(pos_info.Ticket());\n           }\n\n         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         trade.Sell(Lots,_Symbol,bid,sl,tp,\"Sell1\");\n         trade.Sell(Lots,_Symbol,bid,sl,NULL,\"Sell2\");\n\n        }\n\n     }\n\n  }\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopBuy(double ask, double AtrFactor)\n  {\n\n// set the stop loss to 150 points\n   double SL=NormalizeDouble(ask-AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n            // get the ticket number\n            ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n\n            // get position open price\n            double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n\n            // calculate the current stop loss\n            double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n            \n            // Assume a min of 2pips \n            double MinTradeStops = 20*_Point;\n               \n   \n            // Check if stop loss is too close to price or if price has moved back past the open price\n            if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n              {\n               CloseAllPositions();\n              }  \n               \n               \n            else\n               {\n                  // move stop loss to open price, therefore zero loss\n                  if(CurrentStopLoss < PositionOpen && positionmodifiercount == 0)\n                    {\n                     trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                     \n                    }\n                  // if current stop loss is more than 150 points\n                  if(CurrentStopLoss < SL && positionmodifiercount == 1)\n                    {\n                     // move the stop loss\n                     trade.PositionModify(PositionTicket,SL,NULL);\n                    }\n                    \n                  if(positionmodifiercount == 0){\n                     positionmodifiercount += 1;\n                    }\n\n               }\n               \n           }\n        }\n     }\n  }\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopSell(double bid, double AtrFactor)\n  {\n\n// set the stop loss to ATR points\n   double SL=NormalizeDouble(bid+AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n           {\n            // get the ticket number\n            ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n\n            // get position open price\n            double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n\n            // calculate the current stop loss\n            double CurrentStopLoss = PositionGetDouble(POSITION_SL); //works\n            \n            // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n             double MinTradeStops = 20*_Point;\n               \n   \n            // Check if stop loss is too close to price or if price has moved back past the open price\n            if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n              {\n                  CloseAllPositions();\n              }\n\n            \n            else\n               {\n            \n               // move stop loss to open price, therefore zero loss\n               if(CurrentStopLoss > PositionOpen && positionmodifiercount == 0)\n                 {\n                 //Print(CurrentStopLoss);\n                  trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                  \n                 }\n               // if current stop loss is more than ATR points\n               if(CurrentStopLoss > SL && positionmodifiercount == 1)\n                 {\n                  // move the stop loss\n                  trade.PositionModify(PositionTicket,SL,NULL);\n                 }\n                 \n               if(positionmodifiercount == 0){\n                 positionmodifiercount += 1;\n                 }\n\n               }\n \n           }\n        }\n     }\n  }\n\n\n\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CloseAllPositions()\n  {\n\n// Count down until there are no positions left\n   for(int i = PositionsTotal()-1; i>=0; i--)\n     {\n     string symbol=PositionGetSymbol(i); // get the symbol of the position\n     if(_Symbol == symbol)\n     \n     { \n      // Get the position number\n      ulong ticket = PositionGetTicket(i);\n\n      // Close the position\n      trade.PositionClose(ticket);\n      }\n     }\n\n\n  }\n\n//+------------------------------------------------------------------+\n//+------------------------------------------------------------------+\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                     System_1.mq5 |\n//|                                                     Spencer Luck |\n//+------------------------------------------------------------------+\n\n// Importing files to use methods\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n\n// Object CTrade as trade\nCTrade trade;\n// Object CPositionInfo as pos_info\nCPositionInfo pos_info;\n\n// Inputs\ninput int JTPO_period = 27;\ninput int JTPO_price = 0;\ninput int Wad_fast_MA = 22;\ninput int Wad_slow_MA = 35;\ninput int Wad_bollinger = 20;\ninput int Wad_bollinger_dev = 2;\ninput int Wad_sens = 150;\ninput int Wad_DZP = 3000;\ninput int Schaff_period = 50;\ninput int Schaff_fast_EMA = 10;\ninput int Schaff_slow_EMA = 15;\ninput int Schaff_smooth = 3;\ninput int Schaff_price = 0;\ninput int MA_period = 6;\ninput ENUM_MA_METHOD MA_mode=MODE_SMA;\ninput int Oscar_period = 7;\ninput int Oscar_signal_period = 11;\n\n// position modifier count\nint positionmodifiercount = 0;\n\nint OnInit()\n  {\n   \n   return(INIT_SUCCEEDED);\n  }\n\nvoid OnDeinit(const int reason)\n  {\n\n  }\n\nvoid OnTick()\n  {\n\n// Restrict code to process only once per bar\n   static datetime timestamp;\n   datetime time = iTime(_Symbol,PERIOD_CURRENT,0); // Time of current candle\n   if(timestamp != time)\n     {\n      timestamp = time;\n\n\n      //ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //J_TPO\n      static int HandleJTPO = iCustom(_Symbol,PERIOD_CURRENT,\"j_tpo\",JTPO_period,JTPO_price);\n      double JTPOArray[];\n      CopyBuffer(HandleJTPO,0,1,2,JTPOArray);\n      ArraySetAsSeries(JTPOArray,true);\n      //Waddah Attar Explosion\n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",Wad_fast_MA,Wad_slow_MA,Wad_bollinger,Wad_bollinger_dev,Wad_sens,Wad_DZP,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // Candle Ratio\n      static int HandleSchaff = iCustom(_Symbol,PERIOD_CURRENT,\"Schaff Trend Cycle\",Schaff_period,Schaff_fast_EMA,Schaff_slow_EMA,Schaff_smooth,Schaff_price);\n      double SchaffArray[];\n      CopyBuffer(HandleSchaff,1,1,2,SchaffArray);\n      ArraySetAsSeries(SchaffArray,true);\n      // Simple Moving Average\n      static int HandleMA = iMA(_Symbol,PERIOD_CURRENT,MA_period,0,MA_mode,PRICE_CLOSE);\n      double ArrayMA [];\n      CopyBuffer(HandleMA,0,1,2,ArrayMA);\n      ArraySetAsSeries(ArrayMA,true);\n      //Oscar\n      static int HandleOscar = iCustom(_Symbol,PERIOD_CURRENT,\"Oscar\",Oscar_period,Oscar_signal_period);\n      //Oscar - Ratio\n      double OscarArray[];\n      CopyBuffer(HandleOscar,0,1,2,OscarArray);\n      ArraySetAsSeries(OscarArray,true);\n      //Oscar - Signal\n      double SignalArray[];\n      CopyBuffer(HandleOscar,1,1,2,SignalArray);\n      ArraySetAsSeries(SignalArray,true);\n\n\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n\n      // Buy conditions\n      bool JTPO_buy = (JTPOArray[0] > 0 && JTPOArray[1] < 0);\n      bool Schaff_buy = (SchaffArray[0] == 1);\n      bool MA_buy = (ArrayMA[0] < CloseArray[0]);\n      bool Oscar_buy = (OscarArray[0] > SignalArray[0]);\n\n\n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n      // Sell conditions\n      bool JTPO_sell = (JTPOArray[0] < 0 && JTPOArray[1] > 0);\n      bool Schaff_sell = (SchaffArray[0] == 2);\n      bool MA_sell = (ArrayMA[0] > CloseArray[0]);\n      bool Oscar_sell = (OscarArray[0] < SignalArray[0]);\n\n\n      // Exit conditions\n      bool Oscar_sell_exit = (OscarArray[0] > SignalArray[0] && OscarArray[1] < SignalArray[1]);\n      bool Oscar_buy_exit = (OscarArray[0] < SignalArray[0] && OscarArray[1] > SignalArray[1]);\n\n\n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  \n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; \n              }\n        }\n\n\n      // Managing positions, modifying second trade (moving SL)\n      // Checking how many positions are open\n\n      int "
  },
  {
    "filename": "CheckSymbolBase.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                              CheckSymbolBase.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolBase (string BaseSymbol, int OrderType){\n// Provide base symbol in string form. Provide OrderType by providing ORDER_TYPE_BUY/SELL\n\n   double BaseSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n\n   for(int i = PositionsTotal()-1; i>=0; i--)\n   {\n      string CurrencyPair = PositionGetSymbol(i);\n      string CurrentSymbolBase = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_BASE);\n \n      \n      if(PositionGetInteger(POSITION_TYPE)==OrderType)\n      {\n         if(CurrentSymbolBase==BaseSymbol)\n         {\n            //System 1\n            if(PositionGetInteger(POSITION_MAGIC)==001)\n            {\n              System1Count += 1;\n            }\n            //System 2\n            if(PositionGetInteger(POSITION_MAGIC)==002)\n            {\n              System2Count += 1;\n            }\n            //System 3\n            if(PositionGetInteger(POSITION_MAGIC)==003)\n            {\n              System3Count += 1;\n            }\n            //System 4\n            if(PositionGetInteger(POSITION_MAGIC)==004)\n            {\n              System4Count += 1;\n            }\n            //System 5\n            if(PositionGetInteger(POSITION_MAGIC)==005)\n            {\n              System5Count += 1;\n            }\n            //System 6\n            if(PositionGetInteger(POSITION_MAGIC)==006)\n            {\n              System6Count += 1;\n            }\n            //System 7\n            if(PositionGetInteger(POSITION_MAGIC)==007)\n            {\n              System7Count += 1;\n            }\n            //System 8\n            if(PositionGetInteger(POSITION_MAGIC)==008)\n            {\n              System7Count += 1;\n            }\n         }\n         \n      }\n    }\n      \n   // Increment preset risk exposures retrieved from each system\n   if(System1Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n\n   // Returns the total volume exposed to the base symbol currency\n   return BaseSymbolExposure;\n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSymbolBase.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolBase (string BaseSymbol, int OrderType){\n// Provide base symbol in string form. Provide OrderType by providing ORDER_TYPE_BUY/SELL\n\n   double BaseSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n\n   for(int i = PositionsTotal()-1; i>=0; i--)\n   {\n      string CurrencyPair = PositionGetSymbol(i);\n      string CurrentSymbolBase = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_BASE);\n \n      \n      if(PositionGetInteger(POSITION_TYPE)==OrderType)\n      {\n         if(CurrentSymbolBase==BaseSymbol)\n         {\n            //System 1\n            if(PositionGetInteger(POSITION_MAGIC)==001)\n            {\n              System1Count += 1;\n            }\n            //System 2\n            if(PositionGetInteger(POSITION_MAGIC)==002)\n            {\n              System2Count += 1;\n            }\n            //System 3\n            if(PositionGetInteger(POSITION_MAGIC)==003)\n            {\n              System3Count += 1;\n            }\n            //System 4\n            if(PositionGetInteger(POSITION_MAGIC)==004)\n            {\n              System4Count += 1;\n            }\n            //System 5\n            if(PositionGetInteger(POSITION_MAGIC)==005)\n            {\n              System5Count += 1;\n            }\n            //System 6\n            if(PositionGetInteger(POSITION_MAGIC)==006)\n            {\n              System6Count += 1;\n            }\n            //System 7\n            if(PositionGetInteger(POSITION_MAGIC)==007)\n            {\n              System7Count += 1;\n            }\n            //System 8\n            if(PositionGetInteger(POSITION_MAGIC)==008)\n            {\n              System7Count += 1;\n            }\n         }\n         \n      }\n    }\n      \n   // Increment preset risk exposures retrieved from each system\n   if(System1Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n\n   // Returns the total volume exposed to the base symbol currency\n   return BaseSymbolExposure;\n   \n}"
  },
  {
    "filename": "CheckSystem1Exit.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem1Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 exit signals\n\nstring CheckSystem1Exit()\n{\n   string Sys1ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n \n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade exit entry signals //\n   // Sell exit signal\n   if(Aroon_buy_signal || JMA_buy_signal)\n   {\n      Print(\"System 1 Sell Exit Signal\");\n      Sys1ExitSignal = \"Sell Exit\";\n   }\n   \n   // Buy exit signal\n   if(Aroon_sell_signal || JMA_sell_signal)\n   {\n      Print(\"System 1 Buy Exit Signal\");\n      Sys1ExitSignal = \"Buy Exit\";\n   }\n   \n\n   return (Sys1ExitSignal);\n\n   \n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem1Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 exit signals\n\nstring CheckSystem1Exit()\n{\n   string Sys1ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n \n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade exit entry signals //\n   // Sell exit signal\n   if(Aroon_buy_signal || JMA_buy_signal)\n   {\n      Print(\"System 1 Sell Exit Signal\");\n      Sys1ExitSignal = \"Sell Exit\";\n   }\n   \n   // Buy exit signal\n   if(Aroon_sell_signal || JMA_sell_signal)\n   {\n      Print(\"System 1 Buy Exit Signal\");\n      Sys1ExitSignal = \"Buy Exit\";\n   }\n   \n\n   return (Sys1ExitSignal);\n\n   \n}\n"
  },
  {
    "filename": "CheckSystem3.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem3.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 entry signals \n\nstring CheckSystem3()\n{\n   string Sys3Signal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n   //Conditions\n      // Buy conditions\n      bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n      bool Klinger_buy = (KlingerArray[0] > KSignalArray[0]);\n      bool Waj_buy = (CloseArray[0] > WajArray[0]);\n      bool Solar_buy = (SolarArray[0] > 0);\n\n      \n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      // Sell conditions\n      bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n      bool Klinger_sell = (KlingerArray[0] < KSignalArray[0]);\n      bool Waj_sell = (CloseArray[0] < WajArray[0]);\n      bool Solar_sell = (SolarArray[0] < 0);\n      \n   //Trade Entry Signals\n   // Buy signal\n   if(Trinity_buy && FVE_buy && Klinger_buy && Waj_buy && Solar_buy && Wad_vol)\n   {\n      Print(\"System 3 Buy Signal\");\n      Sys3Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && FVE_sell && Klinger_sell && Waj_sell && Solar_sell && Wad_vol)\n   {\n      Print(\"System 3 Sell Signal\");\n      Sys3Signal = \"Sell\";\n   }      \n                              \n     return (Sys3Signal);                  \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem3.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 entry signals \n\nstring CheckSystem3()\n{\n   string Sys3Signal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n   //Conditions\n      // Buy conditions\n      bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n      bool Klinger_buy = (KlingerArray[0] > KSignalArray[0]);\n      bool Waj_buy = (CloseArray[0] > WajArray[0]);\n      bool Solar_buy = (SolarArray[0] > 0);\n\n      \n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      // Sell conditions\n      bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n      bool Klinger_sell = (KlingerArray[0] < KSignalArray[0]);\n      bool Waj_sell = (CloseArray[0] < WajArray[0]);\n      bool Solar_sell = (SolarArray[0] < 0);\n      \n   //Trade Entry Signals\n   // Buy signal\n   if(Trinity_buy && FVE_buy && Klinger_buy && Waj_buy && Solar_buy && Wad_vol)\n   {\n      Print(\"System 3 Buy Signal\");\n      Sys3Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && FVE_sell && Klinger_sell && Waj_sell && Solar_sell && Wad_vol)\n   {\n      Print(\"System 3 Sell Signal\");\n      Sys3Signal = \"Sell\";\n   }      \n                              \n     return (Sys3Signal);                  \n}"
  },
  {
    "filename": "CheckSys7.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem7.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 7 entry signals\n\nstring CheckSys7()\n{\nstring Sys7Signal =\"\";\n      // ATR\n      static int HandleAtr = iATR(_Symbol,PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //DiDi Index \n      static int handleDiDi = iCustom(_Symbol,PERIOD_CURRENT,\"DidiIndex\",0,2,0,0,3,9,15);\n      //DiDi Fast line\n      double FastDiDiArray[];\n      CopyBuffer(handleDiDi,0,1,2,FastDiDiArray);\n      ArraySetAsSeries(FastDiDiArray,true);\n      //DiDi Slow Line\n      double SlowDiDiArray[];\n      CopyBuffer(handleDiDi,2,1,2,SlowDiDiArray);\n      ArraySetAsSeries(SlowDiDiArray,true); \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,5); \n      double BullsArray[];\n      double BearsArray[];\n      CopyBuffer(HandleASA,0,1,2,BullsArray);\n      CopyBuffer(HandleASA,1,1,2,BearsArray);\n      ArraySetAsSeries(BullsArray,true);\n      ArraySetAsSeries(BearsArray,true);\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      //Modified Explosion \n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"Modified_Explosion\",3,90,15,30,15,2,0);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);      \n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);  \n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //iAnchmom\n      static int HandleIANCH = iCustom(_Symbol,PERIOD_CURRENT,\"ianchmom\",34,20,0,0); \n      double IANCHArray[];\n      CopyBuffer(HandleIANCH,0,1,2,IANCHArray);\n      ArraySetAsSeries(IANCHArray,true);\n      \n     //Conditins\n     bool WaddahVol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n     bool ASA_buy = (BullsArray[0] > BearsArray[0] && BullsArray[1] < BearsArray[1]);\n     bool ASA_sell = (BullsArray[0] < BearsArray[0] && BullsArray[1] > BearsArray[1]);\n     bool AnotherComboBuy = ((FastDiDiArray[0] > SlowDiDiArray[0] && FastDiDiArray[1] < SlowDiDiArray[1]) && ASA_buy && IANCHArray[0] > 0);\n     bool AnotherComboSell = ((FastDiDiArray[0] < SlowDiDiArray[0] && FastDiDiArray[1] > SlowDiDiArray[1]) && ASA_sell && IANCHArray[0] < 0); \n     \n      if (AnotherComboBuy && WaddahVol)\n      {\n      Print(\"System 7 is now long\");\n      Sys7Signal=\"Buy\";\n      }\n      \n      if (AnotherComboSell && WaddahVol)\n      {\n      Print(\"System 7 is now short\");\n      Sys7Signal=\"Sell\";\n      }\n      \n      return(Sys7Signal);\n     \n     \n\n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem7.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 7 entry signals\n\nstring CheckSys7()\n{\nstring Sys7Signal =\"\";\n      // ATR\n      static int HandleAtr = iATR(_Symbol,PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //DiDi Index \n      static int handleDiDi = iCustom(_Symbol,PERIOD_CURRENT,\"DidiIndex\",0,2,0,0,3,9,15);\n      //DiDi Fast line\n      double FastDiDiArray[];\n      CopyBuffer(handleDiDi,0,1,2,FastDiDiArray);\n      ArraySetAsSeries(FastDiDiArray,true);\n      //DiDi Slow Line\n      double SlowDiDiArray[];\n      CopyBuffer(handleDiDi,2,1,2,SlowDiDiArray);\n      ArraySetAsSeries(SlowDiDiArray,true); \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,5); \n      double BullsArray[];\n      double BearsArray[];\n      CopyBuffer(HandleASA,0,1,2,BullsArray);\n      CopyBuffer(HandleASA,1,1,2,BearsArray);\n      ArraySetAsSeries(BullsArray,true);\n      ArraySetAsSeries(BearsArray,true);\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      //Modified Explosion \n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"Modified_Explosion\",3,90,15,30,15,2,0);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);      \n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);  \n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //iAnchmom\n      static int HandleIANCH = iCustom(_Symbol,PERIOD_CURRENT,\"ianchmom\",34,20,0,0); \n      double IANCHArray[];\n      CopyBuffer(HandleIANCH,0,1,2,IANCHArray);\n      ArraySetAsSeries(IANCHArray,true);\n      \n     //Conditins\n     bool WaddahVol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n     bool ASA_buy = (BullsArray[0] > BearsArray[0] && BullsArray[1] < BearsArray[1]);\n     bool ASA_sell = (BullsArray[0] < BearsArray[0] && BullsArray[1] > BearsArray[1]);\n     bool AnotherComboBuy = ((FastDiDiArray[0] > SlowDiDiArray[0] && FastDiDiArray[1] < SlowDiDiArray[1]) && ASA_buy && IANCHArray[0] > 0);\n     bool AnotherComboSell = ((FastDiDiArray[0] < SlowDiDiArray[0] && FastDiDiArray[1] > SlowDiDiArray[1]) && ASA_sell && IANCHArray[0] < 0); \n     \n      if (AnotherComboBuy && WaddahVol)\n      {\n      Print(\"System 7 is now long\");\n      Sys7Signal=\"Buy\";\n      }\n      \n      if (AnotherComboSell && WaddahVol)\n      {\n      Print(\"System 7 is now short\");\n      Sys7Signal=\"Sell\";\n      }\n      \n      return(Sys7Signal);\n     \n     \n\n}\n"
  },
  {
    "filename": "CheckSystem1.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem1.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 entry signals\n\nstring CheckSystem1()\n{\n   string Sys1Signal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy = (CloseArray[0] > JMAArray[0]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell = (CloseArray[0] < JMAArray[0]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy)\n   {\n      Print(\"System 1 Buy Signal\");\n      Sys1Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell)\n   {\n      Print(\"System 1 Sell Signal\");\n      Sys1Signal = \"Sell\";\n   }\n   \n\n   return (Sys1Signal);\n\n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem1.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 entry signals\n\nstring CheckSystem1()\n{\n   string Sys1Signal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy = (CloseArray[0] > JMAArray[0]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell = (CloseArray[0] < JMAArray[0]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy)\n   {\n      Print(\"System 1 Buy Signal\");\n      Sys1Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell)\n   {\n      Print(\"System 1 Sell Signal\");\n      Sys1Signal = \"Sell\";\n   }\n   \n\n   return (Sys1Signal);\n\n   \n}"
  },
  {
    "filename": "CheckSystem8.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem8.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 8 entry signals\n\nstring CheckSystem8()\n{\n\n   string Sys8Signal=\"\";\n\n         // ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n         double AtrArray[];\n         CopyBuffer(HandleAtr,0,1,2,AtrArray);\n         ArraySetAsSeries(AtrArray,true);\n\n      // SSL\n      static int HandleSSL = iCustom(_Symbol,PERIOD_CURRENT,\"SSL_Channel_Chart\",3,20); \n         double SSLBearArray[];\n         double SSLBullArray[];\n         double SSLArray[];\n         CopyBuffer(HandleSSL,0,1,2,SSLBearArray);\n         CopyBuffer(HandleSSL,1,1,2,SSLBullArray);\n         CopyBuffer(HandleSSL,2,1,2,SSLArray);\n         ArraySetAsSeries(SSLBearArray,true);\n         ArraySetAsSeries(SSLBullArray,true);\n         ArraySetAsSeries(SSLArray,true);\n         \n         \n      // FVE\n      static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0); \n         double FVEArray[];\n         double SignalArray[];\n         CopyBuffer(HandleFVE,0,1,2,FVEArray);\n         CopyBuffer(HandleFVE,1,1,2,SignalArray);\n         ArraySetAsSeries(FVEArray,true);\n         ArraySetAsSeries(SignalArray,true);\n         \n         \n      // ROC\n      static int HandleROC = iCustom(_Symbol,PERIOD_CURRENT,\"ROC\",18);\n         double ROCArray[];\n         CopyBuffer(HandleROC,0,1,2,ROCArray);\n         ArraySetAsSeries(ROCArray,true);\n      \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,0); \n         double BullsArray[];\n         double BearsArray[];\n         CopyBuffer(HandleASA,0,1,2,BullsArray);\n         CopyBuffer(HandleASA,1,1,2,BearsArray);\n         ArraySetAsSeries(BullsArray,true);\n         ArraySetAsSeries(BearsArray,true);\n               // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n         // Buy conditions\n      bool SSL_buy_signal = (SSLArray[0] > 0 && SSLArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n      bool ROC_buy = (ROCArray[0] > 0);\n      bool ASA_buy = (BullsArray[0] > BearsArray[0]);\n\n      \n      // Sell conditions\n      bool SSL_sell_signal = (SSLArray[0] < 0 && SSLArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n      bool ROC_sell = (ROCArray[0] < 0);\n      bool ASA_sell = (BullsArray[0] < BearsArray[0]);\n      \n      if (SSL_buy_signal && FVE_buy && ROC_buy && ASA_buy)\n      {\n      Print(\"System 8 is now long\");\n      Sys8Signal=\"Buy\";\n      }\n      \n      if (SSL_sell_signal && FVE_sell && ROC_sell && ASA_sell)\n      {\n      Print(\"System 8 is now short\");\n      Sys8Signal=\"Sell\";\n      }\n      \n      return(Sys8Signal);\n      \n      \n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem8.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 8 entry signals\n\nstring CheckSystem8()\n{\n\n   string Sys8Signal=\"\";\n\n         // ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n         double AtrArray[];\n         CopyBuffer(HandleAtr,0,1,2,AtrArray);\n         ArraySetAsSeries(AtrArray,true);\n\n      // SSL\n      static int HandleSSL = iCustom(_Symbol,PERIOD_CURRENT,\"SSL_Channel_Chart\",3,20); \n         double SSLBearArray[];\n         double SSLBullArray[];\n         double SSLArray[];\n         CopyBuffer(HandleSSL,0,1,2,SSLBearArray);\n         CopyBuffer(HandleSSL,1,1,2,SSLBullArray);\n         CopyBuffer(HandleSSL,2,1,2,SSLArray);\n         ArraySetAsSeries(SSLBearArray,true);\n         ArraySetAsSeries(SSLBullArray,true);\n         ArraySetAsSeries(SSLArray,true);\n         \n         \n      // FVE\n      static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0); \n         double FVEArray[];\n         double SignalArray[];\n         CopyBuffer(HandleFVE,0,1,2,FVEArray);\n         CopyBuffer(HandleFVE,1,1,2,SignalArray);\n         ArraySetAsSeries(FVEArray,true);\n         ArraySetAsSeries(SignalArray,true);\n         \n         \n      // ROC\n      static int HandleROC = iCustom(_Symbol,PERIOD_CURRENT,\"ROC\",18);\n         double ROCArray[];\n         CopyBuffer(HandleROC,0,1,2,ROCArray);\n         ArraySetAsSeries(ROCArray,true);\n      \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,0); \n         double BullsArray[];\n         double BearsArray[];\n         CopyBuffer(HandleASA,0,1,2,BullsArray);\n         CopyBuffer(HandleASA,1,1,2,BearsArray);\n         ArraySetAsSeries(BullsArray,true);\n         ArraySetAsSeries(BearsArray,true);\n               // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n         // Buy conditions\n      bool SSL_buy_signal = (SSLArray[0] > 0 && SSLArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n      bool ROC_buy = (ROCArray[0] > 0);\n      bool ASA_buy = (BullsArray[0] > BearsArray[0]);\n\n      \n      // Sell conditions\n      bool SSL_sell_signal = (SSLArray[0] < 0 && SSLArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n      bool ROC_sell = (ROCArray[0] < 0);\n      bool ASA_sell = (BullsArray[0] < BearsArray[0]);\n      \n      if (SSL_buy_signal && FVE_buy && ROC_buy && ASA_buy)\n      {\n      Print(\"System 8 is now long\");\n      Sys8Signal=\"Buy\";\n      }\n      \n      if (SSL_sell_signal && FVE_sell && ROC_sell && ASA_sell)\n      {\n      Print(\"System 8 is now short\");\n      Sys8Signal=\"Sell\";\n      }\n      \n      return(Sys8Signal);\n      \n      \n}\n"
  },
  {
    "filename": "CheckSystem6JMA.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem6JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 6 Jurik Moving Average specific entry signals\n\nstring CheckSystem6JMA()\n{\n   string Sys6JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 6 JMA Buy Signal\");\n      Sys6JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 6 JMA Sell Signal\");\n      Sys6JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys6JMASignal);\n\n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem6JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 6 Jurik Moving Average specific entry signals\n\nstring CheckSystem6JMA()\n{\n   string Sys6JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 6 JMA Buy Signal\");\n      Sys6JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 6 JMA Sell Signal\");\n      Sys6JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys6JMASignal);\n\n   \n}"
  },
  {
    "filename": "CheckSystem1JMA.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem1JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 with Jurik Moving Average specific entry signals\n\nstring CheckSystem1JMA()\n{\n   string Sys1JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 1 JMA Buy Signal\");\n      Sys1JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 1 JMA Sell Signal\");\n      Sys1JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys1JMASignal);\n\n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem1JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 with Jurik Moving Average specific entry signals\n\nstring CheckSystem1JMA()\n{\n   string Sys1JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 1 JMA Buy Signal\");\n      Sys1JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 1 JMA Sell Signal\");\n      Sys1JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys1JMASignal);\n\n   \n}"
  },
  {
    "filename": "CheckSymbolProfit.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                            CheckSymbolProfit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolProfit (string ProfitSymbol, int OrderType){\n\n   double ProfitSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n   \n      for(int i = PositionsTotal()-1; i>=0; i--)\n      {\n         string CurrencyPair = PositionGetSymbol(i);\n         string CurrentSymbolProfit = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_PROFIT);\n\n         \n         if(PositionGetInteger(POSITION_TYPE)==OrderType)\n         {\n            if(CurrentSymbolProfit==ProfitSymbol)\n            {\n            \n               //System 1\n               if(PositionGetInteger(POSITION_MAGIC)==001)\n               {\n                 System1Count += 1;\n               }\n               //System 2\n               if(PositionGetInteger(POSITION_MAGIC)==002)\n               {\n                 System2Count += 1;\n               }\n               //System 3\n               if(PositionGetInteger(POSITION_MAGIC)==003)\n               {\n                 System3Count += 1;\n               }\n               //System 4\n               if(PositionGetInteger(POSITION_MAGIC)==004)\n               {\n                 System4Count += 1;\n               }\n               //System 5\n               if(PositionGetInteger(POSITION_MAGIC)==005)\n               {\n                 System5Count += 1;\n               }\n               //System 6\n               if(PositionGetInteger(POSITION_MAGIC)==006)\n               {\n                 System6Count += 1;\n               }\n               //System 7\n               if(PositionGetInteger(POSITION_MAGIC)==007)\n               {\n                 System7Count += 1;\n               }\n               //System 8\n               if(PositionGetInteger(POSITION_MAGIC)==008)\n               {\n                 System7Count += 1;\n               }\n               \n            }\n         \n         }\n         \n         \n         \n         \n         \n      }   \n         \n   // Increment preset risk exposures retrieved from each system      \n   if(System1Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   // Returns the total volume exposed to the profit symbol currency\n   return ProfitSymbolExposure;\n   \n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                            CheckSymbolProfit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolProfit (string ProfitSymbol, int OrderType){\n\n   double ProfitSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n   \n      for(int i = PositionsTotal()-1; i>=0; i--)\n      {\n         string CurrencyPair = PositionGetSymbol(i);\n         string CurrentSymbolProfit = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_PROFIT);\n\n         \n         if(PositionGetInteger(POSITION_TYPE)==OrderType)\n         {\n            if(CurrentSymbolProfit==ProfitSymbol)\n            {\n            \n               //System 1\n               if(PositionGetInteger(POSITION_MAGIC)==001)\n               {\n                 System1Count += 1;\n               }\n               //System 2\n               if(PositionGetInteger(POSITION_MAGIC)==002)\n               {\n                 System2Count += 1;\n               }\n               //System 3\n               if(PositionGetInteger(POSITION_MAGIC)==003)\n               {\n                 System3Count += 1;\n               }\n               //System 4\n               if(PositionGetInteger(POSITION_MAGIC)==004)\n               {\n                 System4Count += 1;\n               }\n               //System 5\n               if(PositionGetInteger(POSITION_MAGIC)==005)\n               {\n                 System5Count += 1;\n               }\n               //System 6\n               if(PositionGetInteger(POSITION_MAGIC)==006)\n               {\n                 System6Count += 1;\n               }\n               //System 7\n               if(PositionGetInteger(POSITION_MAGIC)==007)\n               {\n                 System7Count += 1;\n               }\n               //System 8\n               if(PositionGetInteger(POSITION_MAGIC)==008)\n               {\n                 System7Count += 1;\n               }\n               \n            }\n         \n         }\n         \n         \n         \n         \n         \n      }   \n         \n   // Increment preset risk exposures retrieved from each system      \n   if(System1Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   // Returns the total volume exposed to the profit symbol currency\n   return ProfitSymbolExposure;\n   \n}\n"
  },
  {
    "filename": "CheckSystem4Exit.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem4Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 exit signals \n\nstring CheckSystem4Exit()\n{\n\n   string Sys4ExitSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n    \n\n   // Trade exit signals //\n   // Buy exit\n   if(QQE_sell_signal)\n   {\n      Print(\"System 4 Buy Exit Signal\");\n      Sys4ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit\n   if(QQE_buy_signal)\n   {\n      Print(\"System 4 Sell Exit Signal\");\n      Sys4ExitSignal = \"Sell Exit\";\n   }\n\n   return (Sys4ExitSignal);\n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem4Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 exit signals \n\nstring CheckSystem4Exit()\n{\n\n   string Sys4ExitSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n    \n\n   // Trade exit signals //\n   // Buy exit\n   if(QQE_sell_signal)\n   {\n      Print(\"System 4 Buy Exit Signal\");\n      Sys4ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit\n   if(QQE_buy_signal)\n   {\n      Print(\"System 4 Sell Exit Signal\");\n      Sys4ExitSignal = \"Sell Exit\";\n   }\n\n   return (Sys4ExitSignal);\n   \n}"
  },
  {
    "filename": "TradeControlMain.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                           TradeControlScript.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n// System 1\n#include \"CheckSystem1.mq5\"\n#include \"CheckSystem1Exit.mq5\"\n// System 2\n#include \"CheckSystem2.mq5\"\n#include \"CheckSystem2Exit.mq5\"\n// System 3\n#include \"CheckSystem3.mq5\"\n#include \"CheckSystem3Exit.mq5\"\n// System 4\n#include \"CheckSystem4.mq5\"\n#include \"CheckSystem4Exit.mq5\"\n#include \"CheckSystem4AML.mq5\"\n// System 5\n#include \"CheckSystem5.mq5\"\n#include \"CheckSystem5Exit.mq5\"\n// System 6\n#include \"CheckSystem6JMA.mq5\"\n// System 7\n#include \"CheckSys7.mq5\"\n// System 8\n#include \"CheckSystem8.mq5\"\n\n// Check symbol base\n#include \"CheckSymbolBase.mq5\"\n// Check symbol profit\n#include \"CheckSymbolProfit.mq5\"\n\n\nCTrade trade;\nCPositionInfo pos_info;\nCDealInfo m_deal; \n\n// Position modifier count\nint positionmodifiercount = 0;\n\n// Init position count\nint initpositioncount = 0;\n\n// Current symbol base pair\nstring SymbolBase = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_BASE);\n\n// Current symbol profit pair\nstring SymbolProfit = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_PROFIT);\n\n// Currency exposure risk\ndouble ExposureLimit = 0.045;\n\n// Optimization\ninput int Opt_allow = 1;\n\nint OnInit()\n{\n      // Checking for open positions   \n      double askp = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n      \n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  //It is a Buy\n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; // It is a Sell\n              }\n        }\n      \n      if(Buy_opened || Sell_opened){\n         Alert(\"Positions already open\");\n         Print(\"Positions already open, setting init_position_count == 1\");\n         initpositioncount += 1;   \n      }\n\n   return(INIT_SUCCEEDED);\n}\n\nvoid OnDeinit(const int reason)\n{\n\n}\n\nvoid OnTick()\n{\n\n// Executed on tick\n//---------------------------------------------------------------------------------------//\n      // Checking for open positions by EA magic number (trade identifier)\n      // System 1\n      bool AS1_buy_opened=false;  \n      bool AS1_sell_opened=false;\n      // System 2\n      bool AS2_buy_opened=false;  \n      bool AS2_sell_opened=false;\n      // System 3\n      bool AS3_buy_opened=false;\n      bool AS3_sell_opened=false;\n      // System 4\n      bool AS4_buy_opened=false;  \n      bool AS4_sell_opened=false;\n      // System5\n      bool AS5_buy_opened=false;  \n      bool AS5_sell_opened=false;\n      // System6\n      bool AS6_buy_opened=false;\n      bool AS6_sell_opened=false;\n      // System7\n      bool AS7_buy_opened=false;\n      bool AS7_sell_opened=false;\n      // System8\n      bool AS8_buy_opened=false;\n      bool AS8_sell_opened=false;\n\n      if(PositionSelect(_Symbol)==true){\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               AS7_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               AS8_buy_opened=true;\n            } \n                       \n         }\n         else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               AS7_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               AS8_sell_opened=true;\n            } \n                                        \n         }\n      }\n\n//---------------------------------------------------------------------------------------//\n      \n      // Checking trailing stops for systems with trailing stops (1, 3, 5, 6)\n      \n      // Average true range\n      static int HandleATR = iATR(_Symbol, PERIOD_CURRENT,14);\n      double ATRArray[];\n      CopyBuffer(HandleATR,0,1,2,ATRArray);\n      ArraySetAsSeries(ATRArray,true);\n      \n      // System 1. Current open positions1 relates to system 1's open positions.\n      int current_open_positions1 = CountOpenPositions(001);\n\n      if(AS1_buy_opened && current_open_positions1 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         CheckTrailingStopBuyZero(Ask,001);\n        }\n\n      if(AS1_sell_opened && current_open_positions1 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         CheckTrailingStopSellZero(Bid,001);\n        }\n      // System 3. Current open positions3 relates to system 3's open positions.\n      int current_open_positions3 = CountOpenPositions(003);\n          \n      if (current_open_positions3 == 0 && positionmodifiercount == 1)\n         {\n            positionmodifiercount -= 1 ;\n         }\n             \n      if(AS3_buy_opened && current_open_positions3 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor,003);\n        }\n      \n      if(AS3_sell_opened && current_open_positions3 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor,003);\n        }      \n      // System 5. Current open positions5 relates to system 5's open positions.\n      int current_open_positions5 = CountOpenPositions(005);\n          \n      if (current_open_positions5 == 0 && positionmodifiercount == 1)\n         {\n            positionmodifiercount -= 1 ;\n         }\n             \n      if(AS5_buy_opened && current_open_positions5 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor,005);\n        }\n      \n      if(AS5_sell_opened && current_open_positions5 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor,005);\n        }\n\n      int current_open_positions6 = CountOpenPositions(006);\n      // System 6. Current open positions6 relates to system 6's open positions.\n      if(AS6_buy_opened && current_open_positions6 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         CheckTrailingStopBuyZero(Ask,006);\n        }\n\n      if(AS1_sell_opened && current_open_positions1 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         CheckTrailingStopSellZero(Bid,006);\n        }\n\n\n\n// Executed on formation of a new bar\n//---------------------------------------------------------------------------------------//\n\n\n   // Restrict code to process only once per bar\n   static datetime timestamp;\n   datetime time = iTime(_Symbol,PERIOD_CURRENT,0); // Time of current candle\n   if(timestamp != time)\n   {\n      timestamp = time;\n      \n      \n     if(initpositioncount == 0)\n     {\n      \n      CheckSystem1();\n      CheckSystem1Exit();\n      \n      CheckSystem2();\n      CheckSystem2Exit();\n      \n      CheckSystem3();\n      CheckSystem3Exit();\n      \n      CheckSystem4();\n      CheckSystem4Exit();\n      CheckSystem4AML();\n      \n      CheckSystem6JMA();\n      \n      CheckSystem5();\n      CheckSystem5Exit();\n      \n      CheckSys7();    \n      CheckSystem8();\n         \n      \n           \n      // Average true range\n      static int HandleAtr = iATR(_Symbol,PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n//---------------------------------------------------------------------------------------//\n\n      // Checking for open positions by EA magic number\n      // System 1\n      bool S1_buy_opened=false;  \n      bool S1_sell_opened=false;\n      // System 2\n      bool S2_buy_opened=false;  \n      bool S2_sell_opened=false;\n      // System 3\n      bool S3_buy_opened=false;\n      bool S3_sell_opened=false;\n      // System 4\n      bool S4_buy_opened=false;  \n      bool S4_sell_opened=false;\n      // System5\n      bool S5_buy_opened=false;  \n      bool S5_sell_opened=false;\n      // System6\n      bool S6_buy_opened=false;\n      bool S6_sell_opened=false;\n      // System7\n      bool S7_buy_opened=false;\n      bool S7_sell_opened=false;\n      // System8\n      bool S8_buy_opened=false;\n      bool S8_sell_opened=false;\n\n      if(PositionSelect(_Symbol)==true){\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               S1_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               S2_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               S3_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               S4_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               S5_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               S6_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               S7_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               S8_buy_opened=true;\n            } \n                       \n         }\n         else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               S1_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               S2_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               S3_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               S4_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               S5_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               S6_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               S7_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               S8_sell_opened=true;\n            } \n                                        \n         }\n      }\n      \n//---------------------------------------------------------------------------------------//      \n      // Exiting positions\n      // System 1\n      if(S1_buy_opened && (CheckSystem1Exit()==\"Buy Exit\" || CheckSystem1()==\"Sell\"))\n      {\n         CloseAllPositions(001);\n      }\n      \n      if(S1_sell_opened && (CheckSystem1Exit()==\"Sell Exit\" || CheckSystem1()==\"Buy\"))\n      {\n         CloseAllPositions(001);\n      }\n      \n      // System 2\n      if(S2_buy_opened && (CheckSystem2Exit()==\"Buy Exit\" || CheckSystem2()==\"Sell\"))\n      {\n         CloseAllPositions(002);\n      }\n      \n      if(S2_sell_opened && (CheckSystem2Exit()==\"Sell Exit\" || CheckSystem2()==\"Buy\"))\n      {\n         CloseAllPositions(002);\n      }\n      \n      // System 3\n      if(S3_sell_opened && (CheckSystem3()==\"Buy\" || CheckSystem3Exit()==\"Buy Exit\"))\n      {\n         CloseAllPositions(003);\n      }\n      if(S3_buy_opened && (CheckSystem3()==\"Sell\" || CheckSystem3Exit()==\"Sell Exit\"))\n      {\n         CloseAllPositions(003);\n      }\n      \n      // System 4   \n      if(S4_buy_opened && (CheckSystem4Exit()==\"Buy Exit\" || CheckSystem4()==\"Sell\"))\n      {\n         CloseAllPositions(004);\n      }\n      \n      if(S4_sell_opened && (CheckSystem4Exit()==\"Sell Exit\" || CheckSystem4()==\"Buy\"))\n      {\n         CloseAllPositions(004);\n      }\n      \n      // System 5\n      if(S5_buy_opened && (CheckSystem5Exit()==\"Buy Exit\" || CheckSystem5()==\"Sell\"))\n      {\n         CloseAllPositions(005);\n      }\n      \n      if(S5_sell_opened && (CheckSystem5Exit()==\"Sell Exit\" || CheckSystem5()==\"Buy\"))\n      {\n         CloseAllPositions(005);\n      }\n      \n      // System 6\n      if(S6_buy_opened && (CheckSystem1Exit()==\"Buy Exit\" || CheckSystem6JMA()==\"Sell\"))\n      {\n         CloseAllPositions(006);\n      }\n      \n      if(S6_sell_opened && (CheckSystem1Exit()==\"Sell Exit\" || CheckSystem6JMA()==\"Buy\"))\n      {\n         CloseAllPositions(006);\n      }\n      \n      // System 7   \n      if(S7_buy_opened && (CheckSys7()==\"Sell\"))\n      {\n         CloseAllPositions(007);\n      }\n      \n      if(S7_sell_opened && (CheckSys7()==\"Buy\"))\n      {\n         CloseAllPositions(007);\n      } \n      \n      // System 8   \n      if(S8_buy_opened && (CheckSystem8()==\"Sell\"))\n      {\n         CloseAllPositions(008);\n      }\n      \n      if(S8_sell_opened && (CheckSystem8()==\"Buy\"))\n      {\n         CloseAllPositions(008);\n      } \n                   \n     \n             \n//---------------------------------------------------------------------------------------//\n\n      // System 1\n      // Buy orders\n      if(CheckSystem1()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double AtrFactorTP2 = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         double tp2 = ask + AtrFactorTP2;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(001);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 1 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,tp2,\"System 1 Buy: 2nd Trade\");\n         }  \n      }\n      \n      \n      \n      \n      // Sell orders\n      if(CheckSystem1()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double AtrFactorTP2 = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         double tp2 = bid - AtrFactorTP2;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(001);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 1 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,tp2,\"System 1 Sell: 2nd Trade\");  \n         } \n         \n      }\n      \n \n       \n//---------------------------------------------------------------------------------------//\n      \n      // System 2\n      // Buy orders\n      if(CheckSystem2()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(002);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 2 Buy\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem2()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(002);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 2 Sell\");  \n         } \n         \n      }\n//---------------------------------------------------------------------------------------//\n      \n      // System 3\n      // Buy orders\n      if(CheckSystem3()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(003); \n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 3 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,NULL,\"System 3 Buy: 2nd Trade\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem3()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(003);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 3 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,NULL,\"System 3 Sell: 2nd Trade\"); \n         } \n         \n      }       \n//---------------------------------------------------------------------------------------//\n      \n      // System 4\n      // Buy orders AML\n      if(CheckSystem4AML()==\"AML Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(004);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 4 AML Buy\"); \n         } \n         \n      }\n\n      // Sell orders AML\n      if(CheckSystem4AML()==\"AML Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(004);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 4 AML Sell\");  \n         } \n         \n      }\n      \n//---------------------------------------------------------------------------------------//\n      \n      // System 5\n      // Buy orders\n      if(CheckSystem5()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(005); \n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 5 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,NULL,\"System 5 Buy: 2nd Trade\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem5()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(005);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 5 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,NULL,\"System 5 Sell: 2nd Trade\");  \n         } \n         \n      }\n\n\n//---------------------------------------------------------------------------------------//      \n      // System 6\n      // Buy orders JMA\n      if(CheckSystem6JMA()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         \n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(006);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 1 JMA Buy\");\n         } \n         \n      }\n      \n      // Sell orders JMA\n      if(CheckSystem6JMA()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(006);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 1 JMA Sell\");  \n         } \n         \n      } \n\n//---------------------------------------------------------------------------------------//\n      \n      // System 7\n      // Buy orders\n      if(CheckSys7()==\"Buy\")   \n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(007);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 7 Buy\");  \n         }  \n         \n         \n      }\n      // Sell orders\n      if(CheckSys7()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(007);  \n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 7 Sell\"); \n         } \n       \n      \n      }\n//---------------------------------------------------------------------------------------//\n      \n      // System 8\n      // Buy orders\n      if(CheckSystem8() == \"Buy\") \n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n          \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n           trade.SetExpertMagicNumber(008);\n           trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 8 Buy\");   \n         } \n       \n\n                \n      }\n      // Sell orders\n      if(CheckSystem8() == \"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n          \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n           trade.SetExpertMagicNumber(008);\n           trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 8 Sell\");    \n         } \n       \n      \n      }\n   \n   }\n   \n  // If there are positions open, counter is reset and above code is not run   \n   if(initpositioncount == 1)\n      {\n      Print(\"Counter reset\");\n      initpositioncount -= 1;\n      }\n        \n  }\n  \n}\n//---------------------------------------------------------------------------------------//\n\n// FUNCTIONS //\n\n\n//+------------------------------------------------------------------+\n//| Close All Positions                                              |\n//+------------------------------------------------------------------+\n\nvoid CloseAllPositions(ulong Magic)\n  {\n\n// Count down until there are no positions left\n   for(int i = PositionsTotal()-1; i>=0; i--)\n     {\n        string symbol=PositionGetSymbol(i); // get the symbol of the position\n        if(_Symbol == symbol)\n        {\n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // Get the position number\n               ulong ticket = PositionGetTicket(i);\n      \n               // Close the position\n               trade.PositionClose(ticket);\n        \n            } \n         }\n     }\n\n\n  }\n  \n  \n//+------------------------------------------------------------------+\n//| Count Open Positions                                             |\n//+------------------------------------------------------------------+\nint CountOpenPositions(ulong Magic)\n   {\n   \n      int NumberOfOpenPositions = 0;\n      \n      for(int i = PositionsTotal()-1; i>=0; i--)\n      {\n         string CurrencyPair = PositionGetSymbol(i);\n         \n         if(Symbol()==CurrencyPair)\n         {\n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               NumberOfOpenPositions = NumberOfOpenPositions + 1;\n            }     \n         }\n      }\n\n      return NumberOfOpenPositions;      \n\n   } \n\n\n//+------------------------------------------------------------------+\n//| Check Buy Trailing Stop                                                                |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopBuy(double ask, double AtrFactor, ulong Magic)\n  {\n\n// set the stop loss to 150 points\n   double SL=NormalizeDouble(ask-AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n                  \n               if(PositionGetInteger(POSITION_MAGIC)==Magic)\n               {\n           \n                  // get the ticket number\n                  ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n      \n                  // get position open price\n                  double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n      \n                  // calculate the current stop loss\n                  double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n                  \n                  // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                  double MinTradeStops = 20*_Point;\n                     \n         \n                  // Check if stop loss is too close to price or if price has moved back past the open price\n                  if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n                    {\n                     CloseAllPositions(Magic);\n                    }  \n                     \n                     \n                  else\n                     {\n                        // move stop loss to open price, therefore zero loss\n                        if(CurrentStopLoss < PositionOpen && positionmodifiercount == 0)\n                          {\n                           trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                           \n                          }\n                        // if current stop loss is more than 150 points\n                        if(CurrentStopLoss < SL && positionmodifiercount == 1)\n                          {\n                           // move the stop loss\n                           trade.PositionModify(PositionTicket,SL,NULL);\n                          }\n                          \n                        if(positionmodifiercount == 0){\n                           positionmodifiercount += 1;\n                          }\n      \n                     }\n                  \n                }\n           \n          }\n        }\n      }\n    }\n\n\n//+------------------------------------------------------------------+\n//| Check Sell Trailing Stop                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopSell(double bid, double AtrFactor, ulong Magic)\n  {\n\n// set the stop loss to ATR points\n   double SL=NormalizeDouble(bid+AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n            \n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n            \n            \n               if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n                 {\n                  // get the ticket number\n                  ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n      \n                  // get position open price\n                  double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n      \n                  // calculate the current stop loss\n                  double CurrentStopLoss = PositionGetDouble(POSITION_SL); //works\n                  \n                  // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                   double MinTradeStops = 20*_Point;\n                     \n         \n                  // Check if stop loss is too close to price or if price has moved back past the open price\n                  if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n                    {\n                        CloseAllPositions(Magic);\n                    }\n      \n                  \n                  else\n                     {\n                  \n                     // move stop loss to open price, therefore zero loss\n                     if(CurrentStopLoss > PositionOpen && positionmodifiercount == 0)\n                       {\n                       //Print(CurrentStopLoss);\n                        trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                        \n                       }\n                     // if current stop loss is more than ATR points\n                     if(CurrentStopLoss > SL && positionmodifiercount == 1)\n                       {\n                        // move the stop loss\n                        trade.PositionModify(PositionTicket,SL,NULL);\n                       }\n                       \n                     if(positionmodifiercount == 0){\n                       positionmodifiercount += 1;\n                       }\n      \n                     }\n \n          }\n        }\n      }\n    }\n  }\n\n\n//+------------------------------------------------------------------+\n//| Check Buy Trailing Stop to zero                                  |\n//+------------------------------------------------------------------+\n// Moving stop loss to a zero position only\nvoid CheckTrailingStopBuyZero(double ask, ulong Magic)\n  {\n\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n           \n           if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // get the ticket number\n               ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n   \n               // get position open price\n               double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n   \n               // calculate the current stop loss\n               double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n               \n               double TP = PositionGetDouble(POSITION_TP);\n               \n               // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n               double MinTradeStops = 20*_Point;\n                  \n      \n               // Check if stop loss is too close to price or if price has moved back past the open price\n               if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n                 {\n                  CloseAllPositions(Magic);\n                 }  \n                  \n                  \n               else\n                  {\n                     // move stop loss to open price, therefore zero loss\n                     if(CurrentStopLoss < PositionOpen)\n                       {\n                        trade.PositionModify(PositionTicket,PositionOpen,TP);\n                        \n                       }\n   \n                  }\n                      \n           }\n         }\n       }\n     }\n   }\n\n\n//+------------------------------------------------------------------+\n//| Check Sell Trailing Stop to Zero                                 |  \n//+------------------------------------------------------------------+\n// Moving the stop loss to a zero position only\nvoid CheckTrailingStopSellZero(double bid, ulong Magic)\n  {\n\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n           {\n           \n           if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // get the ticket number\n               ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n   \n               // get position open price\n               double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n   \n               // calculate the current stop loss\n               double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n               \n               double TP = PositionGetDouble(POSITION_TP);\n               \n               // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                double MinTradeStops = 20*_Point;\n                  \n      \n               // Check if stop loss is too close to price or if price has moved back past the open price\n               if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n                 {\n                     CloseAllPositions(Magic);\n                 }\n   \n               \n               else\n                  {\n               \n                  // move stop loss to open price, therefore zero loss\n                  if(CurrentStopLoss > PositionOpen)\n                    {\n                    //Print(CurrentStopLoss);\n                     trade.PositionModify(PositionTicket,PositionOpen,TP);\n                     \n                    }\n   \n                  }\n \n           }\n           \n         }\n       }\n     }\n   }\n\n\n//+------------------------------------------------------------------+\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                           TradeControlScript.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n// System 1\n#include \"CheckSystem1.mq5\"\n#include \"CheckSystem1Exit.mq5\"\n// System 2\n#include \"CheckSystem2.mq5\"\n#include \"CheckSystem2Exit.mq5\"\n// System 3\n#include \"CheckSystem3.mq5\"\n#include \"CheckSystem3Exit.mq5\"\n// System 4\n#include \"CheckSystem4.mq5\"\n#include \"CheckSystem4Exit.mq5\"\n#include \"CheckSystem4AML.mq5\"\n// System 5\n#include \"CheckSystem5.mq5\"\n#include \"CheckSystem5Exit.mq5\"\n// System 6\n#include \"CheckSystem6JMA.mq5\"\n// System 7\n#include \"CheckSys7.mq5\"\n// System 8\n#include \"CheckSystem8.mq5\"\n\n// Check symbol base\n#include \"CheckSymbolBase.mq5\"\n// Check symbol profit\n#include \"CheckSymbolProfit.mq5\"\n\n\nCTrade trade;\nCPositionInfo pos_info;\nCDealInfo m_deal; \n\n// Position modifier count\nint positionmodifiercount = 0;\n\n// Init position count\nint initpositioncount = 0;\n\n// Current symbol base pair\nstring SymbolBase = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_BASE);\n\n// Current symbol profit pair\nstring SymbolProfit = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_PROFIT);\n\n// Currency exposure risk\ndouble ExposureLimit = 0.045;\n\n// Optimization\ninput int Opt_allow = 1;\n\nint OnInit()\n{\n      // Checking for open positions   \n      double askp = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n      \n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  //It is a Buy\n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; // It is a Sell\n              }\n        }\n      \n      if(Buy_opened || Sell_opened){\n         Alert(\"Positions already open\");\n         Print(\"Positions already open, setting init_position_count == 1\");\n         initpositioncount += 1;   \n      }\n\n   return(INIT_SUCCEEDED);\n}\n\nvoid OnDeinit(const int reason)\n{\n\n}\n\nvoid OnTick()\n{\n\n// Executed on tick\n//---------------------------------------------------------------------------------------//\n      // Checking for open positions by EA magic number (trade identifier)\n      // System 1\n      bool AS1_buy_opened=false;  \n      bool AS1_sell_opened=false;\n      // System 2\n      bool AS2_buy_opened=false;  \n      bool AS2_sell_opened=false;\n      // System 3\n      bool AS3_buy_opened=false;\n      bool AS3_sell_opened=false;\n      // System 4\n      bool AS4_buy_opened=false;  \n      bool AS4_sell_opened=false;\n      // System5\n      bool AS5_buy_opened=false;  \n      bool AS5_sell_opened=false;\n      // System6\n      bool AS6_buy_opened=false;\n      bool AS6_sell_opened=false;\n      // System7\n      bool AS7_buy_opened=false;\n      bool AS7_sell_opened=false;\n      // System8\n      bool AS8_buy_opened=false;\n      bool AS8_sell_opened=false;\n\n      if(PositionSelect(_Symbol)==true){\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               AS7_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               AS8_buy_opened=true;\n            } \n                       \n         }\n         else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_sell_opened=true;\n            }\n         "
  },
  {
    "filename": "CheckSystem2.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem2.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 entry signals\n\nstring CheckSystem2()\n{\n   string Sys2Signal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n   bool Solar_buy = (SolarArray[0] > 0);\n\n \n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      \n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n   bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n   bool Solar_sell = (SolarArray[0] < 0);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(Trinity_buy && Wad_vol && FVE_buy && Solar_buy)\n   {\n      Print(\"System 2 Buy Signal\");\n      Sys2Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && Wad_vol && FVE_sell && Solar_sell)\n   {\n      Print(\"System 2 Sell Signal\");\n      Sys2Signal = \"Sell\";\n   }\n   \n\n   return (Sys2Signal);\n\n   \n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem2.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 entry signals\n\nstring CheckSystem2()\n{\n   string Sys2Signal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n   bool Solar_buy = (SolarArray[0] > 0);\n\n \n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      \n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n   bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n   bool Solar_sell = (SolarArray[0] < 0);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(Trinity_buy && Wad_vol && FVE_buy && Solar_buy)\n   {\n      Print(\"System 2 Buy Signal\");\n      Sys2Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && Wad_vol && FVE_sell && Solar_sell)\n   {\n      Print(\"System 2 Sell Signal\");\n      Sys2Signal = \"Sell\";\n   }\n   \n\n   return (Sys2Signal);\n\n   \n}\n"
  },
  {
    "filename": "CheckSystem5.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem5.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 entry signals \n\nstring CheckSystem5()\n{\n   string Sys5Signal = \"\";\n   \n   // Indicator inputs //\n   int QQE_smooth_factor = 5;\n   int Trinity_period = 30;\n   int Trinity_smooth = 34;\n   int Wad_fast_MA = 20;\n   int Wad_slow_MA = 40;\n   int Wad_bollinger = 20;\n   int Wad_bollinger_dev = 2;\n   int Wad_sens = 150;\n   int Wad_DZP = 3000;\n   int UO_Oscillator = 3;\n   int UO_period = 14;\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n   bool Trinity_buy = (TrinityArray[0] > 0);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n      \n      \n   // Volume conditions\n   bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n   bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n   bool Trinity_sell = (TrinityArray[0] < 0);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 5 Buy Signal\");\n      Sys5Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 5 Sell Signal\");\n      Sys5Signal = \"Sell\";\n   }\n   \n\n   return (Sys5Signal);\n\n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem5.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 entry signals \n\nstring CheckSystem5()\n{\n   string Sys5Signal = \"\";\n   \n   // Indicator inputs //\n   int QQE_smooth_factor = 5;\n   int Trinity_period = 30;\n   int Trinity_smooth = 34;\n   int Wad_fast_MA = 20;\n   int Wad_slow_MA = 40;\n   int Wad_bollinger = 20;\n   int Wad_bollinger_dev = 2;\n   int Wad_sens = 150;\n   int Wad_DZP = 3000;\n   int UO_Oscillator = 3;\n   int UO_period = 14;\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n   bool Trinity_buy = (TrinityArray[0] > 0);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n      \n      \n   // Volume conditions\n   bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n   bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n   bool Trinity_sell = (TrinityArray[0] < 0);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 5 Buy Signal\");\n      Sys5Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 5 Sell Signal\");\n      Sys5Signal = \"Sell\";\n   }\n   \n\n   return (Sys5Signal);\n\n   \n}"
  },
  {
    "filename": "CheckSystem4.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem4.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 entry signals \n\nstring CheckSystem4()\n{\n\n   string Sys4Signal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    \n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    \n\n   \n   // Trade entry signals //   \n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 4 Buy Signal\");\n      Sys4Signal = \"Buy\";\n   }\n   \n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 4 Sell Signal\");\n      Sys4Signal = \"Sell\";\n   }\n   \n   \n   return (Sys4Signal);\n   \n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem4.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 entry signals \n\nstring CheckSystem4()\n{\n\n   string Sys4Signal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    \n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    \n\n   \n   // Trade entry signals //   \n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 4 Buy Signal\");\n      Sys4Signal = \"Buy\";\n   }\n   \n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 4 Sell Signal\");\n      Sys4Signal = \"Sell\";\n   }\n   \n   \n   return (Sys4Signal);\n   \n   \n}"
  },
  {
    "filename": "CheckSystem2Exit.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem2Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 exit signals \n\nstring CheckSystem2Exit()\n{\n   string Sys2ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n\n\n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n\n\n   // Trade Exit signals //\n   // Buy exit signal\n   if(Trinity_sell)\n   {\n      Print(\"System 2 Buy Exit Signal\");\n      Sys2ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Trinity_buy)\n   {\n      Print(\"System 2 Sell Exit Signal\");\n      Sys2ExitSignal = \"Sell Exit\";\n   }\n   \n   \n   return (Sys2ExitSignal);\n\n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem2Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 exit signals \n\nstring CheckSystem2Exit()\n{\n   string Sys2ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n\n\n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n\n\n   // Trade Exit signals //\n   // Buy exit signal\n   if(Trinity_sell)\n   {\n      Print(\"System 2 Buy Exit Signal\");\n      Sys2ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Trinity_buy)\n   {\n      Print(\"System 2 Sell Exit Signal\");\n      Sys2ExitSignal = \"Sell Exit\";\n   }\n   \n   \n   return (Sys2ExitSignal);\n\n}\n"
  },
  {
    "filename": "CheckSystem5Exit.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem5Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 exit signals \n\nstring CheckSystem5Exit()\n{\n   \n   string Sys5ExitSignal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n      \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n\n   // Trade exit signals //\n   // Buy exit signal\n   if(QQE_sell_signal)\n   {\n      Print(\"System 5 Buy Exit Signal\");\n      Sys5ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(QQE_buy_signal)\n   {\n      Print(\"System 5 Sell Exit Signal\");\n      Sys5ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys5ExitSignal);\n   \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem5Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 exit signals \n\nstring CheckSystem5Exit()\n{\n   \n   string Sys5ExitSignal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n      \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n\n   // Trade exit signals //\n   // Buy exit signal\n   if(QQE_sell_signal)\n   {\n      Print(\"System 5 Buy Exit Signal\");\n      Sys5ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(QQE_buy_signal)\n   {\n      Print(\"System 5 Sell Exit Signal\");\n      Sys5ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys5ExitSignal);\n   \n}"
  },
  {
    "filename": "CheckSystem3Exit.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem3Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 exit signals \n\nstring CheckSystem3Exit()\n{\n   string Sys3ExitSignal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      \n   //Conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n    \n   bool Buy_Exit_Signal = Trinity_sell;\n   bool Sell_Exit_Signal = Trinity_buy;\n    \n   //Trade Exit Signals\n   // Buy exit signal\n   if(Buy_Exit_Signal)\n   {\n      Print(\"System 3 Buy Exit Signal\");\n      Sys3ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Sell_Exit_Signal)\n   {\n      Print(\"System 3 Sell Exit Signal\");\n      Sys3ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys3ExitSignal);\n}      ",
    "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem3Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 exit signals \n\nstring CheckSystem3Exit()\n{\n   string Sys3ExitSignal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      \n   //Conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n    \n   bool Buy_Exit_Signal = Trinity_sell;\n   bool Sell_Exit_Signal = Trinity_buy;\n    \n   //Trade Exit Signals\n   // Buy exit signal\n   if(Buy_Exit_Signal)\n   {\n      Print(\"System 3 Buy Exit Signal\");\n      Sys3ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Sell_Exit_Signal)\n   {\n      Print(\"System 3 Sell Exit Signal\");\n      Sys3ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys3ExitSignal);\n}      "
  },
  {
    "filename": "CheckSystem4AML.mq5",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem4AML.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 Advanced Market Line specific entry signals \n\nstring CheckSystem4AML()\n{\n\n   string Sys4AMLSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    bool AML_buy_signal = (CloseArray[0] > AMLArray[0] && CloseArray[1] < AMLArray[1]);\n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    bool AML_sell_signal = (CloseArray[0] < AMLArray[0] && CloseArray[1] > AMLArray[1]);\n\n   \n   // Trade entry signals //   \n   // AML buy signal\n   if(QQE_buy && Trinity_buy && Wad_vol_buy && UO_buy && AML_buy_signal)\n   {\n      Print(\"System 4 AML Buy Signal\");\n      Sys4AMLSignal = \"AML Buy\";\n   }\n      \n   // AML sell signal\n   if(QQE_sell && Trinity_sell && Wad_vol_sell && UO_sell && AML_sell_signal)\n   {\n      Print(\"System 4 AML Sell Signal\");\n      Sys4AMLSignal = \"AML Sell\";\n   }\n\n   return (Sys4AMLSignal);\n   \n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem4AML.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 Advanced Market Line specific entry signals \n\nstring CheckSystem4AML()\n{\n\n   string Sys4AMLSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    bool AML_buy_signal = (CloseArray[0] > AMLArray[0] && CloseArray[1] < AMLArray[1]);\n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    bool AML_sell_signal = (CloseArray[0] < AMLArray[0] && CloseArray[1] > AMLArray[1]);\n\n   \n   // Trade entry signals //   \n   // AML buy signal\n   if(QQE_buy && Trinity_buy && Wad_vol_buy && UO_buy && AML_buy_signal)\n   {\n      Print(\"System 4 AML Buy Signal\");\n      Sys4AMLSignal = \"AML Buy\";\n   }\n      \n   // AML sell signal\n   if(QQE_sell && Trinity_sell && Wad_vol_sell && UO_sell && AML_sell_signal)\n   {\n      Print(\"System 4 AML Sell Signal\");\n      Sys4AMLSignal = \"AML Sell\";\n   }\n\n   return (Sys4AMLSignal);\n   \n}\n"
  },
  {
    "filename": "DeepLearning.mqh",
    "source_type": "KOD",
    "content": "#include <DeepLearningLibrary.mqh>\n\nclass DeepLearning\n  {\npublic:\n   //-------------------------------\n   // Define the cost functions and its derivatives\n   class Loss;\n   // Define metrics for evaluation\n   class Metrics;\n   \n   //-------------------------------\n   // Dense Connected Layer\n   class DenseLayer;\n   // Activation Function Layer \n   class ActivationLayer;\n   // Softmax function Layer\n   class SoftmaxLayer;\n   // Dropout Layer to Enhance Overffiting\n   class DropoutLayer;\n\n   //--------------------------------\n   // Convolutional Neural Net Layer\n   class ConvolutionalLayer;\n   // Max Pooling Layer\n   class MaxPoolingLayer;\n   // Flatten Layer\n   class FlattenLayer;\n   // Sum Convolutional Layer\n   class SumConvLayer;\n\n   //--------------------------------\n   //Long Short-Term Memory Layer\n   class LSTMLayer;\n   // Bidirectional LSTM layer\n   class BiLSTMLayer;\n   \n   \n   //Methods\n   virtual matrix    Output(matrix &X)                {return X*0;   }\n   virtual matrix    GradDescent(matrix &Ey)          {return Ey*0;  }\n   virtual void      Update(void)                     {              }\n   virtual void      SaveWeights(int k,string IAname) {              }\n   virtual void      LoadWeights(int k,string IAname) {              }\n   virtual void      SetDrop(double Drop)             {              }\n   virtual void      SetAdam(double B1, double B2, double Alph) {    }\n   \n   \n   \n   //=============================\n   matrix   InitWeights(matrix &M);\n   matrix   ZeroMatrix(matrix &M);\n   void     SaveMatrix(matrix &M, string M_name);\n   matrix   LoadMatrix(string M_name);\n   matrix   Concatenate(matrix &X, matrix &H);\n   \n   //Convolution \n   matrix VertConvV(matrix &A, matrix &B);\n   matrix VertConvF(matrix &A, matrix &B);\n   matrix VertInv(matrix &A);\n   \n   matrix HorConvV(matrix &A, matrix &B);\n   matrix HorConvF(matrix &A, matrix &B);\n   matrix HorInv(matrix &A);\n   \n   //Activation\n   matrix Sig(matrix &X);\n   matrix Tanh(matrix &X);\n   matrix ReLU(matrix &X);\n   \n   matrix dSig(matrix &X);\n   matrix dTanh(matrix &X);\n   matrix dReLU(matrix &X);\n   \n   //ADAM optimizer\n   matrix AdamM(matrix &m, matrix &dX,double beta1);\n   matrix AdamV(matrix &v, matrix &dX,double beta2);\n   matrix Adam(double it, matrix &m, matrix &v,double beta1, double beta2, double alpha);\n   \n   \n  };\n \n//+------------------------------------------------------------------+\n//|   Deep Learning Methodes                                         |\n//+------------------------------------------------------------------+\nmatrix DeepLearning::InitWeights(matrix &M)\n{\n   matrix W;\n   W = M;\n   for(int i=0;i<W.Rows();i++)\n     {for(int j=0;j<W.Cols();j++)\n        {W[i][j] = (2.0*(MathRand()/32766.0) -1.0);}}\n         \nreturn W;\n}\nmatrix DeepLearning::ZeroMatrix(matrix &M)\n{\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = 0;}}\n      \nreturn M;\n}\nvoid DeepLearning::SaveMatrix(matrix &M,string M_name)\n{\n   //transforma a matrix M num vetor de strings\n   ulong Srows , SCols;\n   Srows = M.Rows();\n   SCols = M.Cols();\n   string csv_name;\n   csv_name = M_name;\n   \n   string V[];\n   ArrayResize(V,Srows);\n   \n   //Zera o vetor de strings\n   for(int i=0;i<ArraySize(V);i++)\n     {V[i] = NULL;}\n      \n   //Prepara o vetor com as classes \n\n   for(int i=0;i<Srows;i++)\n     {for(int j=0;j<SCols;j++)\n         {\n         if(j == SCols-1) V[i] = V[i] + DoubleToString(M[i][j]);\n         else V[i] = V[i] + DoubleToString(M[i][j]) + \",\";}}     \n   \n   //Abre o arquivo para ser escrito\n   int h=FileOpen(csv_name,FILE_WRITE|FILE_ANSI|FILE_CSV);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE) Alert(\"Error opening file\");\n   \n   for(int i=0;i<Srows;i++)\n      {\n      FileWrite(h,V[i]);\n      }\n   FileClose(h);\n}\nmatrix DeepLearning::LoadMatrix(string M_name)\n{\n   //Le apenas a primeira linha para saber o n\u00famero de colunas\n   string L1;\n   string csv_name;\n   csv_name = M_name;\n   //Abre o arquivo para ser lido\n   int h1=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_TXT);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h1==INVALID_HANDLE)   Alert(\"Error opening file\");\n   L1 = FileReadString(h1);\n   FileClose(h1);\n   \n   //L1 possui agora a primeira linha da matriz\n   //L\u00ea quantas colunas s\u00e3o pelo n\u00famero de v\u00edrgulas\n   \n   int num_columns = 1; \n   \n   for(int i=0;i<L1.Length();i++)\n     {\n      if(L1.Substr(i,1) == \",\") num_columns++;\n     }\n   \n   //Abre o arquivo para ser lido\n   int h=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_CSV,\",\");\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE)   Alert(\"Error opening file\");\n\n   string read_x;\n   string m[]; //Vetor que receber\u00e1 os dados\n   int    m_size = 0;\n   \n   matrix A;   // Matriz que retornar\u00e1 com os dados\n   int A_size = 0;\n   //Come\u00e7a com a leitura da primeira linha\n   \n   while(!FileIsEnding(h))\n   {\n      ArrayResize(m,m_size+1);\n      read_x = FileReadString(h);   // L\u00ea o conteudo at\u00e9 a virgula \u00e9 passa pra pr\u00f3xima\n      m[m_size] = read_x;\n   if(!FileIsEnding(h)) m_size++;  \n   }\n   FileClose(h);\n   \n   int num_rows;\n   num_rows = (m_size + 1)/num_columns;\n   \n   if(((m_size +1)% num_columns) != 0 )   Alert(\"Error the matrix data is incomplete\");\n   else\n   {\n   \n   //Preparar a Matriz A\n   A.Init(num_rows,num_columns);\n   \n   for(int i=0;i<num_rows;i++)\n      {for(int j=0;j<num_columns;j++)\n        {A[i][j] = StringToDouble(m[i * num_columns + j]);}}         \n   //==========\n   }\nreturn A;\n}\nmatrix DeepLearning::Concatenate(matrix &X,matrix &H)\n{\nif(X.Cols() != H.Cols()) Alert(\"The number of Cols of X and H must be equal\");\n\nmatrix M;\nM.Init(X.Rows() + H.Rows(),X.Cols());\n\nulong lim;\nlim = X.Rows();\n\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(i < lim) M[i][j] = X[i][j];\n      if(i >= lim) M[i][j] = H[i-lim][j];}}\n      \nreturn M;\n}\n\n//+------------------------------------------------------------------+\n//|    Convolutional Methodes                                        |\n//+------------------------------------------------------------------+\n\nmatrix DeepLearning::VertConvV(matrix &A,matrix &B)\n{\nif(A.Cols() != B.Cols())\n  {Alert(\"matrices with different number of Columns\");\n  return A*0;\n  }\nmatrix U,D,C;\nU = A;\nD = B;\nif(U.Rows() < D.Rows())\n  {C = U;\n   U = D;\n   D = C;\n   }\nD = VertInv(D);\n\nmatrix Conv; \nConv.Init(U.Rows()-D.Rows()+1,U.Cols());\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n      \n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {for(int k=0;k<D.Rows();k++)\n        {Conv[i][j] = Conv[i][j] + U[i+k][j]*D[k][j];}}}\n      \nreturn Conv;\n}\nmatrix DeepLearning::HorConvV(matrix &A,matrix &B)\n{\nif(A.Rows() != B.Rows())\n  {Alert(\"matrices with different number of Rows\");\n  return A*0;\n  }\nmatrix U,D,C;\nU = A;\nD = B;\nif(U.Cols() < D.Cols())\n  {C = U;\n   U = D;\n   D = C;\n   }\nD = HorInv(D);\n\nmatrix Conv; \nConv.Init(U.Rows(), U.Cols() - D.Cols() + 1);\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n      \n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {for(int k=0;k<D.Cols();k++)\n        {Conv[i][j] += U[i][j+k]*D[i][k];}}}\n      \nreturn Conv;\n}\nmatrix DeepLearning::VertConvF(matrix &A,matrix &B)\n{\nif(A.Cols() != B.Cols())\n  {Alert(\"matrices with different number of Columns\");\n  return A*0;\n  }\n\nmatrix U,D,E;\n\nU = A;\nD = B;\n\nif(U.Rows() < D.Rows())\n  {E = U;\n   U = D;\n   D = E;\n   }\nmatrix Conv;\nConv.Init(U.Rows()+2*D.Rows()-2,U.Cols());\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n\nulong c = B.Rows()-1;\nfor(int i=c;i<Conv.Rows()-c;i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {\n      Conv[i][j] = U[i-c][j];\n     }\n   \n  }\n\nmatrix CF;\n   CF= VertConvV(Conv,D);\nreturn CF;\n}\nmatrix DeepLearning::HorConvF(matrix &A,matrix &B)\n{\nif(A.Rows() != B.Rows())\n  {Alert(\"matrices with different number of Rows\");\n  return A*0;\n  }\n\nmatrix U,D,E;\n\nU = A;\nD = B;\n\nif(U.Rows() < D.Rows())\n  {E = U;\n   U = D;\n   D = E;\n   }\nmatrix Conv;\nConv.Init(U.Rows(),U.Cols() + 2*D.Cols() -2);\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n\nulong c = B.Cols()-1;\n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=c;j<Conv.Cols()-c;j++)\n     {\n      Conv[i][j] = U[i][j-c];\n     }\n   \n  }\n\nmatrix CF;\n   CF= HorConvV(Conv,D);\nreturn CF;\n}\nmatrix DeepLearning::VertInv(matrix &A)\n{\nmatrix B;\nB.Init(A.Rows(),A.Cols());\nfor(int i=0;i<A.Rows();i++)\n  {for(int j=0;j<A.Cols();j++)\n     {B[i][j] = A[A.Rows()-i-1][j];}}\n\n\nreturn B;\n}\nmatrix DeepLearning::HorInv(matrix &A)\n{\nmatrix B;\nB.Init(A.Rows(),A.Cols());\nfor(int i=0;i<A.Rows();i++)\n  {for(int j=0;j<A.Cols();j++)\n     {B[i][j] = A[i][A.Cols()-j-1];}}\n\n\nreturn B;\n}\n\n//+------------------------------------------------------------------+\n//|    Activation Methodes                                           |\n//+------------------------------------------------------------------+\n\nmatrix DeepLearning::Sig(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = 1.0/(1.0 + MathExp((-1)*M[i][j]));}}\n     \nreturn M;\n      \n}\nmatrix DeepLearning::Tanh(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = (MathExp(M[i][j])-MathExp((-1.0)*M[i][j]))/(MathExp(M[i][j])+MathExp((-1.0)*M[i][j]));}}\n     \nreturn M;\n}\nmatrix DeepLearning::ReLU(matrix &X)\n{\nmatrix M;\nM = X; \nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(M[i][j] > 0) M[i][j] = M[i][j];\n      if(M[i][j] <=0) M[i][j] = 0.01*M[i][j];}}\n\nreturn M;     \n}\n\nmatrix DeepLearning::dSig(matrix &X)\n{\nmatrix M;\nM = X; \n\nM = Sig(M);\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = M[i][j]*(1.0 - M[i][j]);}}\n\nreturn M;  \n}\nmatrix DeepLearning::dTanh(matrix &X)\n{\nmatrix M;\nM = X; \n\nM = Tanh(M);\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = (1.0 - M[i][j]*M[i][j]);}}\n\nreturn M;  \n}\nmatrix DeepLearning::dReLU(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(M[i][j] > 0) M[i][j] = 1;\n      if(M[i][j] <= 0) M[i][j] = 0.01;}}\n      \nreturn M;\n}\n//+------------------------------------------------------------------+\n//|   Optimizers                                                     |\n//+------------------------------------------------------------------+\nmatrix DeepLearning::AdamM(matrix &m, matrix &dX,double beta1)\n{\nmatrix mt;\nmt.Init(dX.Rows(),dX.Cols());\nmt = m * beta1;\nmt = mt + dX * (1-beta1);\nreturn mt;\n}\nmatrix  DeepLearning::AdamV(matrix &v, matrix &dX,double beta2)\n{\nmatrix vt;\nvt = beta2*v;\nvt = vt + dX * dX * (1-beta2);\nreturn vt; \n}\nmatrix DeepLearning::Adam(double it, matrix &m, matrix &v,double beta1,double beta2, double alpha)\n{\nmatrix D, mt, vt; \n\nmt = m * (1/(1-MathPow(beta1,it)));\nvt = v * (1/(1-MathPow(beta2,it)));\n\nvt = MathSqrt(vt) + 1e-8; \nD = m / vt;\nD = D * alpha;\nreturn D; \n}\n\n#include <Layers\\LossLayer.mqh>\n#include <Layers\\MetricsLayer.mqh>\n\n#include <Layers\\DenseLayer.mqh>\n#include <Layers\\ActivationLayer.mqh>\n#include <Layers\\DropoutLayer.mqh>\n\n#include <Layers\\ConvolutionalLayer.mqh>\n#include <Layers\\MaxPoolingLayer.mqh>\n#include <Layers\\FlattenLayer.mqh>\n#include <Layers\\SumConvLayer.mqh>\n\n#include <Layers\\LSTMLayer.mqh>\n#include <Layers\\BiLSTMLayer.mqh>\n\n\n\n\n\n\n\n\n\n",
    "search_content": "#include <DeepLearningLibrary.mqh>\n\nclass DeepLearning\n  {\npublic:\n   //-------------------------------\n   // Define the cost functions and its derivatives\n   class Loss;\n   // Define metrics for evaluation\n   class Metrics;\n   \n   //-------------------------------\n   // Dense Connected Layer\n   class DenseLayer;\n   // Activation Function Layer \n   class ActivationLayer;\n   // Softmax function Layer\n   class SoftmaxLayer;\n   // Dropout Layer to Enhance Overffiting\n   class DropoutLayer;\n\n   //--------------------------------\n   // Convolutional Neural Net Layer\n   class ConvolutionalLayer;\n   // Max Pooling Layer\n   class MaxPoolingLayer;\n   // Flatten Layer\n   class FlattenLayer;\n   // Sum Convolutional Layer\n   class SumConvLayer;\n\n   //--------------------------------\n   //Long Short-Term Memory Layer\n   class LSTMLayer;\n   // Bidirectional LSTM layer\n   class BiLSTMLayer;\n   \n   \n   //Methods\n   virtual matrix    Output(matrix &X)                {return X*0;   }\n   virtual matrix    GradDescent(matrix &Ey)          {return Ey*0;  }\n   virtual void      Update(void)                     {              }\n   virtual void      SaveWeights(int k,string IAname) {              }\n   virtual void      LoadWeights(int k,string IAname) {              }\n   virtual void      SetDrop(double Drop)             {              }\n   virtual void      SetAdam(double B1, double B2, double Alph) {    }\n   \n   \n   \n   //=============================\n   matrix   InitWeights(matrix &M);\n   matrix   ZeroMatrix(matrix &M);\n   void     SaveMatrix(matrix &M, string M_name);\n   matrix   LoadMatrix(string M_name);\n   matrix   Concatenate(matrix &X, matrix &H);\n   \n   //Convolution \n   matrix VertConvV(matrix &A, matrix &B);\n   matrix VertConvF(matrix &A, matrix &B);\n   matrix VertInv(matrix &A);\n   \n   matrix HorConvV(matrix &A, matrix &B);\n   matrix HorConvF(matrix &A, matrix &B);\n   matrix HorInv(matrix &A);\n   \n   //Activation\n   matrix Sig(matrix &X);\n   matrix Tanh(matrix &X);\n   matrix ReLU(matrix &X);\n   \n   matrix dSig(matrix &X);\n   matrix dTanh(matrix &X);\n   matrix dReLU(matrix &X);\n   \n   //ADAM optimizer\n   matrix AdamM(matrix &m, matrix &dX,double beta1);\n   matrix AdamV(matrix &v, matrix &dX,double beta2);\n   matrix Adam(double it, matrix &m, matrix &v,double beta1, double beta2, double alpha);\n   \n   \n  };\n \n//+------------------------------------------------------------------+\n//|   Deep Learning Methodes                                         |\n//+------------------------------------------------------------------+\nmatrix DeepLearning::InitWeights(matrix &M)\n{\n   matrix W;\n   W = M;\n   for(int i=0;i<W.Rows();i++)\n     {for(int j=0;j<W.Cols();j++)\n        {W[i][j] = (2.0*(MathRand()/32766.0) -1.0);}}\n         \nreturn W;\n}\nmatrix DeepLearning::ZeroMatrix(matrix &M)\n{\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = 0;}}\n      \nreturn M;\n}\nvoid DeepLearning::SaveMatrix(matrix &M,string M_name)\n{\n   //transforma a matrix M num vetor de strings\n   ulong Srows , SCols;\n   Srows = M.Rows();\n   SCols = M.Cols();\n   string csv_name;\n   csv_name = M_name;\n   \n   string V[];\n   ArrayResize(V,Srows);\n   \n   //Zera o vetor de strings\n   for(int i=0;i<ArraySize(V);i++)\n     {V[i] = NULL;}\n      \n   //Prepara o vetor com as classes \n\n   for(int i=0;i<Srows;i++)\n     {for(int j=0;j<SCols;j++)\n         {\n         if(j == SCols-1) V[i] = V[i] + DoubleToString(M[i][j]);\n         else V[i] = V[i] + DoubleToString(M[i][j]) + \",\";}}     \n   \n   //Abre o arquivo para ser escrito\n   int h=FileOpen(csv_name,FILE_WRITE|FILE_ANSI|FILE_CSV);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE) Alert(\"Error opening file\");\n   \n   for(int i=0;i<Srows;i++)\n      {\n      FileWrite(h,V[i]);\n      }\n   FileClose(h);\n}\nmatrix DeepLearning::LoadMatrix(string M_name)\n{\n   //Le apenas a primeira linha para saber o n\u00famero de colunas\n   string L1;\n   string csv_name;\n   csv_name = M_name;\n   //Abre o arquivo para ser lido\n   int h1=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_TXT);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h1==INVALID_HANDLE)   Alert(\"Error opening file\");\n   L1 = FileReadString(h1);\n   FileClose(h1);\n   \n   //L1 possui agora a primeira linha da matriz\n   //L\u00ea quantas colunas s\u00e3o pelo n\u00famero de v\u00edrgulas\n   \n   int num_columns = 1; \n   \n   for(int i=0;i<L1.Length();i++)\n     {\n      if(L1.Substr(i,1) == \",\") num_columns++;\n     }\n   \n   //Abre o arquivo para ser lido\n   int h=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_CSV,\",\");\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE)   Alert(\"Error opening file\");\n\n   string read_x;\n   string m[]; //Vetor que receber\u00e1 os dados\n   int    m_size = 0;\n   \n   matrix A;   // Matriz que retornar\u00e1 com os dados\n   int A_size = 0;\n   //Come\u00e7a com a leitura da primeira linha\n   \n   while(!FileIsEnding(h))\n   {\n      ArrayResize(m,m_size+1);\n      read_x = FileReadString(h);   // L\u00ea o c"
  },
  {
    "filename": "DeepLearningLibrary.mqh",
    "source_type": "KOD",
    "content": "enum ActFunction\n  {\n   SIGMOID,\n   TANH,\n   RELU,\n  };\n  \nenum Optim\n  {\n   STD,\n   ADAM,\n  };\n  \nenum CONV_DIR\n  {\n   VERT,\n   HORZ,\n  };",
    "search_content": "enum ActFunction\n  {\n   SIGMOID,\n   TANH,\n   RELU,\n  };\n  \nenum Optim\n  {\n   STD,\n   ADAM,\n  };\n  \nenum CONV_DIR\n  {\n   VERT,\n   HORZ,\n  };"
  },
  {
    "filename": "TimeSeriesData.mqh",
    "source_type": "KOD",
    "content": "\ufffd\ufffd#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000<\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000\\\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000 \u0000c\u0000a\u0000n\u0000v\u0000a\u0000s\u0000;\u0000\n\u0000\n\u0000#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000 \u0000<\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000s\u0000\\\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000/\u0000/\u0000-\u0000-\u0000-\u0000\n\u0000\n\u0000\n\u0000\n\u0000c\u0000l\u0000a\u0000s\u0000s\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000p\u0000u\u0000b\u0000l\u0000i\u0000c\u0000:\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000o\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000l\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000d\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000E\u0000s\u0000c\u0000r\u0000e\u0000v\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000W\u0000r\u0000i\u0000t\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000,\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000c\u0000o\u0000m\u0000 \u0000o\u0000s\u0000 \u0000p\u0000a\u0000s\u0000s\u0000o\u0000s\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000m\u0000p\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000p\u0000a\u0000s\u0000s\u0000a\u0000r\u0000 \u0000p\u0000e\u0000l\u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000r\u0000e\u0000a\u0000l\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000a\u0000r\u0000 \u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000s\u0000 \u0000s\u0000a\u0000\ufffd\u0000d\u0000a\u0000s\u0000 \u0000r\u0000e\u0000a\u0000i\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000a\u0000 \u0000o\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000r\u0000a\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000a\u0000 \u0000m\u0000\ufffd\u0000d\u0000i\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000e\u0000a\u0000n\u0000 \u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\ufffd\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\ufffd\u0000x\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000a\u0000x\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\ufffd\u0000n\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000}\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000/\u0000/\u0000|\u0000 \u0000 \u0000 \u0000M\u0000e\u0000t\u0000h\u0000o\u0000d\u0000e\u0000s\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000|\u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000X\u0000;\u0000 \u0000\n\u0000\n\u0000X\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000r\u0000=\u0000i\u0000;\u0000r\u0000<\u0000i\u0000+\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000r\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000r\u0000-\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000r\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000X\u0000 \u0000=\u0000 \u0000X\u0000.\u0000T\u0000r\u0000a\u0000n\u0000s\u0000p\u0000o\u0000s\u0000e\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000;\u0000\n\u0000\n\u0000Y\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u00001\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000Y\u0000[\u00000\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000+\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000i\u0000<\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000i\u0000n\u0000t\u0000 \u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000E\u0000n\u0000t\u0000r\u0000a\u0000d\u0000a\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000x\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000x\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000x\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000i\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000S\u0000a\u0000\ufffd\u0000d\u0000a\u0000s\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000y\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000y\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000y\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000[\u0000i\u0000]\u0000[\u0000c\u0000o\u0000l\u0000u\u0000m\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000*\u0000b\u0000o\u0000o\u0000l\u0000 \u0000 \u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000l\u0000o\u0000n\u0000g\u0000 \u0000 \u0000 \u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000 \u0000I\u0000D\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000 \u0000n\u0000a\u0000m\u0000e\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000n\u0000a\u0000m\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000u\u0000b\u0000w\u0000i\u0000n\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000u\u0000b\u0000-\u0000w\u0000i\u0000n\u0000d\u0000o\u0000w\u0000 \u0000i\u0000n\u0000d\u0000e\u0000x\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00002\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00002\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000)\u0000*\u0000/\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000A\u0000 \u0000f\u0000u\u0000n\u0000\ufffd\u0000\ufffd\u0000o\u0000 \u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000 \u0000\ufffd\u0000 \u0000d\u0000a\u0000d\u0000a\u0000 \u0000a\u0000c\u0000i\u0000m\u0000a\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u00000\u0000,\u0000\"\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000\"\u0000,\u00000\u0000,\u00003\u00000\u0000,\u00003\u00000\u0000,\u00001\u00005\u00000\u00000\u0000,\u00009\u00000\u00000\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000d\u0000i\u0000c\u0000i\u0000o\u0000n\u0000a\u0000 \u0000o\u0000s\u0000 \u0000g\u0000r\u0000\ufffd\u0000f\u0000i\u0000c\u0000o\u0000s\u0000 \u0000n\u0000a\u0000 \u0000c\u0000u\u0000r\u0000v\u0000a\u0000.\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000y\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000O\u0000s\u0000 \u0000t\u0000r\u0000e\u0000c\u0000h\u0000o\u0000s\u0000 \u0000\"\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000\"\u0000 \u0000n\u0000\ufffd\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00002\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u00000\u0000,\u0000y\u00002\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000\ufffd\u0000o\u0000 \u0000n\u0000e\u0000c\u0000e\u0000s\u0000s\u0000\ufffd\u0000r\u0000i\u0000o\u0000s\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000u\u0000d\u0000a\u0000 \u0000o\u0000s\u0000 \u0000n\u0000o\u0000m\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000g\u0000r\u0000\ufffd\u0000f\u0000i\u0000c\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000X\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000m\u0000 \u0000o\u0000 \u0000t\u0000a\u0000m\u0000a\u0000n\u0000h\u0000o\u0000 \u0000d\u0000a\u0000 \u0000f\u0000o\u0000n\u0000t\u0000e\u0000,\u0000 \u0000n\u0000\ufffd\u0000o\u0000 \u0000f\u0000u\u0000n\u0000c\u0000i\u0000o\u0000n\u0000a\u0000.\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000Y\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000P\u0000l\u0000o\u0000t\u0000A\u0000l\u0000l\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000U\u0000p\u0000d\u0000a\u0000t\u0000e\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000P\u0000l\u0000o\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000]\u0000,\u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000]\u0000,\u0000x\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000,\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000x\u0000,\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000i\u0000f\u0000(\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000)\u0000 \u0000!\u0000=\u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000P\u0000r\u0000i\u0000n\u0000t\u0000(\u0000\"\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000 \u0000a\u0000n\u0000d\u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000 \u0000w\u0000i\u0000t\u0000h\u0000 \u0000d\u0000i\u0000f\u0000e\u0000r\u0000e\u0000n\u0000t\u0000 \u0000s\u0000i\u0000z\u0000e\u0000s\u0000\"\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000E\u0000s\u0000c\u0000r\u0000e\u0000v\u0000e\u0000 \u0000o\u0000s\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000e\u0000s\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000e\u0000m\u0000 \u0000p\u0000l\u0000o\u0000t\u0000a\u0000d\u0000o\u0000s\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000x\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000i\u0000;\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000]\u0000[\u00000\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000i\u0000]\u0000[\u00000\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000*\u0000b\u0000o\u0000o\u0000l\u0000 \u0000 \u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000l\u0000o\u0000n\u0000g\u0000 \u0000 \u0000 \u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000 \u0000I\u0000D\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000 \u0000n\u0000a\u0000m\u0000e\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000n\u0000a\u0000m\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000u\u0000b\u0000w\u0000i\u0000n\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000u\u0000b\u0000-\u0000w\u0000i\u0000n\u0000d\u0000o\u0000w\u0000 \u0000i\u0000n\u0000d\u0000e\u0000x\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00002\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00002\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000)\u0000*\u0000/\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000A\u0000 \u0000f\u0000u\u0000n\u0000\ufffd\u0000\ufffd\u0000o\u0000 \u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000 \u0000\ufffd\u0000 \u0000d\u0000a\u0000d\u0000a\u0000 \u0000a\u0000c\u0000i\u0000m\u0000a\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u00000\u0000,\u0000\"\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000\"\u0000,\u00000\u0000,\u00003\u00000\u0000,\u00003\u00000\u0000,\u00009\u00005\u00000\u0000,\u00005\u00005\u00000\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000d\u0000i\u0000c\u0000i\u0000o\u0000n\u0000a\u0000 \u0000o\u0000s\u0000 \u0000g\u0000r\u0000\ufffd\u0000f\u0000i\u0000c\u0000o\u0000s\u0000 \u0000n\u0000a\u0000 \u0000c\u0000u\u0000r\u0000v\u0000a\u0000.\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000O\u0000s\u0000 \u0000t\u0000r\u0000e\u0000c\u0000h\u0000o\u0000s\u0000 \u0000\"\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000\"\u0000 \u0000n\u0000\ufffd\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00002\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000\ufffd\u0000o\u0000 \u0000n\u0000e\u0000c\u0000e\u0000s\u0000s\u0000\ufffd\u0000r\u0000i\u0000o\u0000s\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000u\u0000d\u0000a\u0000 \u0000o\u0000s\u0000 \u0000n\u0000o\u0000m\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000g\u0000r\u0000\ufffd\u0000f\u0000i\u0000c\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000X\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000m\u0000 \u0000o\u0000 \u0000t\u0000a\u0000m\u0000a\u0000n\u0000h\u0000o\u0000 \u0000d\u0000a\u0000 \u0000f\u0000o\u0000n\u0000t\u0000e\u0000,\u0000 \u0000n\u0000\ufffd\u0000o\u0000 \u0000f\u0000u\u0000n\u0000c\u0000i\u0000o\u0000n\u0000a\u0000.\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000Y\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000P\u0000l\u0000o\u0000t\u0000A\u0000l\u0000l\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000U\u0000p\u0000d\u0000a\u0000t\u0000e\u0000(\u0000)\u0000;\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000X\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000X\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000a\u0000n\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000s\u0000t\u0000d\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000i\u0000n\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000e\u0000a\u0000n\u0000 \u0000=\u0000 \u0000M\u0000e\u0000a\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000_\u0000f\u0000i\u0000l\u0000t\u0000e\u0000r\u0000 \u0000=\u00003\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000a\u0000 \u0000m\u0000\ufffd\u0000d\u0000i\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000-\u0000 \u0000m\u0000e\u0000a\u0000n\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000o\u0000s\u0000 \u0000O\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000l\u0000=\u00000\u0000;\u0000l\u0000<\u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000_\u0000f\u0000i\u0000l\u0000t\u0000e\u0000r\u0000;\u0000l\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000c\u0000a\u0000m\u0000a\u0000d\u0000a\u0000 \u0000d\u0000e\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000M\u0000a\u0000t\u0000h\u0000A\u0000b\u0000s\u0000(\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000>\u0000 \u00003\u0000*\u0000s\u0000t\u0000d\u0000)\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u00000\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000I\u0000n\u0000t\u0000e\u0000r\u0000p\u0000o\u0000l\u0000a\u0000 \u0000o\u0000s\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000=\u0000 \u00000\u0000)\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000(\u0000X\u0000[\u0000i\u0000-\u00001\u0000]\u0000[\u0000j\u0000]\u0000 \u0000+\u0000 \u0000X\u0000[\u0000i\u0000+\u00001\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000/\u0000 \u00002\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000R\u0000e\u0000c\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\ufffd\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000i\u0000v\u0000i\u0000d\u0000e\u0000 \u0000p\u0000e\u0000l\u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\ufffd\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000/\u0000s\u0000t\u0000d\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u0000M\u0000a\u0000x\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u0000M\u0000i\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000(\u00001\u0000.\u00005\u0000 \u0000*\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000/\u0000(\u0000m\u0000a\u0000x\u0000 \u0000-\u0000 \u0000m\u0000i\u0000n\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000e\u0000a\u0000n\u0000 \u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000M\u0000 \u0000=\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000m\u0000e\u0000 \u0000=\u0000 \u0000m\u0000e\u0000 \u0000+\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u0000m\u0000e\u0000 \u0000/\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000M\u0000 \u0000=\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000s\u0000t\u0000d\u0000;\u0000\n\u0000\n\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000,\u0000s\u0000u\u0000m\u0000;\u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000e\u0000a\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000-\u00001\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u0000s\u0000u\u0000m\u0000 \u0000+\u0000 \u0000M\u0000a\u0000t\u0000h\u0000P\u0000o\u0000w\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000-\u0000m\u0000e\u0000,\u00002\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u0000s\u0000u\u0000m\u0000 \u0000/\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000M\u0000a\u0000t\u0000h\u0000S\u0000q\u0000r\u0000t\u0000(\u0000s\u0000u\u0000m\u0000)\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000s\u0000t\u0000d\u0000;\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000i\u0000n\u0000;\u0000 \u0000\n\u0000\n\u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000<\u0000 \u0000m\u0000i\u0000n\u0000)\u0000 \u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000i\u0000n\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000a\u0000x\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000>\u0000 \u0000m\u0000a\u0000x\u0000)\u0000 \u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000R\u0000e\u0000a\u0000d\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u0000e\u0000 \u0000a\u0000p\u0000e\u0000n\u0000a\u0000s\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000a\u0000b\u0000e\u0000r\u0000 \u0000o\u0000 \u0000n\u0000\ufffd\u0000m\u0000e\u0000r\u0000o\u0000 \u0000d\u0000e\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000L\u00001\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u00001\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000R\u0000E\u0000A\u0000D\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000T\u0000X\u0000T\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\ufffd\u0000o\u0000 \u0000\ufffd\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\ufffd\u0000 \u0000i\u0000n\u0000v\u0000\ufffd\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u00001\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000L\u00001\u0000 \u0000=\u0000 \u0000F\u0000i\u0000l\u0000e\u0000R\u0000e\u0000a\u0000d\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000h\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u00001\u0000 \u0000p\u0000o\u0000s\u0000s\u0000u\u0000i\u0000 \u0000a\u0000g\u0000o\u0000r\u0000a\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000 \u0000d\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u0000\ufffd\u0000 \u0000q\u0000u\u0000a\u0000n\u0000t\u0000a\u0000s\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000s\u0000 \u0000s\u0000\ufffd\u0000o\u0000 \u0000p\u0000e\u0000l\u0000o\u0000 \u0000n\u0000\ufffd\u0000m\u0000e\u0000r\u0000o\u0000 \u0000d\u0000e\u0000 \u0000v\u0000\ufffd\u0000r\u0000g\u0000u\u0000l\u0000a\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000 \u0000=\u0000 \u00001\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000L\u00001\u0000.\u0000L\u0000e\u0000n\u0000g\u0000t\u0000h\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000L\u00001\u0000.\u0000S\u0000u\u0000b\u0000s\u0000t\u0000r\u0000(\u0000i\u0000,\u00001\u0000)\u0000 \u0000=\u0000=\u0000 \u0000\"\u0000,\u0000\"\u0000)\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000+\u0000+\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000R\u0000E\u0000A\u0000D\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000C\u0000S\u0000V\u0000,\u0000\"\u0000,\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\ufffd\u0000o\u0000 \u0000\ufffd\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\ufffd\u0000 \u0000i\u0000n\u0000v\u0000\ufffd\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000m\u0000[\u0000]\u0000;\u0000 \u0000/\u0000/\u0000V\u0000e\u0000t\u0000o\u0000r\u0000 \u0000q\u0000u\u0000e\u0000 \u0000r\u0000e\u0000c\u0000e\u0000b\u0000e\u0000r\u0000\ufffd\u0000 \u0000o\u0000s\u0000 \u0000d\u0000a\u0000d\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000A\u0000;\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000M\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000q\u0000u\u0000e\u0000 \u0000r\u0000e\u0000t\u0000o\u0000r\u0000n\u0000a\u0000r\u0000\ufffd\u0000 \u0000c\u0000o\u0000m\u0000 \u0000o\u0000s\u0000 \u0000d\u0000a\u0000d\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000A\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000o\u0000m\u0000e\u0000\ufffd\u0000a\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000 \u0000l\u0000e\u0000i\u0000t\u0000u\u0000r\u0000a\u0000 \u0000d\u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000w\u0000h\u0000i\u0000l\u0000e\u0000(\u0000!\u0000F\u0000i\u0000l\u0000e\u0000I\u0000s\u0000E\u0000n\u0000d\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000m\u0000,\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000+\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000 \u0000=\u0000 \u0000F\u0000i\u0000l\u0000e\u0000R\u0000e\u0000a\u0000d\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000;\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000L\u0000\ufffd\u0000 \u0000o\u0000 \u0000c\u0000o\u0000n\u0000t\u0000e\u0000u\u0000d\u0000o\u0000 \u0000a\u0000t\u0000\ufffd\u0000 \u0000a\u0000 \u0000v\u0000i\u0000r\u0000g\u0000u\u0000l\u0000a\u0000 \u0000\ufffd\u0000 \u0000p\u0000a\u0000s\u0000s\u0000a\u0000 \u0000p\u0000r\u0000a\u0000 \u0000p\u0000r\u0000\ufffd\u0000x\u0000i\u0000m\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000m\u0000[\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000]\u0000 \u0000=\u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000!\u0000F\u0000i\u0000l\u0000e\u0000I\u0000s\u0000E\u0000n\u0000d\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000)\u0000 \u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000+\u0000+\u0000;\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000 \u0000=\u0000 \u0000(\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000+\u0000 \u00001\u0000)\u0000/\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000(\u0000(\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000+\u00001\u0000)\u0000%\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000)\u0000 \u0000!\u0000=\u0000 \u00000\u0000 \u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000t\u0000h\u0000e\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000d\u0000a\u0000t\u0000a\u0000 \u0000i\u0000s\u0000 \u0000i\u0000n\u0000c\u0000o\u0000m\u0000p\u0000l\u0000e\u0000t\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000e\u0000l\u0000s\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000r\u0000e\u0000p\u0000a\u0000r\u0000a\u0000r\u0000 \u0000a\u0000 \u0000M\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000A\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000A\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000,\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000A\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000T\u0000o\u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000(\u0000m\u0000[\u0000i\u0000 \u0000*\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000 \u0000+\u0000 \u0000j\u0000]\u0000)\u0000;\u0000}\u0000}\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000A\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000W\u0000r\u0000i\u0000t\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000,\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000t\u0000r\u0000a\u0000n\u0000s\u0000f\u0000o\u0000r\u0000m\u0000a\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000 \u0000n\u0000u\u0000m\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000d\u0000e\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000S\u0000r\u0000o\u0000w\u0000s\u0000 \u0000,\u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000S\u0000r\u0000o\u0000w\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000V\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000V\u0000,\u0000S\u0000r\u0000o\u0000w\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000Z\u0000e\u0000r\u0000a\u0000 \u0000o\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000d\u0000e\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000V\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000N\u0000U\u0000L\u0000L\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000r\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000o\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000s\u0000 \u0000c\u0000l\u0000a\u0000s\u0000s\u0000e\u0000s\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000S\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000S\u0000C\u0000o\u0000l\u0000s\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000j\u0000 \u0000=\u0000=\u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000-\u00001\u0000)\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000+\u0000 \u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000T\u0000o\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000e\u0000l\u0000s\u0000e\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000+\u0000 \u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000T\u0000o\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000+\u0000 \u0000\"\u0000,\u0000\"\u0000;\u0000}\u0000}\u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000e\u0000s\u0000c\u0000r\u0000i\u0000t\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000W\u0000R\u0000I\u0000T\u0000E\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000C\u0000S\u0000V\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\ufffd\u0000o\u0000 \u0000\ufffd\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\ufffd\u0000 \u0000i\u0000n\u0000v\u0000\ufffd\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000S\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000W\u0000r\u0000i\u0000t\u0000e\u0000(\u0000h\u0000,\u0000V\u0000[\u0000i\u0000]\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u0000)\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000 \u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000*\u0000(\u00001\u0000-\u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000,\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000-\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000/\u0000/\u0000i\u0000f\u0000(\u0000i\u0000 \u0000<\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000i\u0000 \u0000>\u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000}\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000r\u0000a\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000 \u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000*\u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000,\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000-\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000i\u0000 \u0000<\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000i\u0000f\u0000(\u0000i\u0000 \u0000>\u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000;\u0000\n\u0000\n\u0000}\u0000",
    "search_content": "\ufffd\ufffd#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000<\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000\\\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000 \u0000c\u0000a\u0000n\u0000v\u0000a\u0000s\u0000;\u0000\n\u0000\n\u0000#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000 \u0000<\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000s\u0000\\\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000/\u0000/\u0000-\u0000-\u0000-\u0000\n\u0000\n\u0000\n\u0000\n\u0000c\u0000l\u0000a\u0000s\u0000s\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000p\u0000u\u0000b\u0000l\u0000i\u0000c\u0000:\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000o\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000l\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000d\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000E\u0000s\u0000c\u0000r\u0000e\u0000v\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000W\u0000r\u0000i\u0000t\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000,\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000c\u0000o\u0000m\u0000 \u0000o\u0000s\u0000 \u0000p\u0000a\u0000s\u0000s\u0000o\u0000s\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000m\u0000p\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000p\u0000a\u0000s\u0000s\u0000a\u0000r\u0000 \u0000p\u0000e\u0000l\u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000r\u0000e\u0000a\u0000l\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000a\u0000r\u0000 \u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000s\u0000 \u0000s\u0000a\u0000\ufffd\u0000d\u0000a\u0000s\u0000 \u0000r\u0000e\u0000a\u0000i\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000a\u0000 \u0000o\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000r\u0000a\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000a\u0000 \u0000m\u0000\ufffd\u0000d\u0000i\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000e\u0000a\u0000n\u0000 \u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\ufffd\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\ufffd\u0000x\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000a\u0000x\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\ufffd\u0000n\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000}\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000/\u0000/\u0000|\u0000 \u0000 \u0000 \u0000M\u0000e\u0000t\u0000h\u0000o\u0000d\u0000e\u0000s\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000|\u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000X\u0000;\u0000 \u0000\n\u0000\n\u0000X\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000r\u0000=\u0000i\u0000;\u0000r\u0000<\u0000i\u0000+\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000r\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000r\u0000-\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000r\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000X\u0000 \u0000=\u0000 \u0000X\u0000.\u0000T\u0000r\u0000a\u0000n\u0000s\u0000p\u0000o\u0000s\u0000e\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000;\u0000\n\u0000\n\u0000Y\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u00001\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000Y\u0000[\u00000\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000+\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000i\u0000<\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000i\u0000n\u0000t\u0000 \u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000"
  },
  {
    "filename": "Example.mq5",
    "source_type": "KOD",
    "content": "#include <TimeSeriesData.mqh>\nTimeSeries time_series;\n#include <DeepLearning.mqh>\nDeepLearning *Layer[];\n\n//Number of layers of our neural net\n//The first thing to do is set the number of layers \n//the network will have \nint   N_layers = 5;\n\n//Loss object\nLoss loss;\n//Metrics object\nMetrics metrics;\n\n//=============================================================\n//In this Example we are trying to predict de Weather in Delhi\n//This dataset was chosen because it is a time series and \n//therefore its similarity with financial time series\n//=============================================================\n\n\nvoid OnInit()\n  {\n//+------------------------------------------------------------------+\n//| Hiper Parameters                                                 |\n//+------------------------------------------------------------------+\n   //Load Dataset\n   matrix M;\n   M = time_series.ReadDataset(\"Delhi.csv\");\n   \n   //----------------------------------------------------------------+\n   //After we have the number of layers setted, it's time to load\n   //the dataset and set other parameters of the dataset\n\n   //AI Name\n   string IAname;\n   IAname = \"DelhiIA\";\n   //number of epochs\n   ulong epoch = 1000;\n   //Learning rate\n   double N = 0.001;\n   //Optimization Method\n   Optim OP = ADAM;\n   //number of samples\n   ulong N_samples = M.Rows();\n   //Dropout rate\n   double drp = 0.9;\n   //Percentage of samples for training\n   double train_ratio = 0.8;\n   //Stride of Max Pooling layers\n   int stride = 2;\n   \n   //Number of inputs\n   int N_entries = M.Cols();\n   //Number of time steps \n   int N_steps = 60;\n   //Column to be predicted\n   int feature = 0;\n \n   \n   //ADAM parameters\n   double Beta1 = 0.8;\n   double Beta2 = 0.999;\n   double Alpha = N; \n        \n   //+------------------------------------------------------------------+\n   //|    Neural Network creation                                     |\n   //+------------------------------------------------------------------+\n   \n   ArrayResize(Layer,N_layers);\n   \n   //Architecture creation\n   biLSTMLayer            *biLSTM1 = new biLSTMLayer();\n   ActivationLayer      *ACT2  = new ActivationLayer();\n   FlattenLayer         *FLAT3 = new FlattenLayer();\n   DenseLayer           *ANN4  = new DenseLayer();\n   ActivationLayer      *ACT5  = new ActivationLayer();\n   \n   //The InitLayer method is used to initialize the weights of each layer\n   //The layer's parameters used in initialization are explained \n   //in the in its respective libraries in Layers directory\n\n\n   //Layers Initialization\n   biLSTM1.InitLayer(N_steps,N_entries,4,1,N,OP);\n   ACT2.InitLayer(TANH);  \n   ANN4.InitLayer(N_steps*1,1,N,OP);\n   ACT5.InitLayer(TANH);\n   \n   \n   //Neural Network \n   Layer[0] = biLSTM1;\n   Layer[1] = ACT2;\n   Layer[2] = FLAT3;\n   Layer[3] = ANN4;\n   Layer[4] = ACT5;\n   \n   //+------------------------------------------------------------------+\n   //|  Otimizers parameters                                 |\n   //+------------------------------------------------------------------+\n   \n   //ADAM\n   Adam(Beta1,Beta2,Alpha); \n\n   \n   //+------------------------------------------------------------------+\n   //|    Dataset pre-processing                                        |\n   //+------------------------------------------------------------------+\n   \n   //The pre-process methods are explained in TimeSeriesData.mqh library\n\n   //Shuffle  Dataset\n   //M = dataset.Shuffle(M);\n   \n   //Normalize dataset\n   M = time_series.NormalizeDataset(M);\n   \n   //training Dataset \n   matrix M_train;\n   M_train = time_series.DatasetTrain(M,train_ratio);\n   \n   // testing Dataset \n   matrix M_test;\n   M_test = time_series.DatasetTest(M,1-train_ratio);\n   \n   //+------------------------------------------------------------------+\n   //|    Weights                                                        |\n   //+------------------------------------------------------------------+\n   \n   //Load Neural Network weights\n   //Load(IAname);\n   \n   // Training:\n   Train(epoch,feature,N_steps,N,M_train);\n     \n   //Save the weigths\n   Save(IAname);\n    \n    \n   //+------------------------------------------------------------------+\n   //|   Evaluation                                                     |\n   //+------------------------------------------------------------------+\n   \n   \n   //Output\n   matrix Out;\n   Out = Test(M_test, N_steps);\n\n \n   //Compare\n   matrix Y_true = time_series.OutputTest(feature,N_steps,M_test);\n   \n   //Plotar outputs\n   time_series.PlotTest(Y_true,Out); \n   //time_series.PlotDataset(M,0);\n   \n   \n   //Accuracy\n   double mape;\n   mape = metrics.MAPE(Y_true,Out);\n   //int percent_accuracy;\n   //accuracy = metrics.Accuracy(R,Out);\n   //percent_accuracy = 100*accuracy;\n   \n   Print(\"The Mean Absolute Percentage Error of the model is \",mape);\n   \n   \n  }\n//+------------------------------------------------------------------+\n//|   Functions and methods                                             |\n//+------------------------------------------------------------------+\n\nvoid Train(ulong epoch,int feature, ulong N_steps,double N,matrix &M)\n{\n   ulong N_samples;\n   N_samples = M.Rows();\n   \n   //estimate time\n   datetime date1, date2; \n   int interval, min, sec; \n   \n   //Estimate training progress\n   double count1,count2;\n   int count;\n   \n   double Error; \n   //Start of training\n   for(int e=0;e<epoch;e++)\n     {\n      Error = 0;\n      for(int s=0;s<N_samples-N_steps;s++)\n        {\n         \n         //Input and output preparation\n         matrix Y_pred;\n         matrix Grad;\n         matrix Y_true;\n         \n         Y_true = time_series.RealOutput(s,feature,N_steps,M);\n         Y_pred = time_series.Features(s,N_steps,M);\n         \n         //Forward Propagation\n         for(int i=0;i<ArraySize(Layer);i++)\n           { Y_pred = Layer[i].Output(Y_pred); }\n           \n         //Error\n         Error += loss.MeanSquaredError(Y_true,Y_pred);\n         Grad = loss.Grad_MSE(Y_true,Y_pred);\n         \n         //Backpropagation\n         for(int i=ArraySize(Layer)-1;i>-1;i--)\n           { Grad = Layer[i].GradDescent(Grad); }\n           \n         //Update Weights\n         for(int i=0;i<ArraySize(Layer);i++)\n           {Layer[i].Update();}  \n         }\n    \n     //Progress bar\n     count = epoch*0.01;\n     if((e % (count)) == 0)\n       {\n         count1 = epoch;\n         count2 = e;\n         count2 = count2/count1;\n         count = 100*count2;\n         Print(\"training progress in \",count,\"%\");\n         Print(\"Current Error = \",Error);\n         date1 = TimeLocal(); \n         if(count > 0)\n           {\n            //Calculate time passed \n            //entre x% e x+1%\n            interval = date1 - date2;\n            //Estimate seconds left\n            interval = interval *(100 - count);\n            //Calculate minutes\n            min = interval / 60;\n            //Calculate seconds\n            sec = interval % 60;\n            Print(\"Remaining Time: \",min,\"min \",sec,\"sec\");\n            \n           }\n         date2 = TimeLocal();\n       }\n//+++++++++++++\n     }\n}\n\nmatrix Test(matrix &M_test,int N_steps)\n{\n   ulong N_samples;\n   N_samples = M_test.Rows();\n   \n   matrix Y_pred;\n   \n   matrix Out;\n   Out.Init(N_samples-N_steps,1);\n   \n   for(int s=0;s<N_samples-N_steps;s++)\n     {   \n         \n         Y_pred = time_series.Features(s,N_steps,M_test);\n         for(int i=0;i<ArraySize(Layer);i++)\n           {//Linha respons\u00e1vel por anular o dropset\n            Layer[i].SetDrop(1.0);\n            //Sa\u00edda efetivamente\n            Y_pred = Layer[i].Output(Y_pred); }\n         \n         Out[s][0] = Y_pred[0][0];\n         //   \n      }\nreturn Out;\n}\n\nvoid Load(string IA_name)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].LoadWeights(i,IA_name);}\n}\nvoid Save(string IA_name)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].SaveWeights(i,IA_name);}\n}\n\nvoid Adam(double beta1, double beta2, double alpha)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].SetAdam(beta1,beta2,alpha);}\n}",
    "search_content": "#include <TimeSeriesData.mqh>\nTimeSeries time_series;\n#include <DeepLearning.mqh>\nDeepLearning *Layer[];\n\n//Number of layers of our neural net\n//The first thing to do is set the number of layers \n//the network will have \nint   N_layers = 5;\n\n//Loss object\nLoss loss;\n//Metrics object\nMetrics metrics;\n\n//=============================================================\n//In this Example we are trying to predict de Weather in Delhi\n//This dataset was chosen because it is a time series and \n//therefore its similarity with financial time series\n//=============================================================\n\n\nvoid OnInit()\n  {\n//+------------------------------------------------------------------+\n//| Hiper Parameters                                                 |\n//+------------------------------------------------------------------+\n   //Load Dataset\n   matrix M;\n   M = time_series.ReadDataset(\"Delhi.csv\");\n   \n   //----------------------------------------------------------------+\n   //After we have the number of layers setted, it's time to load\n   //the dataset and set other parameters of the dataset\n\n   //AI Name\n   string IAname;\n   IAname = \"DelhiIA\";\n   //number of epochs\n   ulong epoch = 1000;\n   //Learning rate\n   double N = 0.001;\n   //Optimization Method\n   Optim OP = ADAM;\n   //number of samples\n   ulong N_samples = M.Rows();\n   //Dropout rate\n   double drp = 0.9;\n   //Percentage of samples for training\n   double train_ratio = 0.8;\n   //Stride of Max Pooling layers\n   int stride = 2;\n   \n   //Number of inputs\n   int N_entries = M.Cols();\n   //Number of time steps \n   int N_steps = 60;\n   //Column to be predicted\n   int feature = 0;\n \n   \n   //ADAM parameters\n   double Beta1 = 0.8;\n   double Beta2 = 0.999;\n   double Alpha = N; \n        \n   //+------------------------------------------------------------------+\n   //|    Neural Network creation                                     |\n   //+------------------------------------------------------------------+\n   \n   ArrayResize(Layer,N_layers);\n   \n   //Architecture creation\n   biLSTMLayer            *biLSTM1 = new biLSTMLayer();\n   ActivationLayer      *ACT2  = new ActivationLayer();\n   FlattenLayer         *FLAT3 = new FlattenLayer();\n   DenseLayer           *ANN4  = new DenseLayer();\n   ActivationLayer      *ACT5  = new ActivationLayer();\n   \n   //The InitLayer method is used to initialize the weights of each layer\n   //The layer's parameters used in initialization are explained \n   //in the in its respective libraries in Layers directory\n\n\n   //Layers Initialization\n   biLSTM1.InitLayer(N_steps,N_entries,4,1,N,OP);\n   ACT2.InitLayer(TANH);  \n   ANN4.InitLayer(N_steps*1,1,N,OP);\n   ACT5.InitLayer(TANH);\n   \n   \n   //Neural Network \n   Layer[0] = biLSTM1;\n   Layer[1] = ACT2;\n   Layer[2] = FLAT3;\n   Layer[3] = ANN4;\n   Layer[4] = ACT5;\n   \n   //+------------------------------------------------------------------+\n   //|  Otimizers parameters                                 |\n   //+------------------------------------------------------------------+\n   \n   //ADAM\n   Adam(Beta1,Beta2,Alpha); \n\n   \n   //+------------------------------------------------------------------+\n   //|    Dataset pre-processing                                        |\n   //+------------------------------------------------------------------+\n   \n   //The pre-process methods are explained in TimeSeriesData.mqh library\n\n   //Shuffle  Dataset\n   //M = dataset.Shuffle(M);\n   \n   //Normalize dataset\n   M = time_series.NormalizeDataset(M);\n   \n   //training Dataset \n   matrix M_train;\n   M_train = time_series.DatasetTrain(M,train_ratio);\n   \n   // testing Dataset \n   matrix M_test;\n   M_test = time_series.DatasetTest(M,1-train_ratio);\n   \n   //+------------------------------------------------------------------+\n   //|    Weights                                                        |\n   //+------------------------------------------------------------------+\n   \n   //Load Neural Network weights\n   //Load(IAname);\n   \n   // Training:\n   Train(epoch,feature,N_steps,N,M_train);\n     \n   //Save the weigths\n   Save(IAname);\n    \n    \n   //+------------------------------------------------------------------+\n   //|   Evaluation                                                     |\n   //+------------------------------------------------------------------+\n   \n   \n   //Output\n   matrix Out;\n   Out = Test(M_test, N_steps);\n\n \n   //Compare\n   matrix Y_true = time_series.OutputTest(feature,N_steps,M_test);\n   \n   //Plotar outputs\n   time_series.PlotTest(Y_true,Out); \n   //time_series.PlotDataset(M,0);\n   \n   \n   //Accuracy\n   double mape;\n   mape = metrics.MAPE(Y_true,Out);\n   //int percent_accuracy;\n   //accuracy = metrics.Accuracy(R,Out);\n   //percent_accuracy = 100*accuracy;\n   \n   Print(\"The Mean Absolute Percentage Error of the model is \",mape);\n   \n   \n  }\n//+------------------------------------------------------------------+\n//|   Functions and methods                                             |\n//+--"
  },
  {
    "filename": "Loss.mqh",
    "source_type": "KOD",
    "content": " //+------------------------------------------------------------------+\n //|  Loss                                                            |\n //+------------------------------------------------------------------+\n  \nclass Loss : public DeepLearning\n{\npublic: \n   //Defines Cross Entropy for calculating error in classification problems\n   double CrossEntropy(matrix &R, matrix &Y);\n   //Defines the mean squared error for classification problems; \n   double MeanSquaredError(matrix &R, matrix &Y);\n   \n   //Defines the derivative of the cross entropy function. (Works with softmax previous activation layer)\n   matrix Grad_CE(matrix &R, matrix &Y);\n   //Two-class case (Only works with a sigmoid anterior activation layer)\n   matrix Grad_BinaryCE(matrix &R, matrix &Y);\n   //Defines the derivative of the Quadratic error function.\n   matrix Grad_MSE(matrix &R, matrix &Y);\n   \n   //notas: \n   //R is the expected output\n   //Y is the output calculated by the neural network\n};\n\n//+------------------------------------------------------------------+\n//|   Loss                                                           |\n//+------------------------------------------------------------------+\ndouble Loss::CrossEntropy(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\n\nL = R * MathLog(Y);\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}};\nreturn -l;\n}\ndouble Loss::MeanSquaredError(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\ndouble c;\nL = MathPow(R-Y,2);\nc = R.Rows();\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}}\n\nl = l/c;\nreturn l; \n}     \nmatrix Loss::Grad_CE(matrix &R, matrix &Y)\n{\nmatrix a;\na = (-1)*(R/Y);\nreturn a;\n}\nmatrix Loss::Grad_BinaryCE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c;\nc = R.Rows();\na = ((1 - R) / (1 - Y) - R / Y) / c;\nreturn a;\n}\nmatrix Loss::Grad_MSE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c; \nc = R.Rows();\na = 2*(Y - R)/c;\nreturn a;\n}",
    "search_content": " //+------------------------------------------------------------------+\n //|  Loss                                                            |\n //+------------------------------------------------------------------+\n  \nclass Loss : public DeepLearning\n{\npublic: \n   //Defines Cross Entropy for calculating error in classification problems\n   double CrossEntropy(matrix &R, matrix &Y);\n   //Defines the mean squared error for classification problems; \n   double MeanSquaredError(matrix &R, matrix &Y);\n   \n   //Defines the derivative of the cross entropy function. (Works with softmax previous activation layer)\n   matrix Grad_CE(matrix &R, matrix &Y);\n   //Two-class case (Only works with a sigmoid anterior activation layer)\n   matrix Grad_BinaryCE(matrix &R, matrix &Y);\n   //Defines the derivative of the Quadratic error function.\n   matrix Grad_MSE(matrix &R, matrix &Y);\n   \n   //notas: \n   //R is the expected output\n   //Y is the output calculated by the neural network\n};\n\n//+------------------------------------------------------------------+\n//|   Loss                                                           |\n//+------------------------------------------------------------------+\ndouble Loss::CrossEntropy(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\n\nL = R * MathLog(Y);\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}};\nreturn -l;\n}\ndouble Loss::MeanSquaredError(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\ndouble c;\nL = MathPow(R-Y,2);\nc = R.Rows();\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}}\n\nl = l/c;\nreturn l; \n}     \nmatrix Loss::Grad_CE(matrix &R, matrix &Y)\n{\nmatrix a;\na = (-1)*(R/Y);\nreturn a;\n}\nmatrix Loss::Grad_BinaryCE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c;\nc = R.Rows();\na = ((1 - R) / (1 - Y) - R / Y) / c;\nreturn a;\n}\nmatrix Loss::Grad_MSE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c; \nc = R.Rows();\na = 2*(Y - R)/c;\nreturn a;\n}"
  },
  {
    "filename": "ConvolutionalLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Convolutional Layer                                                               |\n//+------------------------------------------------------------------+\nclass ConvolutionalLayer : public DeepLearning\n  {\npublic:\n   //Initialize kernels and layer biases\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagate the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load Weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \n   \n   \nprivate:\n   //Kernel layer\n   matrix K;\n   //Kernel Gradient\n   matrix dK;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input layer\n   matrix Xe;\n   //Learning rate\n   double N;\n   //Optimization method\n   Optim OP;\n   //Convolution direction\n   CONV_DIR DIR;\n   \n   \n   //ADAM \n   //===============\n   //iteration counter\n   ulong it; \n   //m\n   matrix mK, mB;\n   //v\n   matrix vK, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Convolutional Layer                                            |\n//+------------------------------------------------------------------+\n\nvoid ConvolutionalLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD)\n{\n   DIR = direction;\n   \n   if(DIR == VERT)\n   { K.Init(N_steps-N_outputs+1,N_entries);\n   B.Init(N_steps-K.Rows()+1,N_entries);}\n   \n   if(DIR == HORZ)\n   { K.Init(N_entries,N_steps-N_outputs + 1);\n   B.Init(N_entries,N_steps - K.Cols() +1);}\n   \n   N = LR;\n   OP = Op;\n\n   K = InitWeights(K);\n   B = InitWeights(B);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mK.Init(K.Rows(),K.Cols());\n      vK.Init(K.Rows(),K.Cols());  \n      mK = ZeroMatrix(mK);\n      vK = ZeroMatrix(vK);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix ConvolutionalLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nif(DIR == VERT)Y = VertConvV(X,K) + B;\nif(DIR == HORZ)Y = HorConvV(X,K) + B;\nreturn Y;\n}\nmatrix ConvolutionalLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex,Ki,Xi;\n   if(DIR == VERT)\n   {\n   Ki = VertInv(K);\n   Ex = VertConvF(Ki,Ey);\n   \n   Xi = VertInv(Xe);\n   dK = VertConvV(Xi,Ey);\n   dB = Ey;}\n   \n   if(DIR == HORZ)\n   {\n   Ki = HorInv(K);\n   Ex = HorConvF(Ki,Ey);\n   \n   Xi = HorInv(Xe);\n   dK = HorConvV(Xi,Ey);\n   dB = Ey;}\n   return Ex;\n}\nvoid ConvolutionalLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      K = K - dK*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mK = AdamM(mK,dK,beta1);\n      vK = AdamV(vK,dK,beta2);\n      K = K - Adam(it,mK,vK,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B - Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid ConvolutionalLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k);\n   SaveMatrix(K,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid ConvolutionalLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname+ \"\\KLayer\" + IntegerToString(k);\n   K = LoadMatrix(csv_name);\n   csv_name = IAname+ \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid ConvolutionalLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|   Convolutional Layer                                                               |\n//+------------------------------------------------------------------+\nclass ConvolutionalLayer : public DeepLearning\n  {\npublic:\n   //Initialize kernels and layer biases\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagate the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load Weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \n   \n   \nprivate:\n   //Kernel layer\n   matrix K;\n   //Kernel Gradient\n   matrix dK;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input layer\n   matrix Xe;\n   //Learning rate\n   double N;\n   //Optimization method\n   Optim OP;\n   //Convolution direction\n   CONV_DIR DIR;\n   \n   \n   //ADAM \n   //===============\n   //iteration counter\n   ulong it; \n   //m\n   matrix mK, mB;\n   //v\n   matrix vK, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Convolutional Layer                                            |\n//+------------------------------------------------------------------+\n\nvoid ConvolutionalLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD)\n{\n   DIR = direction;\n   \n   if(DIR == VERT)\n   { K.Init(N_steps-N_outputs+1,N_entries);\n   B.Init(N_steps-K.Rows()+1,N_entries);}\n   \n   if(DIR == HORZ)\n   { K.Init(N_entries,N_steps-N_outputs + 1);\n   B.Init(N_entries,N_steps - K.Cols() +1);}\n   \n   N = LR;\n   OP = Op;\n\n   K = InitWeights(K);\n   B = InitWeights(B);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mK.Init(K.Rows(),K.Cols());\n      vK.Init(K.Rows(),K.Cols());  \n      mK = ZeroMatrix(mK);\n      vK = ZeroMatrix(vK);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix ConvolutionalLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nif(DIR == VERT)Y = VertConvV(X,K) + B;\nif(DIR == HORZ)Y = HorConvV(X,K) + B;\nreturn Y;\n}\nmatrix ConvolutionalLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex,Ki,Xi;\n   if(DIR == VERT)\n   {\n   Ki = VertInv(K);\n   Ex = VertConvF(Ki,Ey);\n   \n   Xi = VertInv(Xe);\n   dK = VertConvV(Xi,Ey);\n   dB = Ey;}\n   \n   if(DIR == HORZ)\n   {\n   Ki = HorInv(K);\n   Ex = HorConvF(Ki,Ey);\n   \n   Xi = HorInv(Xe);\n   dK = HorConvV(Xi,Ey);\n   dB = Ey;}\n   return Ex;\n}\nvoid ConvolutionalLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      K = K - dK*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mK = AdamM(mK,dK,beta1);\n      vK = AdamV(vK,dK,beta2);\n      K = K - Adam(it,mK,vK,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B - Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid ConvolutionalLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k);\n   SaveMatrix(K,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid ConvolutionalLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname+ \"\\KLayer\" + IntegerToString(k);\n   K = LoadMatrix(csv_name);\n   csv_name = IAname+ \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid ConvolutionalLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}\n"
  },
  {
    "filename": "MaxPoolingLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Max Pooling                                                    |\n//+------------------------------------------------------------------+\n\nclass MaxPoolingLayer : public DeepLearning\n  {\npublic:\n   //Initializes parameters\n   void   InitLayer( int stride, CONV_DIR direction);\n   //Calculates the output of the litter from an input\n   //The output dimension is  Ceil(N_entries / stride)\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n\nprivate:\n   //Stride\n   int S;\n   //Direction\n   CONV_DIR DIR; \n   //Matrix with the index of the maximum values\n   matrix Max;\n   //Number of steps \n   int Steps; \n   \n   //\n  };\n\n//+------------------------------------------------------------------+\n//|    Max Pooling                                                              |\n//+------------------------------------------------------------------+\nvoid   MaxPoolingLayer::InitLayer( int stride, CONV_DIR direction)\n{\nS = stride;\nDIR = direction;\n\n}\nmatrix MaxPoolingLayer::Output(matrix &X)\n{\nmatrix M,MP,Mx;\n\nif(DIR == VERT)\n  {\n   M.Init(S,X.Cols());\n   \n   int N_slides,N_steps,count;\n   Steps = X.Rows();\n   \n   double N_out; \n   N_out = X.Rows();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   MP.Init(N_slides,X.Cols());\n   Mx.Init(N_slides,X.Cols());\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+i < Steps)  M[i][j] = X[k*S+i][j];\n            if(k*S+i >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(0);\n      for(int i=0;i<MP.Cols();i++)\n        {count = v[i];\n         MP[k][i] = M[count][i];\n         Mx[k][i] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nif(DIR == HORZ)\n  {\n   M.Init(X.Rows(),S);\n   \n   int N_slides,N_steps,count;\n   Steps = X.Cols();\n   \n   double N_out; \n   N_out = X.Cols();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   \n   MP.Init(X.Rows(),N_slides);\n   Mx.Init(X.Rows(),N_slides);\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+j < Steps)  M[i][j] = X[i][k*S+j];\n            if(k*S+j >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(1);\n      for(int i=0;i<MP.Rows();i++)\n        {count = v[i];\n         MP[i][k] = M[i][count];\n         Mx[i][k] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nreturn MP;\n}\n\nmatrix MaxPoolingLayer::GradDescent(matrix &Ey)\n{\n\n   matrix Ex;\nif(DIR == VERT)\n{\n   Ex.Init(Steps,Ey.Cols());\n   \n   for(int k=0;k<Steps;k++)\n      {for(int j=0;j<Ey.Cols();j++)\n        {for(int i=0;i<S;i++)\n           {if(k*S+i < Steps)\n              {if(i == Max[k][j])\n              { Ex[k*S+i][j] = Ey[k][j];}\n               if(i != Max[k][j]) \n               {Ex[k*S+i][j] = 0;}\n               \n       }}}}\n}\nif(DIR == HORZ)\n{\n   Ex.Init(Ey.Rows(),Steps);\n   \n   for(int k=0;k<Steps;k++)\n      {for(int i=0;i<Ey.Rows();i++)\n        {for(int j=0;j<S;j++)\n           {if(k*S+j < Steps)\n              {if(j == Max[i][k])\n              { Ex[i][k*S+j] = Ey[i][k];}\n               if(j != Max[i][k]) \n               {Ex[i][k*S+j] = 0;}\n               \n       }}}}\n}        \nreturn Ex;\n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|   Max Pooling                                                    |\n//+------------------------------------------------------------------+\n\nclass MaxPoolingLayer : public DeepLearning\n  {\npublic:\n   //Initializes parameters\n   void   InitLayer( int stride, CONV_DIR direction);\n   //Calculates the output of the litter from an input\n   //The output dimension is  Ceil(N_entries / stride)\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n\nprivate:\n   //Stride\n   int S;\n   //Direction\n   CONV_DIR DIR; \n   //Matrix with the index of the maximum values\n   matrix Max;\n   //Number of steps \n   int Steps; \n   \n   //\n  };\n\n//+------------------------------------------------------------------+\n//|    Max Pooling                                                              |\n//+------------------------------------------------------------------+\nvoid   MaxPoolingLayer::InitLayer( int stride, CONV_DIR direction)\n{\nS = stride;\nDIR = direction;\n\n}\nmatrix MaxPoolingLayer::Output(matrix &X)\n{\nmatrix M,MP,Mx;\n\nif(DIR == VERT)\n  {\n   M.Init(S,X.Cols());\n   \n   int N_slides,N_steps,count;\n   Steps = X.Rows();\n   \n   double N_out; \n   N_out = X.Rows();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   MP.Init(N_slides,X.Cols());\n   Mx.Init(N_slides,X.Cols());\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+i < Steps)  M[i][j] = X[k*S+i][j];\n            if(k*S+i >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(0);\n      for(int i=0;i<MP.Cols();i++)\n        {count = v[i];\n         MP[k][i] = M[count][i];\n         Mx[k][i] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nif(DIR == HORZ)\n  {\n   M.Init(X.Rows(),S);\n   \n   int N_slides,N_steps,count;\n   Steps = X.Cols();\n   \n   double N_out; \n   N_out = X.Cols();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   \n   MP.Init(X.Rows(),N_slides);\n   Mx.Init(X.Rows(),N_slides);\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+j < Steps)  M[i][j] = X[i][k*S+j];\n            if(k*S+j >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(1);\n      for(int i=0;i<MP.Rows();i++)\n        {count = v[i];\n         MP[i][k] = M[i][count];\n         Mx[i][k] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nreturn MP;\n}\n\nmatrix MaxPoolingLayer::GradDescent(matrix &Ey)\n{\n\n   matrix Ex;\nif(DIR == VERT)\n{\n   Ex.Init(Steps,Ey.Cols());\n   \n   for(int k=0;k<Steps;k++)\n      {for(int j=0;j<Ey.Cols();j++)\n        {for(int i=0;i<S;i++)\n           {if(k*S+i < Steps)\n              {if(i == Max[k][j])\n              { Ex[k*S+i][j] = Ey[k][j];}\n               if(i != Max[k][j]) \n               {Ex[k*S+i][j] = 0;}\n               \n       }}}}\n}\nif(DIR == HORZ)\n{\n   Ex.Init(Ey.Rows(),Steps);\n   \n   for(int k=0;k<Steps;k++)\n      {for(int i=0;i<Ey.Rows();i++)\n        {for(int j=0;j<S;j++)\n           {if(k*S+j < Steps)\n              {if(j == Max[i][k])\n              { Ex[i][k*S+j] = Ey[i][k];}\n               if(j != Max[i][k]) \n               {Ex[i][k*S+j] = 0;}\n               \n       }}}}\n}        \nreturn Ex;\n}\n"
  },
  {
    "filename": "SumConvLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+\n\nclass SumConvLayer : public DeepLearning\n  {\npublic :\n   //Inicializa os kernels e o bias da camada\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD);\n   //Calcula a sa\u00edda da camada a partir de uma entrada\n   virtual matrix Output(matrix &X);\n   //Propaga o Erro \n   virtual matrix GradDescent(matrix &Ey);\n   //Atualiza os pesos\n   virtual void   Update(void);\n   //Salvar os pesos, k \u00e9 o indice da camada;\n   virtual void   SaveWeights(int k,string IAname);\n   //Carregar os pesos\n   virtual void   LoadWeights(int k,string IAname);\n\nprivate:\n   //Number of convolutions\n   int N_C;\n   //Kernel da Camada\n   matrix K[];\n   //Gradiente do Kernel\n   matrix dK[];\n   //Bias da camada\n   matrix B[];\n   //Gradiente do Bias\n   matrix dB[];\n   //Entrada da Camada de ativa\u00e7\u00e3o\n   matrix Xact[];\n   //Peso auxiliar\n   matrix C[];\n   //gradiente do peso auxiliar \n   matrix dC[];\n   //Entrada da Camada convolucional\n   matrix Xc;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimiza\u00e7\u00e3o\n   Optim OP;\n   //Dire\u00e7\u00e3o da convolu\u00e7\u00e3o\n   CONV_DIR DIR;\n   //Fun\u00e7\u00e3o de Ativa\u00e7\u00e3o\n   ActFunction AF;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mK[], mB[], mC[];\n   //v\n   matrix vK[], vB[], vC[];\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+ \nvoid SumConvLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR,int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD)\n{\n   N_C = N_Conv;\n   AF = af;\n   \n   double factor; \n   factor = N_Conv;\n   factor = 1 / factor; \n   \n   ArrayResize(K,N_C);\n   ArrayResize(dK,N_C);\n   \n   ArrayResize(B,N_C);\n   ArrayResize(dB,N_C);\n   \n   ArrayResize(Xact,N_C);\n   ArrayResize(C,N_C);\n   ArrayResize(dC,N_C);\n   \nfor(int i=0;i<N_C;i++)\n  {\n      if(direction == VERT)\n      {  K[i].Init(N_steps-N_outputs+1,N_entries);\n         B[i].Init(N_steps-K[i].Rows()+1,N_entries);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   \n      if(direction == HORZ)\n      {  K[i].Init(N_entries,N_steps-N_outputs + 1);\n         B[i].Init(N_entries,N_steps - K[i].Rows() +1);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   }\n   N = LR;\n   OP = Op;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      ArrayResize(mK,N_C);\n      ArrayResize(vK,N_C);\n      \n      ArrayResize(mB,N_C);\n      ArrayResize(vB,N_C);\n      \n      ArrayResize(mC,N_C);\n      ArrayResize(vC,N_C);\n      \n      for(int i=0;i<N_C;i++)\n      {\n         mK[i].Init(K[i].Rows(),K[i].Cols());\n         vK[i].Init(K[i].Rows(),K[i].Cols());  \n         mK[i] = ZeroMatrix(mK[i]);\n         vK[i] = ZeroMatrix(vK[i]);\n         \n         mB[i].Init(B[i].Rows(),B[i].Cols());\n         vB[i].Init(B[i].Rows(),B[i].Cols());\n         mB[i] = ZeroMatrix(mB[i]);\n         vB[i] = ZeroMatrix(vB[i]);\n         \n         mC[i].Init(C[i].Rows(),C[i].Cols());\n         vC[i].Init(C[i].Rows(),C[i].Cols());\n         mC[i] = ZeroMatrix(mC[i]);\n         vC[i] = ZeroMatrix(vC[i]);\n      }\n     }\n}\nmatrix SumConvLayer::Output(matrix &X)\n{\nmatrix Out, Y[];\nXc = X;\nArrayResize(Y,N_C);\nfor(int i=0;i<N_C;i++)\n  {\n   if(DIR == VERT) Y[i] = VertConvV(X,K[i]) + B[i];\n   if(DIR == HORZ) Y[i] = HorConvV(X,K[i]) + B[i];\n   }\nOut.Init(B[0].Rows(),B[0].Cols());\n\n//Gravar a entrada\nfor(int i=0;i<N_C;i++)\n  {Xact[i] = Y[i];}\n\n//Zerar a sa\u00edda \nfor(int i=0;i<Out.Rows();i++)\n  {for(int j=0;j<Out.Cols();j++)\n     {Out[i][j] = 0;}}\n\n//Aplicar a fun\u00e7\u00e3o de ativa\u00e7\u00e3o; \nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) Y[i] = Sig(Y[i]);\n   if(AF == TANH)    Y[i] = Tanh(Y[i]);\n   if(AF == RELU)    Y[i] = ReLU(Y[i]);}\n\n//Soma tudo\nfor(int i=0;i<N_C;i++)\n  {Out +=Y[i] * C[i];}\n  \nreturn Out;\n}\n\nmatrix SumConvLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex,dphi[]; \nArrayResize(dphi,N_C);\nEx.Init(Xc.Rows(),Xc.Cols());\n\n//Peso auxiliar\nfor(int i=0;i<N_C;i++)\n   {if(AF == SIGMOID) dC[i] = Sig(Xact[i]) * Ey;\n   if(AF == TANH) dC[i] = Tanh(Xact[i]) * Ey;\n   if(AF == RELU) dC[i] = ReLU(Xact[i]) * Ey;}\n\n//Calcular a derivada da fun\u00e7\u00e3o de ativa\u00e7\u00e3o\nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) dphi[i] = dSig(Xact[i]) * Ey *C[i];\n   if(AF == TANH) dphi[i] = dTanh(Xact[i]) * Ey *C[i];\n   if(AF == RELU) dphi[i] = dReLU(Xact[i]) * Ey *C[i];}\n\n//Zerar o gradiente da entrada\nfor(int i=0;i<Ex.Rows();i++)\n  {for(int j=0;j<Ex.Cols();j++)\n     {Ex[i][j] = 0;}}\n\nmatrix Inv;\n//Calcular as varia\u00e7\u00f5es dos pesos\nfor(int i=0;i<N_C;i++)\n  {if(DIR == VERT)\n     {Inv = VertInv(K[i]);\n      Ex += VertConvF(Inv,dphi[i]);\n      Inv = VertInv(Xc);\n      dK[i] = VertConvV(Inv,dphi[i]);\n      dB[i] = dphi[i];}\n      \n   \n   if(DIR == HORZ)\n     {Inv = HorInv(K[i]);\n      Ex += HorConvF(Inv,dphi[i]);\n      Inv = HorInv(Xc);\n      dK[i] = HorConvV(Inv,dphi[i]);\n      dB[i] = dphi[i];} \n  } \n\nreturn Ex;   \n}\n\n\nvoid   SumConvLayer::Update(void)\n{\nif(OP == STD)\n   {for(int i=0;i<N_C;i++)\n     {K[i] = K[i] - dK[i]*N;\n      B[i] = B[i] - dB[i]*N;\n      C[i] = C[i] - dC[i]*N;\n     }\n   }\nif(OP == ADAM)\n  {\n   it +=1;\n   for(int i=0;i<N_C;i++)\n     {\n      mK[i] = AdamM(mK[i],dK[i],beta1);\n      vK[i] = AdamV(vK[i],dK[i],beta2);\n      K[i] = K[i] - Adam(it,mK[i],vK[i],beta1,beta2,alpha);\n      \n      mB[i] = AdamM(mB[i],dB[i],beta1);\n      vB[i] = AdamV(vB[i],dB[i],beta2);\n      B[i] = B[i] - Adam(it,mB[i],vB[i],beta1,beta2,alpha);\n      \n      mC[i] = AdamM(mC[i],dC[i],beta1);\n      vC[i] = AdamV(vC[i],dC[i],beta2);\n      C[i] = C[i] - Adam(it,mC[i],vC[i],beta1,beta2,alpha);\n     }\n  }\n}\n\nvoid   SumConvLayer::SaveWeights(int k,string IAname)\n{\nfor(int i=0;i<N_C;i++)\n  {\n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(K[i],csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(B[i],csv_name);\n   csv_name = IAname + \"\\CLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(C[i],csv_name);\n  }\n}\n\nvoid   SumConvLayer::LoadWeights(int k,string IAname)\n{\nfor(int i=0;i<N_C;i++)\n   {  \n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k) + IntegerToString(i);\n   K[i] = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k) + IntegerToString(i);\n   B[i] = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k) + IntegerToString(i);\n   C[i] = LoadMatrix(csv_name);\n   }\n}",
    "search_content": "//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+\n\nclass SumConvLayer : public DeepLearning\n  {\npublic :\n   //Inicializa os kernels e o bias da camada\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD);\n   //Calcula a sa\u00edda da camada a partir de uma entrada\n   virtual matrix Output(matrix &X);\n   //Propaga o Erro \n   virtual matrix GradDescent(matrix &Ey);\n   //Atualiza os pesos\n   virtual void   Update(void);\n   //Salvar os pesos, k \u00e9 o indice da camada;\n   virtual void   SaveWeights(int k,string IAname);\n   //Carregar os pesos\n   virtual void   LoadWeights(int k,string IAname);\n\nprivate:\n   //Number of convolutions\n   int N_C;\n   //Kernel da Camada\n   matrix K[];\n   //Gradiente do Kernel\n   matrix dK[];\n   //Bias da camada\n   matrix B[];\n   //Gradiente do Bias\n   matrix dB[];\n   //Entrada da Camada de ativa\u00e7\u00e3o\n   matrix Xact[];\n   //Peso auxiliar\n   matrix C[];\n   //gradiente do peso auxiliar \n   matrix dC[];\n   //Entrada da Camada convolucional\n   matrix Xc;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimiza\u00e7\u00e3o\n   Optim OP;\n   //Dire\u00e7\u00e3o da convolu\u00e7\u00e3o\n   CONV_DIR DIR;\n   //Fun\u00e7\u00e3o de Ativa\u00e7\u00e3o\n   ActFunction AF;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mK[], mB[], mC[];\n   //v\n   matrix vK[], vB[], vC[];\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+ \nvoid SumConvLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR,int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD)\n{\n   N_C = N_Conv;\n   AF = af;\n   \n   double factor; \n   factor = N_Conv;\n   factor = 1 / factor; \n   \n   ArrayResize(K,N_C);\n   ArrayResize(dK,N_C);\n   \n   ArrayResize(B,N_C);\n   ArrayResize(dB,N_C);\n   \n   ArrayResize(Xact,N_C);\n   ArrayResize(C,N_C);\n   ArrayResize(dC,N_C);\n   \nfor(int i=0;i<N_C;i++)\n  {\n      if(direction == VERT)\n      {  K[i].Init(N_steps-N_outputs+1,N_entries);\n         B[i].Init(N_steps-K[i].Rows()+1,N_entries);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   \n      if(direction == HORZ)\n      {  K[i].Init(N_entries,N_steps-N_outputs + 1);\n         B[i].Init(N_entries,N_steps - K[i].Rows() +1);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   }\n   N = LR;\n   OP = Op;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      ArrayResize(mK,N_C);\n      ArrayResize(vK,N_C);\n      \n      ArrayResize(mB,N_C);\n      ArrayResize(vB,N_C);\n      \n      ArrayResize(mC,N_C);\n      ArrayResize(vC,N_C);\n      \n      for(int i=0;i<N_C;i++)\n      {\n         mK[i].Init(K[i].Rows(),K[i].Cols());\n         vK[i].Init(K[i].Rows(),K[i].Cols());  \n         mK[i] = ZeroMatrix(mK[i]);\n         vK[i] = ZeroMatrix(vK[i]);\n         \n         mB[i].Init(B[i].Rows(),B[i].Cols());\n         vB[i].Init(B[i].Rows(),B[i].Cols());\n         mB[i] = ZeroMatrix(mB[i]);\n         vB[i] = ZeroMatrix(vB[i]);\n         \n         mC[i].Init(C[i].Rows(),C[i].Cols());\n         vC[i].Init(C[i].Rows(),C[i].Cols());\n         mC[i] = ZeroMatrix(mC[i]);\n         vC[i] = ZeroMatrix(vC[i]);\n      }\n     }\n}\nmatrix SumConvLayer::Output(matrix &X)\n{\nmatrix Out, Y[];\nXc = X;\nArrayResize(Y,N_C);\nfor(int i=0;i<N_C;i++)\n  {\n   if(DIR == VERT) Y[i] = VertConvV(X,K[i]) + B[i];\n   if(DIR == HORZ) Y[i] = HorConvV(X,K[i]) + B[i];\n   }\nOut.Init(B[0].Rows(),B[0].Cols());\n\n//Gravar a entrada\nfor(int i=0;i<N_C;i++)\n  {Xact[i] = Y[i];}\n\n//Zerar a sa\u00edda \nfor(int i=0;i<Out.Rows();i++)\n  {for(int j=0;j<Out.Cols();j++)\n     {Out[i][j] = 0;}}\n\n//Aplicar a fun\u00e7\u00e3o de ativa\u00e7\u00e3o; \nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) Y[i] = Sig(Y[i]);\n   if(AF == TANH)    Y[i] = Tanh(Y[i]);\n   if(AF == RELU)    Y[i] = ReLU(Y[i]);}\n\n//Soma tudo\nfor(int i=0;i<N_C;i++)\n  {Out +=Y[i] * C[i];}\n  \nreturn Out;\n}\n\nmatrix SumConvLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex,dphi[]; \nArrayResize(dphi,N_C);\nEx.Init(Xc.Rows(),Xc.Cols());\n\n//Peso auxiliar\nfor(int i=0;i<N_C;i++)\n   {if(AF == SIGMOID) dC[i] = Sig(Xact[i]) * Ey;\n   if(AF == TANH) dC[i] = Tanh(Xact[i]) * Ey;\n   if(AF == RELU) dC[i] = ReLU(Xact[i]) * Ey;}\n\n//Calcular a derivada da fun\u00e7\u00e3o de ativa\u00e7\u00e3o\nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) dphi[i] = dSig(Xact[i]) * Ey *C[i];\n   if(AF == TANH) dphi[i] = dTanh(Xact[i]) * Ey *C[i];\n   "
  },
  {
    "filename": "LSTMLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\nclass LSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Changing ADAM parameters\n   virtual void   SetAdam(double B1, double B2, double Alph); \n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //Forget gate\n   matrix Wf,Bf,Zf[],\n          dWf,dBf;\n   //Input gate\n   matrix Wi,Bi,Zi[],\n          dWi,dBi;\n   //Output gate\n   matrix Wo,Bo,Zo[],\n          dWo,dBo;\n   //Candidate gate\n   matrix Wg,Bg,Zg[],\n          dWg,dBg;\n   //output\n   matrix Wy,By,Zy[],\n          dWy,dBy;\n   //Hidden state\n   matrix H[];\n   //Long term memory\n   matrix C[];\n   //Input\n   matrix x[],x_h[];\n  \n   //ADAM \n   //===============\n   //Iteration counter\n   ulong it; \n   //m\n   matrix mWy, mWf, mWo, mWi, mWg;\n   matrix mBy, mBf, mBo, mBi, mBg;\n   //v\n   matrix vWy, vWf, vWo, vWi, vWg;\n   matrix vBy, vBf, vBo, vBi, vBg;\n   \n   //hiperparameters \n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\n\nvoid LSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//forget gate\nWf.Init(N_H,N_H + N_ins);\ndWf.Init(N_H,N_H + N_ins);\nWf = InitWeights(Wf)*xavier_;\n\nBf.Init(N_H,1);\ndBf.Init(N_H,1);\nBf = InitWeights(Bf)*xavier_;\n\nArrayResize(Zf,N_ts);\n     \n//input gate\nWi.Init(N_H,N_H + N_ins);\ndWi.Init(N_H,N_H + N_ins);\nWi = InitWeights(Wi)*xavier_;\n\nBi.Init(N_H,1);\ndBi.Init(N_H,1);\nBi = InitWeights(Bi)*xavier_;\n\nArrayResize(Zi,N_ts);\n//output gate\nWo.Init(N_H,N_H + N_ins);\ndWo.Init(N_H,N_H + N_ins);\nWo = InitWeights(Wo)*xavier_;\n\nBo.Init(N_H,1);\ndBo.Init(N_H,1);\nBo = InitWeights(Bo)*xavier_;\n\nArrayResize(Zo,N_ts);     \n// candidate gate\nWg.Init(N_H,N_H + N_ins);\ndWg.Init(N_H,N_H + N_ins);\nWg = InitWeights(Wg)*xavier_;\n\nBg.Init(N_H,1);\ndBg.Init(N_H,1);\nBg = InitWeights(Bg)*xavier_;\n\nArrayResize(Zg,N_ts);\n//Output\nWy.Init(N_outs,N_H);\ndWy.Init(N_outs,N_H);\nWy = InitWeights(Wy)*xavier_;\n\n\nBy.Init(N_outs,1);\ndBy.Init(N_outs,1);\nBy = InitWeights(By)*xavier_;\n\nArrayResize(Zy,N_ts);\n\n//Estado Oculto\nArrayResize(H,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(C,N_ts+1);\n\n//Entrada \nArrayResize(x,N_ts);\nArrayResize(x_h,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWy.Init(Wy.Rows(),Wy.Cols());\n      vWy.Init(Wy.Rows(),Wy.Cols());  \n      mWy = ZeroMatrix(mWy);\n      vWy = ZeroMatrix(vWy);\n      \n      mBy.Init(By.Rows(),By.Cols());\n      vBy.Init(By.Rows(),By.Cols());\n      mBy= ZeroMatrix(mBy);\n      vBy = ZeroMatrix(vBy);\n      \n      //Forget gate\n      mWf.Init(Wf.Rows(),Wf.Cols());\n      vWf.Init(Wf.Rows(),Wf.Cols());  \n      mWf = ZeroMatrix(mWf);\n      vWf = ZeroMatrix(vWf);\n      \n      mBf.Init(Bf.Rows(),Bf.Cols());\n      vBf.Init(Bf.Rows(),Bf.Cols());\n      mBf = ZeroMatrix(mBf);\n      vBf = ZeroMatrix(vBf);\n      \n      //Output Gate\n      mWo.Init(Wo.Rows(),Wo.Cols());\n      vWo.Init(Wo.Rows(),Wo.Cols());  \n      mWo = ZeroMatrix(mWo);\n      vWo = ZeroMatrix(vWo);\n      \n      mBo.Init(Bo.Rows(),Bo.Cols());\n      vBo.Init(Bo.Rows(),Bo.Cols());\n      mBo = ZeroMatrix(mBo);\n      vBo = ZeroMatrix(vBo);\n      \n      //Input Gate\n      mWi.Init(Wi.Rows(),Wi.Cols());\n      vWi.Init(Wi.Rows(),Wi.Cols());  \n      mWi = ZeroMatrix(mWi);\n      vWi = ZeroMatrix(vWi);\n      \n      mBi.Init(Bi.Rows(),Bi.Cols());\n      vBi.Init(Bi.Rows(),Bi.Cols());\n      mBi = ZeroMatrix(mBi);\n      vBi = ZeroMatrix(vBi);\n      \n      //Candidate Gate\n      mWg.Init(Wg.Rows(),Wg.Cols());\n      vWg.Init(Wg.Rows(),Wg.Cols());  \n      mWg = ZeroMatrix(mWg);\n      vWg = ZeroMatrix(vWg);\n      \n      mBg.Init(Bg.Rows(),Bg.Cols());\n      vBg.Init(Bg.Rows(),Bg.Cols());\n      mBg = ZeroMatrix(mBg);\n      vBg = ZeroMatrix(vBg);\n     } \n}\nmatrix LSTMLayer::Output(matrix &X)\n{\n//Zera o estado oculto anterior\n\nH[0].Init(N_H,1);\nH[0] = ZeroMatrix(H[0]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nC[0].Init(N_H,1);\nC[0] = ZeroMatrix(C[0]);\n\n     \n//Define a matrix de sa\u00edda \nmatrix Y; \nY.Init(N_outs,N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix y;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {x[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix F,I,O,G; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {x[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_h[t] = Concatenate(H[t],x[t]); \n\n\n   //Forget gate\n   Zf[t] = Wf.MatMul(x_h[t])  + Bf;\n   F = Sig(Zf[t]);\n   //Imput gate\n   Zi[t] = Wi.MatMul(x_h[t])  + Bi;\n   I = Sig(Zi[t]);\n   //Output gate\n   Zo[t] = Wo.MatMul(x_h[t])  + Bo;\n   O = Sig(Zo[t]);\n   //Candidate gate\n   Zg[t] = Wg.MatMul(x_h[t])  + Bg;\n   G = Tanh(Zg[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   C[t+1] = F * C[t] + I * G;\n   //C\u00e1lculo do novo estado oculto\n   H[t+1] = Tanh(C[t+1]);\n   H[t+1]= H[t+1] * O;\n   \n   //Sa\u00edda\n   y = Wy.MatMul(H[t+1]) + By;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<y.Rows();i++)\n     {Y[i][t] = y[i][0];}\n    \n  }\nreturn Y;\n}\nmatrix LSTMLayer::GradDescent(matrix &Ey)\n{\n//Gradient \nmatrix Ex;\nEx.Init(N_ins,N_ts);\n \n//Forget Gate\ndWf = ZeroMatrix(dWf);\ndBf = ZeroMatrix(dBf);\n\n//Input Gate\ndWi = ZeroMatrix(dWi);\ndBi = ZeroMatrix(dBi);\n\n//Output Gate\ndWo = ZeroMatrix(dWo);\ndBo = ZeroMatrix(dBo);\n\n//Candidate Gate\ndWg = ZeroMatrix(dWg);\ndBg = ZeroMatrix(dBg);\n\n//Y gate\ndWy = ZeroMatrix(dWy);\ndBy = ZeroMatrix(dBy);\n//Erro por passo de tempo \nmatrix ey;\ney.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_h, d_c, d_f, d_i, d_o, d_g,d_x_h;\n\n//Estado oculto para t+1\nmatrix dh_next;\ndh_next.Init(N_H,1);\ndh_next = ZeroMatrix(dh_next);\n\nmatrix dc_next;\ndc_next.Init(N_H,1);\ndc_next = ZeroMatrix(dc_next);\n\nmatrix ex;\nex.Init(N_ins,1);\n\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {ey[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWy += ey.MatMul(H[t+1].Transpose());\n   dBy += ey;\n   \n   //Hidden State Error\n   d_h = Wy.Transpose();\n   d_h = d_h.MatMul(ey) + dh_next;\n   \n   //Output gate\n   d_o = d_h * Tanh(C[t+1]) * dSig(Zo[t]);\n   dWo += d_o.MatMul(x_h[t].Transpose());\n   dBo += d_o;\n   \n   //Cell state error\n   d_c = d_h * dTanh(C[t+1]) * Sig(Zo[t]) + dc_next;\n   \n   //Forget gate\n   d_f = d_c * C[t] * dSig(Zf[t]);\n   dWf += d_f.MatMul(x_h[t].Transpose());\n   dBf += d_f;\n   \n   //Input gate\n   d_i = d_c * Tanh(Zg[t]) * dSig(Zi[t]);\n   dWi += d_i.MatMul(x_h[t].Transpose());\n   dBi += d_i;\n   \n   //Candidate gate\n   d_g = d_c * Sig(Zi[t]) * dTanh(Zg[t]);\n   dWg += d_g.MatMul(x_h[t].Transpose());\n   dBg += d_g;\n   \n   //Concatenated Input gradient\n   d_x_h = Wf.Transpose().MatMul(d_f) + Wi.Transpose().MatMul(d_i) + Wo.Transpose().MatMul(d_o) + Wg.Transpose().MatMul(d_g);\n   \n   //Error of Cell state of next time step\n   dc_next = Sig(Zf[t]) * d_c; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_h.Rows();i++)\n     {if(i < N_H) dh_next[i][0] = d_x_h[i][0];\n      if(i >= N_H) ex[i-N_H][0] = d_x_h[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex.Rows();i++)\n     {Ex[i][t] = ex[i][0];}   \n  \n  }\nreturn Ex;\n}\nvoid   LSTMLayer::Update(void)\n{\nif(OP == STD)\n  {\n   Wf = Wf - dWf*N;\n   Wi = Wi - dWi*N;\n   Wo = Wo - dWo*N;\n   Wg = Wg - dWg*N;\n   Wy = Wy - dWy*N;\n   \n   Bf = Bf - dBf*N;\n   Bi = Bi - dBi*N;\n   Bo = Bo - dBo*N;\n   Bg = Bg - dBg*N;\n   By = By - dBy*N;\n  }\n\nif(OP == ADAM)\n  {\n      it +=1;\n      //sa\u00edda\n      mWy = AdamM(mWy,dWy,beta1);\n      vWy = AdamV(vWy,dWy,beta2);\n      Wy = Wy - Adam(it,mWy,vWy,beta1,beta2,alpha);\n      \n      mBy = AdamM(mBy,dBy,beta1);\n      vBy = AdamV(vBy,dBy,beta2);\n      By = By -Adam(it,mBy,vBy,beta1,beta2,alpha);\n      \n      //Forget\n      mWf = AdamM(mWf,dWf,beta1);\n      vWf = AdamV(vWf,dWf,beta2);\n      Wf = Wf - Adam(it,mWf,vWf,beta1,beta2,alpha);\n      \n      mBf = AdamM(mBf,dBf,beta1);\n      vBf = AdamV(vBf,dBf,beta2);\n      Bf = Bf -Adam(it,mBf,vBf,beta1,beta2,alpha);\n      \n      //Output\n      mWo = AdamM(mWo,dWo,beta1);\n      vWo = AdamV(vWo,dWo,beta2);\n      Wo = Wo - Adam(it,mWo,vWo,beta1,beta2,alpha);\n      \n      mBo = AdamM(mBo,dBo,beta1);\n      vBo = AdamV(vBo,dBo,beta2);\n      Bo = Bo -Adam(it,mBo,vBo,beta1,beta2,alpha);\n      \n      //Input\n      mWi = AdamM(mWi,dWi,beta1);\n      vWi = AdamV(vWi,dWi,beta2);\n      Wi = Wi- Adam(it,mWi,vWi,beta1,beta2,alpha);\n      \n      mBi = AdamM(mBi,dBi,beta1);\n      vBi = AdamV(vBi,dBi,beta2);\n      Bi = Bi -Adam(it,mBi,vBi,beta1,beta2,alpha);\n      \n      //Candidate\n      mWg = AdamM(mWg,dWg,beta1);\n      vWg = AdamV(vWg,dWg,beta2);\n      Wg = Wg - Adam(it,mWg,vWg,beta1,beta2,alpha);\n      \n      mBg = AdamM(mBg,dBg,beta1);\n      vBg = AdamV(vBg,dBg,beta2);\n      Bg = Bg -Adam(it,mBg,vBg,beta1,beta2,alpha);\n  }\n\n}\nvoid   LSTMLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfLayer\" + IntegerToString(k);\n   SaveMatrix(Wf,csv_name);\n   csv_name = IAname + \"\\WiLayer\" + IntegerToString(k);\n   SaveMatrix(Wi,csv_name);\n   csv_name = IAname + \"\\WoLayer\" + IntegerToString(k);\n   SaveMatrix(Wo,csv_name);\n   csv_name = IAname + \"\\WgLayer\" + IntegerToString(k);\n   SaveMatrix(Wg,csv_name);\n   csv_name = IAname + \"\\WyLayer\" + IntegerToString(k);\n   SaveMatrix(Wy,csv_name);\n   \n   csv_name = IAname + \"\\BfLayer\" + IntegerToString(k);\n   SaveMatrix(Bf,csv_name);\n   csv_name = IAname + \"\\BiLayer\" + IntegerToString(k);\n   SaveMatrix(Bi,csv_name);\n   csv_name = IAname + \"\\BoLayer\" + IntegerToString(k);\n   SaveMatrix(Bo,csv_name);\n   csv_name = IAname + \"\\BgLayer\" + IntegerToString(k);\n   SaveMatrix(Bg,csv_name);\n   csv_name = IAname + \"\\ByLayer\" + IntegerToString(k);\n   SaveMatrix(By,csv_name);\n}\nvoid   LSTMLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfLayer\" + IntegerToString(k);\n   Wf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WiLayer\" + IntegerToString(k);\n   Wi = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WoLayer\" + IntegerToString(k);\n   Wo = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgLayer\" + IntegerToString(k);\n   Wg = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WyLayer\" + IntegerToString(k);\n   Wy = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BfLayer\" + IntegerToString(k);\n   Bf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BiLayer\" + IntegerToString(k);\n   Bi = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BoLayer\" + IntegerToString(k);\n   Bo = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgLayer\" + IntegerToString(k);\n   Bg = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\ByLayer\" + IntegerToString(k);\n   By = LoadMatrix(csv_name);\n\n}\nvoid   LSTMLayer::SetAdam(double B1, double B2, double Alph)\n{\n\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}",
    "search_content": "//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\nclass LSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Changing ADAM parameters\n   virtual void   SetAdam(double B1, double B2, double Alph); \n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //Forget gate\n   matrix Wf,Bf,Zf[],\n          dWf,dBf;\n   //Input gate\n   matrix Wi,Bi,Zi[],\n          dWi,dBi;\n   //Output gate\n   matrix Wo,Bo,Zo[],\n          dWo,dBo;\n   //Candidate gate\n   matrix Wg,Bg,Zg[],\n          dWg,dBg;\n   //output\n   matrix Wy,By,Zy[],\n          dWy,dBy;\n   //Hidden state\n   matrix H[];\n   //Long term memory\n   matrix C[];\n   //Input\n   matrix x[],x_h[];\n  \n   //ADAM \n   //===============\n   //Iteration counter\n   ulong it; \n   //m\n   matrix mWy, mWf, mWo, mWi, mWg;\n   matrix mBy, mBf, mBo, mBi, mBg;\n   //v\n   matrix vWy, vWf, vWo, vWi, vWg;\n   matrix vBy, vBf, vBo, vBi, vBg;\n   \n   //hiperparameters \n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\n\nvoid LSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//forget gate\nWf.Init(N_H,N_H + N_ins);\ndWf.Init(N_H,N_H + N_ins);\nWf = InitWeights(Wf)*xavier_;\n\nBf.Init(N_H,1);\ndBf.Init(N_H,1);\nBf = InitWeights(Bf)*xavier_;\n\nArrayResize(Zf,N_ts);\n     \n//input gate\nWi.Init(N_H,N_H + N_ins);\ndWi.Init(N_H,N_H + N_ins);\nWi = InitWeights(Wi)*xavier_;\n\nBi.Init(N_H,1);\ndBi.Init(N_H,1);\nBi = InitWeights(Bi)*xavier_;\n\nArrayResize(Zi,N_ts);\n//output gate\nWo.Init(N_H,N_H + N_ins);\ndWo.Init(N_H,N_H + N_ins);\nWo = InitWeights(Wo)*xavier_;\n\nBo.Init(N_H,1);\ndBo.Init(N_H,1);\nBo = InitWeights(Bo)*xavier_;\n\nArrayResize(Zo,N_ts);     \n// candidate gate\nWg.Init(N_H,N_H + N_ins);\ndWg.Init(N_H,N_H + N_ins);\nWg = InitWeights(Wg)*xavier_;\n\nBg.Init(N_H,1);\ndBg.Init(N_H,1);\nBg = InitWeights(Bg)*xavier_;\n\nArrayResize(Zg,N_ts);\n//Output\nWy.Init(N_outs,N_H);\ndWy.Init(N_outs,N_H);\nWy = InitWeights(Wy)*xavier_;\n\n\nBy.Init(N_outs,1);\ndBy.Init(N_outs,1);\nBy = InitWeights(By)*xavier_;\n\nArrayResize(Zy,N_ts);\n\n//Estado Oculto\nArrayResize(H,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(C,N_ts+1);\n\n//Entrada \nArrayResize(x,N_ts);\nArrayResize(x_h,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWy.Init(Wy.Rows(),Wy.Cols());\n      vWy.Init(Wy.Rows(),Wy.Cols());  \n      mWy = ZeroMatrix(mWy);\n      vWy = ZeroMatrix(vWy);\n      \n      mBy.Init(By.Rows(),By.Cols());\n      vBy.Init(By.Rows(),By.Cols());\n      mBy= ZeroMatrix(mBy);\n      vBy = ZeroMatrix(vBy);\n      \n      //Forget gate\n      mWf.Init(Wf.Rows(),Wf.Cols());\n      vWf.Init(Wf.Rows(),Wf.Cols());  \n      mWf = ZeroMatrix(mWf);\n      vWf = ZeroMatrix(vWf);\n      \n      mBf.Init(Bf.Rows(),Bf.Cols());\n      vBf.Init(Bf.Rows(),Bf.Cols());\n      mBf = ZeroMatrix(mBf);\n      vBf = ZeroMatrix(vBf);\n      \n      //Output Gate\n      mWo.Init(Wo.Rows(),Wo.Cols());\n      vWo.Init(Wo.Rows(),Wo.Cols());  \n      mWo = ZeroMatrix(mWo);\n      vWo = ZeroMatrix(vWo);\n      \n      mBo.Init(Bo.Rows(),Bo.Cols());\n      vBo.Init(Bo.Rows(),Bo.Cols());\n      mBo = ZeroMatrix(mBo);\n      vBo = ZeroMatrix(vBo);\n      \n      //Input Gate\n      mWi.Init(Wi.Rows(),Wi.Cols());\n      vWi.Init(Wi.Rows(),Wi.Cols());  \n      mWi = ZeroMatrix(mWi);\n      vWi = ZeroMatrix(vWi);\n      \n      mBi.Init(Bi.Rows(),Bi.Cols());\n      vBi.Init(Bi.Rows(),Bi.Cols());\n      mBi = ZeroMatrix(mBi);\n      vBi = ZeroMatrix(vBi);\n      \n      //Candidate Gate\n      mWg.Init(Wg.Rows(),Wg.Cols());\n      vWg.Init(Wg.Rows(),Wg.Cols());  \n      mWg = ZeroMatrix(mWg);\n      vWg = ZeroMatrix(vWg);\n      \n      mBg.Init(Bg.Rows(),Bg.Cols());\n      vBg.Init(Bg.Rows(),Bg.Cols());\n      mBg = ZeroMatrix(mBg);"
  },
  {
    "filename": "DropoutLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Dropout Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass DropoutLayer : public DeepLearning\n  {\npublic:\n\n   //Initializes the layer weights and bias from the number of neurons\n   void InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index of the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   //Set a different value for the DropOut rate\n   virtual void   SetDrop(double Drop);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \nprivate:\n   //weight sof the layer\n   matrix W;\n   //Gradients of the weights \n   matrix dW;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input vector\n   matrix Xe;\n   //Learning rate\n   double N;\n   //dropout rate\n   double drop;\n   //Dropout matrix\n   matrix D;\n   //Optimization method\n   Optim OP;\n   \n      //ADAM \n   //===============\n   //Iterations counter\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   DropoutLayer                                                               |\n//+------------------------------------------------------------------+\nvoid DropoutLayer::InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n\n   drop = Drop;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n}\nmatrix DropoutLayer::Output(matrix &X)\n{\n\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\n\n//Constru\u00e7\u00e3o da matriz de Dropout\nmatrix Dp;\nDp.Init(Y.Rows(),Y.Cols());\nfor(int i=0;i<Dp.Rows();i++)\n  {for(int j=0;j<Dp.Cols();j++)\n     {if(rand()/32780.0 < drop)  Dp[i][j] = 1;\n      else Dp[i][j] = 0; }}\nD = Dp;\n\nY = Y * Dp;\nreturn Y;\n}\nmatrix DropoutLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex;\n   Ey = Ey * D;\n   Ex = W.Transpose().MatMul(Ey);\n\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   \n   return Ex;\n}\nvoid DropoutLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   \n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid DropoutLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid DropoutLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n}\nvoid DropoutLayer::SetDrop(double Drop)\n{\ndrop = Drop;\n}\nvoid DropoutLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}",
    "search_content": "//+------------------------------------------------------------------+\n//|   Dropout Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass DropoutLayer : public DeepLearning\n  {\npublic:\n\n   //Initializes the layer weights and bias from the number of neurons\n   void InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index of the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   //Set a different value for the DropOut rate\n   virtual void   SetDrop(double Drop);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \nprivate:\n   //weight sof the layer\n   matrix W;\n   //Gradients of the weights \n   matrix dW;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input vector\n   matrix Xe;\n   //Learning rate\n   double N;\n   //dropout rate\n   double drop;\n   //Dropout matrix\n   matrix D;\n   //Optimization method\n   Optim OP;\n   \n      //ADAM \n   //===============\n   //Iterations counter\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   DropoutLayer                                                               |\n//+------------------------------------------------------------------+\nvoid DropoutLayer::InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n\n   drop = Drop;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n}\nmatrix DropoutLayer::Output(matrix &X)\n{\n\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\n\n//Constru\u00e7\u00e3o da matriz de Dropout\nmatrix Dp;\nDp.Init(Y.Rows(),Y.Cols());\nfor(int i=0;i<Dp.Rows();i++)\n  {for(int j=0;j<Dp.Cols();j++)\n     {if(rand()/32780.0 < drop)  Dp[i][j] = 1;\n      else Dp[i][j] = 0; }}\nD = Dp;\n\nY = Y * Dp;\nreturn Y;\n}\nmatrix DropoutLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex;\n   Ey = Ey * D;\n   Ex = W.Transpose().MatMul(Ey);\n\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   \n   return Ex;\n}\nvoid DropoutLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   \n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid DropoutLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid DropoutLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n}\nvoid DropoutLayer::SetDrop(double Drop)\n{\ndrop = Drop;\n}\nvoid DropoutLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}"
  },
  {
    "filename": "BiLSTMLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   BiLSTM Layer                                                   |\n//+------------------------------------------------------------------+\n\nclass BiLSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the error\n   virtual void   Update(void);\n   //Save weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   \n   //ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //From Past to Future:\n   //Forget gate\n   matrix Wfp,Bfp,Zfp[],\n          dWfp,dBfp;\n   //Input gate\n   matrix Wip,Bip,Zip[],\n          dWip,dBip;\n   //Output gate\n   matrix Wop,Bop,Zop[],\n          dWop,dBop;\n   //Candidate gate\n   matrix Wgp,Bgp,Zgp[],\n          dWgp,dBgp;\n   //sa\u00edda\n   matrix Wyp,Byp,Zyp[],\n          dWyp,dByp;\n   //Estado Oculto\n   matrix Hp[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cp[];\n   //Entrada\n   matrix xp[],x_hp[];\n  \n  \n   //From Future to Past\n   //Forget gate\n   matrix Wff,Bff,Zff[],\n          dWff,dBff;\n   //Input gate\n   matrix Wif,Bif,Zif[],\n          dWif,dBif;\n   //Output gate\n   matrix Wof,Bof,Zof[],\n          dWof,dBof;\n   //Candidate gate\n   matrix Wgf,Bgf,Zgf[],\n          dWgf,dBgf;\n   //sa\u00edda\n   matrix Wyf,Byf,Zyf[],\n          dWyf,dByf;\n   //Estado Oculto\n   matrix Hf[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cf[];\n   //Entrada\n   matrix xf[],x_hf[];\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mWyp, mWfp, mWop, mWip, mWgp;\n   matrix mByp, mBfp, mBop, mBip, mBgp;\n   //v\n   matrix vWyp, vWfp, vWop, vWip, vWgp;\n   matrix vByp, vBfp, vBop, vBip, vBgp;\n   \n   matrix mWyf, mWff, mWof, mWif, mWgf;\n   matrix mByf, mBff, mBof, mBif, mBgf;\n   //v\n   matrix vWyf, vWff, vWof, vWif, vWgf;\n   matrix vByf, vBff, vBof, vBif, vBgf;\n   \n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   BiLSTM                                                         |\n//+------------------------------------------------------------------+\nvoid BiLSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//From Past to Future\n//=============================\n\n//forget gate\nWfp.Init(N_H,N_H + N_ins);\ndWfp.Init(N_H,N_H + N_ins);\nWfp = InitWeights(Wfp)*xavier_;\n\nBfp.Init(N_H,1);\ndBfp.Init(N_H,1);\nBfp = InitWeights(Bfp)*xavier_;\n\nArrayResize(Zfp,N_ts);\n     \n//input gate\nWip.Init(N_H,N_H + N_ins);\ndWip.Init(N_H,N_H + N_ins);\nWip = InitWeights(Wip)*xavier_;\n\nBip.Init(N_H,1);\ndBip.Init(N_H,1);\nBip = InitWeights(Bip)*xavier_;\n\nArrayResize(Zip,N_ts);\n\n//output gate\nWop.Init(N_H,N_H + N_ins);\ndWop.Init(N_H,N_H + N_ins);\nWop = InitWeights(Wop)*xavier_;\n\nBop.Init(N_H,1);\ndBop.Init(N_H,1);\nBop = InitWeights(Bop)*xavier_;\n\nArrayResize(Zop,N_ts);\n     \n// candidate gate\nWgp.Init(N_H,N_H + N_ins);\ndWgp.Init(N_H,N_H + N_ins);\nWgp = InitWeights(Wgp)*xavier_;\n\nBgp.Init(N_H,1);\ndBgp.Init(N_H,1);\nBgp = InitWeights(Bgp)*xavier_;\n\nArrayResize(Zgp,N_ts);\n\n//Output\nWyp.Init(N_outs,N_H);\ndWyp.Init(N_outs,N_H);\nWyp = InitWeights(Wyp)*xavier_;\n\n\nByp.Init(N_outs,1);\ndByp.Init(N_outs,1);\nByp = InitWeights(Byp)*xavier_;\n\nArrayResize(Zyp,N_ts);\n\n//Estado Oculto\nArrayResize(Hp,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(Cp,N_ts+1);\n\n//Entrada \nArrayResize(xp,N_ts);\nArrayResize(x_hp,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWyp.Init(Wyp.Rows(),Wyp.Cols());\n      vWyp.Init(Wyp.Rows(),Wyp.Cols());  \n      mWyp = ZeroMatrix(mWyp);\n      vWyp = ZeroMatrix(vWyp);\n      \n      mByp.Init(Byp.Rows(),Byp.Cols());\n      vByp.Init(Byp.Rows(),Byp.Cols());\n      mByp= ZeroMatrix(mByp);\n      vByp = ZeroMatrix(vByp);\n      \n      //Forget gate\n      mWfp.Init(Wfp.Rows(),Wfp.Cols());\n      vWfp.Init(Wfp.Rows(),Wfp.Cols());  \n      mWfp = ZeroMatrix(mWfp);\n      vWfp = ZeroMatrix(vWfp);\n      \n      mBfp.Init(Bfp.Rows(),Bfp.Cols());\n      vBfp.Init(Bfp.Rows(),Bfp.Cols());\n      mBfp = ZeroMatrix(mBfp);\n      vBfp = ZeroMatrix(vBfp);\n      \n      //Output Gate\n      mWop.Init(Wop.Rows(),Wop.Cols());\n      vWop.Init(Wop.Rows(),Wop.Cols());  \n      mWop = ZeroMatrix(mWop);\n      vWop = ZeroMatrix(vWop);\n      \n      mBop.Init(Bop.Rows(),Bop.Cols());\n      vBop.Init(Bop.Rows(),Bop.Cols());\n      mBop = ZeroMatrix(mBop);\n      vBop = ZeroMatrix(vBop);\n      \n      //Input Gate\n      mWip.Init(Wip.Rows(),Wip.Cols());\n      vWip.Init(Wip.Rows(),Wip.Cols());  \n      mWip = ZeroMatrix(mWip);\n      vWip = ZeroMatrix(vWip);\n      \n      mBip.Init(Bip.Rows(),Bip.Cols());\n      vBip.Init(Bip.Rows(),Bip.Cols());\n      mBip = ZeroMatrix(mBip);\n      vBip = ZeroMatrix(vBip);\n      \n      //Candidate Gate\n      mWgp.Init(Wgp.Rows(),Wgp.Cols());\n      vWgp.Init(Wgp.Rows(),Wgp.Cols());  \n      mWgp = ZeroMatrix(mWgp);\n      vWgp = ZeroMatrix(vWgp);\n      \n      mBgp.Init(Bgp.Rows(),Bgp.Cols());\n      vBgp.Init(Bgp.Rows(),Bgp.Cols());\n      mBgp = ZeroMatrix(mBgp);\n      vBgp = ZeroMatrix(vBgp);\n     } \n//From future to past\n//forget gate\nWff.Init(N_H,N_H + N_ins);\ndWff.Init(N_H,N_H + N_ins);\nWff = InitWeights(Wff)*xavier_;\n\nBff.Init(N_H,1);\ndBff.Init(N_H,1);\nBff = InitWeights(Bff)*xavier_;\n\nArrayResize(Zff,N_ts);\n     \n//input gate\nWif.Init(N_H,N_H + N_ins);\ndWif.Init(N_H,N_H + N_ins);\nWif = InitWeights(Wif)*xavier_;\n\nBif.Init(N_H,1);\ndBif.Init(N_H,1);\nBif = InitWeights(Bif)*xavier_;\n\nArrayResize(Zif,N_ts);\n//output gate\nWof.Init(N_H,N_H + N_ins);\ndWof.Init(N_H,N_H + N_ins);\nWof = InitWeights(Wof)*xavier_;\n\nBof.Init(N_H,1);\ndBof.Init(N_H,1);\nBof = InitWeights(Bof)*xavier_;\n\nArrayResize(Zof,N_ts);     \n// candidate gate\nWgf.Init(N_H,N_H + N_ins);\ndWgf.Init(N_H,N_H + N_ins);\nWgf = InitWeights(Wgf)*xavier_;\n\nBgf.Init(N_H,1);\ndBgf.Init(N_H,1);\nBgf = InitWeights(Bgf)*xavier_;\n\nArrayResize(Zgf,N_ts);\n//Output\nWyf.Init(N_outs,N_H);\ndWyf.Init(N_outs,N_H);\nWyf = InitWeights(Wyf)*xavier_;\n\n\nByf.Init(N_outs,1);\ndByf.Init(N_outs,1);\nByf = InitWeights(Byf)*xavier_;\n\nArrayResize(Zyf,N_ts);\n\n//Estado Oculto\nArrayResize(Hf,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(Cf,N_ts+1);\n\n//Entrada \nArrayResize(xf,N_ts);\nArrayResize(x_hf,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWyf.Init(Wyf.Rows(),Wyf.Cols());\n      vWyf.Init(Wyf.Rows(),Wyf.Cols());  \n      mWyf = ZeroMatrix(mWyf);\n      vWyf = ZeroMatrix(vWyf);\n      \n      mByf.Init(Byf.Rows(),Byf.Cols());\n      vByf.Init(Byf.Rows(),Byf.Cols());\n      mByf= ZeroMatrix(mByf);\n      vByf = ZeroMatrix(vByf);\n      \n      //Forget gate\n      mWff.Init(Wff.Rows(),Wff.Cols());\n      vWff.Init(Wff.Rows(),Wff.Cols());  \n      mWff = ZeroMatrix(mWff);\n      vWff = ZeroMatrix(vWff);\n      \n      mBff.Init(Bff.Rows(),Bff.Cols());\n      vBff.Init(Bff.Rows(),Bff.Cols());\n      mBff = ZeroMatrix(mBff);\n      vBff = ZeroMatrix(vBff);\n      \n      //Output Gate\n      mWof.Init(Wof.Rows(),Wof.Cols());\n      vWof.Init(Wof.Rows(),Wof.Cols());  \n      mWof = ZeroMatrix(mWof);\n      vWof = ZeroMatrix(vWof);\n      \n      mBof.Init(Bof.Rows(),Bof.Cols());\n      vBof.Init(Bof.Rows(),Bof.Cols());\n      mBof = ZeroMatrix(mBof);\n      vBof = ZeroMatrix(vBof);\n      \n      //Input Gate\n      mWif.Init(Wif.Rows(),Wif.Cols());\n      vWif.Init(Wif.Rows(),Wif.Cols());  \n      mWif = ZeroMatrix(mWif);\n      vWif = ZeroMatrix(vWif);\n      \n      mBif.Init(Bif.Rows(),Bif.Cols());\n      vBif.Init(Bif.Rows(),Bif.Cols());\n      mBif = ZeroMatrix(mBif);\n      vBif = ZeroMatrix(vBif);\n      \n      //Candidate Gate\n      mWgf.Init(Wgf.Rows(),Wgf.Cols());\n      vWgf.Init(Wgf.Rows(),Wgf.Cols());  \n      mWgf = ZeroMatrix(mWgf);\n      vWgf = ZeroMatrix(vWgf);\n      \n      mBgf.Init(Bgf.Rows(),Bgf.Cols());\n      vBgf.Init(Bgf.Rows(),Bgf.Cols());\n      mBgf = ZeroMatrix(mBgf);\n      vBgf = ZeroMatrix(vBgf);\n     } \n}\n\n\nmatrix BiLSTMLayer::Output(matrix &X)\n{\n//Zera o estado oculto anterior\n\nHp[0].Init(N_H,1);\nHp[0] = ZeroMatrix(Hp[0]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nCp[0].Init(N_H,1);\nCp[0] = ZeroMatrix(Cp[0]);\n\n     \n//Define a matrix de sa\u00edda \nmatrix Yp; \nYp.Init(N_outs,N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix yp;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {xp[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix Fp,Ip,Op,Gp; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {xp[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_hp[t] = Concatenate(Hp[t],xp[t]); \n\n\n   //Forget gate\n   Zfp[t] = Wfp.MatMul(x_hp[t])  + Bfp;\n   Fp = Sig(Zfp[t]);\n   //Imput gate\n   Zip[t] = Wip.MatMul(x_hp[t])  + Bip;\n   Ip = Sig(Zip[t]);\n   //Output gate\n   Zop[t] = Wop.MatMul(x_hp[t])  + Bop;\n   Op = Sig(Zop[t]);\n   //Candidate gate\n   Zgp[t] = Wgp.MatMul(x_hp[t])  + Bgp;\n   Gp = Tanh(Zgp[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   Cp[t+1] = Fp * Cp[t] + Ip * Gp;\n   //C\u00e1lculo do novo estado oculto\n   Hp[t+1] = Tanh(Cp[t+1]);\n   Hp[t+1]= Hp[t+1] * Op;\n   \n   //Sa\u00edda\n   yp = Wyp.MatMul(Hp[t+1]) + Byp;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<yp.Rows();i++)\n     {Yp[i][t] = yp[i][0];}\n    \n  }\n\n//Zera o estado oculto posterior\n\nHf[N_ts].Init(N_H,1);\nHf[N_ts] = ZeroMatrix(Hf[N_ts]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nCf[N_ts].Init(N_H,1);\nCf[N_ts] = ZeroMatrix(Cf[N_ts]);\n  \n//Define a matrix de sa\u00edda \nmatrix Yf; \nYf.Init(N_outs, N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix yf;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {xf[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix Ff,If,Of,Gf; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {xf[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_hf[t] = Concatenate(Hf[t+1],xf[t]); \n\n\n   //Forget gate\n   Zff[t] = Wff.MatMul(x_hf[t])  + Bff;\n   Ff = Sig(Zff[t]);\n   //Imput gate\n   Zif[t] = Wif.MatMul(x_hf[t])  + Bif;\n   If = Sig(Zif[t]);\n   //Output gate\n   Zof[t] = Wof.MatMul(x_hf[t])  + Bof;\n   Of = Sig(Zof[t]);\n   //Candidate gate\n   Zgf[t] = Wgf.MatMul(x_hf[t])  + Bgf;\n   Gf = Tanh(Zgf[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   Cf[t] = Ff * Cf[t+1] + If * Gf;\n   //C\u00e1lculo do novo estado oculto\n   Hf[t] = Tanh(Cf[t]);\n   Hf[t] = Hf[t] * Of;\n   \n   //Sa\u00edda\n   yf = Wyf.MatMul(Hf[t]) + Byf;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<yf.Rows();i++)\n     {Yf[i][t] = yf[i][0];}\n    \n  }\nmatrix Y;\nY = Yp + Yf;\n\nreturn Y;\n}\n\nmatrix BiLSTMLayer::GradDescent(matrix &Ey)\n{\n//Gradient \nmatrix Exp;\nExp.Init(N_ins,N_ts);\n \n//Forget Gate\ndWfp = ZeroMatrix(dWfp);\ndBfp = ZeroMatrix(dBfp);\n\n//Input Gate\ndWip = ZeroMatrix(dWip);\ndBip = ZeroMatrix(dBip);\n\n//Output Gate\ndWop = ZeroMatrix(dWop);\ndBop = ZeroMatrix(dBop);\n\n//Candidate Gate\ndWgp = ZeroMatrix(dWgp);\ndBgp = ZeroMatrix(dBgp);\n\n//Y gate\ndWyp = ZeroMatrix(dWyp);\ndByp = ZeroMatrix(dByp);\n//Erro por passo de tempo \nmatrix eyp;\neyp.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_hp, d_cp, d_fp, d_ip, d_op, d_gp, d_x_hp;\n\n//Estado oculto para t+1\nmatrix dh_nextp;\ndh_nextp.Init(N_H,1);\ndh_nextp = ZeroMatrix(dh_nextp);\n\nmatrix dc_nextp;\ndc_nextp.Init(N_H,1);\ndc_nextp = ZeroMatrix(dc_nextp);\n\nmatrix ex_p;\nex_p.Init(N_ins,1);\n\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {eyp[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWyp += eyp.MatMul(Hp[t+1].Transpose());\n   dByp += eyp;\n   \n   //Hidden State Error\n   d_hp = Wyp.Transpose();\n   d_hp = d_hp.MatMul(eyp) + dh_nextp;\n   \n   //Output gate\n   d_op = d_hp * Tanh(Cp[t+1]) * dSig(Zop[t]);\n   dWop += d_op.MatMul(x_hp[t].Transpose());\n   dBop += d_op;\n   \n   //Cell state error\n   d_cp = d_hp * dTanh(Cp[t+1]) * Sig(Zop[t]) + dc_nextp;\n   \n   //Forget gate\n   d_fp = d_cp * Cp[t] * dSig(Zfp[t]);\n   dWfp += d_fp.MatMul(x_hp[t].Transpose());\n   dBfp += d_fp;\n   \n   //Input gate\n   d_ip = d_cp * Tanh(Zgp[t]) * dSig(Zip[t]);\n   dWip += d_ip.MatMul(x_hp[t].Transpose());\n   dBip += d_ip;\n   \n   //Candidate gate\n   d_gp = d_cp * Sig(Zip[t]) * dTanh(Zgp[t]);\n   dWgp += d_gp.MatMul(x_hp[t].Transpose());\n   dBgp += d_gp;\n   \n   //Concatenated Input gradient\n   d_x_hp = Wfp.Transpose().MatMul(d_fp) + Wip.Transpose().MatMul(d_ip) + Wop.Transpose().MatMul(d_op) + Wgp.Transpose().MatMul(d_gp);\n   \n   //Error of Cell state of next time step\n   dc_nextp = Sig(Zfp[t]) * d_cp; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_hp.Rows();i++)\n     {if(i < N_H) dh_nextp[i][0] = d_x_hp[i][0];\n      if(i >= N_H) ex_p[i-N_H][0] = d_x_hp[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex_p.Rows();i++)\n     {Exp[i][t] = ex_p[i][0];}   \n  \n  }\n\n//Gradient \nmatrix Exf;\nExf.Init(N_ins,N_ts);\n \n//Forget Gate\ndWff = ZeroMatrix(dWff);\ndBff = ZeroMatrix(dBff);\n\n//Input Gate\ndWif = ZeroMatrix(dWif);\ndBif = ZeroMatrix(dBif);\n\n//Output Gate\ndWof = ZeroMatrix(dWof);\ndBof = ZeroMatrix(dBof);\n\n//Candidate Gate\ndWgf = ZeroMatrix(dWgf);\ndBgf = ZeroMatrix(dBgf);\n\n//Y gate\ndWyf = ZeroMatrix(dWyf);\ndByf = ZeroMatrix(dByf);\n//Erro por passo de tempo \nmatrix eyf;\neyf.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_hf, d_cf, d_ff, d_if, d_of, d_gf,d_x_hf;\n\n//Estado oculto para t+1\nmatrix dh_nextf;\ndh_nextf.Init(N_H,1);\ndh_nextf = ZeroMatrix(dh_nextf);\n\nmatrix dc_nextf;\ndc_nextf.Init(N_H,1);\ndc_nextf = ZeroMatrix(dc_nextf);\n\nmatrix ex_f;\nex_f.Init(N_ins,1);\n\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {eyf[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWyf += eyf.MatMul(Hf[t].Transpose());\n   dByf += eyf;\n   \n   //Hidden State Error\n   d_hf = Wyf.Transpose();\n   d_hf = d_hf.MatMul(eyf) + dh_nextf;\n   \n   //Output gate\n   d_of = d_hf * Tanh(Cf[t]) * dSig(Zof[t]);\n   dWof += d_of.MatMul(x_hf[t].Transpose());\n   dBof += d_of;\n   \n   //Cell state error\n   d_cf = d_hf * dTanh(Cf[t]) * Sig(Zof[t]) + dc_nextf;\n   \n   //Forget gate\n   d_ff = d_cf * Cf[t+1] * dSig(Zff[t]);\n   dWff += d_ff.MatMul(x_hf[t].Transpose());\n   dBff += d_ff;\n   \n   //Input gate\n   d_if = d_cf * Tanh(Zgf[t]) * dSig(Zif[t]);\n   dWif += d_if.MatMul(x_hf[t].Transpose());\n   dBif += d_if;\n   \n   //Candidate gate\n   d_gf = d_cf * Sig(Zif[t]) * dTanh(Zgf[t]);\n   dWgf += d_gf.MatMul(x_hf[t].Transpose());\n   dBgf += d_gf;\n   \n   //Concatenated Input gradient\n   d_x_hf = Wff.Transpose().MatMul(d_ff) + Wif.Transpose().MatMul(d_if) + Wof.Transpose().MatMul(d_of) + Wgf.Transpose().MatMul(d_gf);\n   \n   //Error of Cell state of next time step\n   dc_nextf = Sig(Zff[t]) * d_cf; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_hf.Rows();i++)\n     {if(i < N_H) dh_nextf[i][0] = d_x_hf[i][0];\n      if(i >= N_H) ex_f[i-N_H][0] = d_x_hf[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex_f.Rows();i++)\n     {Exf[i][t] = ex_f[i][0];}   \n  \n  }\nmatrix Ex;\n\nEx = Exp + Exf; \nreturn Ex;\n}\n\nvoid   BiLSTMLayer::Update(void)\n{\nif(OP == STD)\n  {\n   //Past \n   Wfp = Wfp - dWfp*N;\n   Wip = Wip - dWip*N;\n   Wop = Wop - dWop*N;\n   Wgp = Wgp - dWgp*N;\n   Wyp = Wyp - dWyp*N;\n   \n   Bfp = Bfp - dBfp*N;\n   Bip = Bip - dBip*N;\n   Bop = Bop - dBop*N;\n   Bgp = Bgp - dBgp*N;\n   Byp = Byp - dByp*N;\n   \n   //Future\n   Wff = Wff - dWff*N;\n   Wif = Wif - dWif*N;\n   Wof = Wof - dWof*N;\n   Wgf = Wgf - dWgf*N;\n   Wyf = Wyf - dWyf*N;\n   \n   Bff = Bff - dBff*N;\n   Bif = Bif - dBif*N;\n   Bof = Bof - dBof*N;\n   Bgf = Bgf - dBgf*N;\n   Byf = Byf - dByf*N;\n  }\nif(OP == ADAM)\n  {\n      it +=1;\n      //sa\u00edda\n      mWyp = AdamM(mWyp,dWyp,beta1);\n      vWyp = AdamV(vWyp,dWyp,beta2);\n      Wyp = Wyp - Adam(it,mWyp,vWyp,beta1,beta2,alpha);\n      \n      mByp = AdamM(mByp,dByp,beta1);\n      vByp = AdamV(vByp,dByp,beta2);\n      Byp = Byp -Adam(it,mByp,vByp,beta1,beta2,alpha);\n      \n      //Forget\n      mWfp = AdamM(mWfp,dWfp,beta1);\n      vWfp = AdamV(vWfp,dWfp,beta2);\n      Wfp = Wfp - Adam(it,mWfp,vWfp,beta1,beta2,alpha);\n      \n      mBfp = AdamM(mBfp,dBfp,beta1);\n      vBfp = AdamV(vBfp,dBfp,beta2);\n      Bfp = Bfp -Adam(it,mBfp,vBfp,beta1,beta2,alpha);\n      \n      //Output\n      mWop = AdamM(mWop,dWop,beta1);\n      vWop = AdamV(vWop,dWop,beta2);\n      Wop = Wop - Adam(it,mWop,vWop,beta1,beta2,alpha);\n      \n      mBop = AdamM(mBop,dBop,beta1);\n      vBop = AdamV(vBop,dBop,beta2);\n      Bop = Bop -Adam(it,mBop,vBop,beta1,beta2,alpha);\n      \n      //Input\n      mWip = AdamM(mWip,dWip,beta1);\n      vWip = AdamV(vWip,dWip,beta2);\n      Wip = Wip- Adam(it,mWip,vWip,beta1,beta2,alpha);\n      \n      mBip = AdamM(mBip,dBip,beta1);\n      vBip = AdamV(vBip,dBip,beta2);\n      Bip = Bip -Adam(it,mBip,vBip,beta1,beta2,alpha);\n      \n      //Candidate\n      mWgp = AdamM(mWgp,dWgp,beta1);\n      vWgp = AdamV(vWgp,dWgp,beta2);\n      Wgp = Wgp - Adam(it,mWgp,vWgp,beta1,beta2,alpha);\n      \n      mBgp = AdamM(mBgp,dBgp,beta1);\n      vBgp = AdamV(vBgp,dBgp,beta2);\n      Bgp = Bgp -Adam(it,mBgp,vBgp,beta1,beta2,alpha);\n\n      //sa\u00edda\n      mWyf = AdamM(mWyf,dWyf,beta1);\n      vWyf = AdamV(vWyf,dWyf,beta2);\n      Wyf = Wyf - Adam(it,mWyf,vWyf,beta1,beta2,alpha);\n      \n      mByf = AdamM(mByf,dByf,beta1);\n      vByf = AdamV(vByf,dByf,beta2);\n      Byf = Byf -Adam(it,mByf,vByf,beta1,beta2,alpha);\n      \n      //Forget\n      mWff = AdamM(mWff,dWff,beta1);\n      vWff = AdamV(vWff,dWff,beta2);\n      Wff = Wff - Adam(it,mWff,vWff,beta1,beta2,alpha);\n      \n      mBff = AdamM(mBff,dBff,beta1);\n      vBff = AdamV(vBff,dBff,beta2);\n      Bff = Bff -Adam(it,mBff,vBff,beta1,beta2,alpha);\n      \n      //Output\n      mWof = AdamM(mWof,dWof,beta1);\n      vWof = AdamV(vWof,dWof,beta2);\n      Wof = Wof - Adam(it,mWof,vWof,beta1,beta2,alpha);\n      \n      mBof = AdamM(mBof,dBof,beta1);\n      vBof = AdamV(vBof,dBof,beta2);\n      Bof = Bof -Adam(it,mBof,vBof,beta1,beta2,alpha);\n      \n      //Input\n      mWif = AdamM(mWif,dWif,beta1);\n      vWif = AdamV(vWif,dWif,beta2);\n      Wif = Wif- Adam(it,mWif,vWif,beta1,beta2,alpha);\n      \n      mBif = AdamM(mBif,dBif,beta1);\n      vBif = AdamV(vBif,dBif,beta2);\n      Bif = Bif -Adam(it,mBif,vBif,beta1,beta2,alpha);\n      \n      //Candidate\n      mWgf = AdamM(mWgf,dWgf,beta1);\n      vWgf = AdamV(vWgf,dWgf,beta2);\n      Wgf = Wgf - Adam(it,mWgf,vWgf,beta1,beta2,alpha);\n      \n      mBgf = AdamM(mBgf,dBgf,beta1);\n      vBgf = AdamV(vBgf,dBgf,beta2);\n      Bgf = Bgf -Adam(it,mBgf,vBgf,beta1,beta2,alpha);\n  }\n}\n\nvoid   BiLSTMLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfpLayer\" + IntegerToString(k);\n   SaveMatrix(Wfp,csv_name);\n   csv_name = IAname + \"\\WipLayer\" + IntegerToString(k);\n   SaveMatrix(Wip,csv_name);\n   csv_name = IAname + \"\\WopLayer\" + IntegerToString(k);\n   SaveMatrix(Wop,csv_name);\n   csv_name = IAname + \"\\WgpLayer\" + IntegerToString(k);\n   SaveMatrix(Wgp,csv_name);\n   csv_name = IAname + \"\\WypLayer\" + IntegerToString(k);\n   SaveMatrix(Wyp,csv_name);\n   \n   csv_name = IAname + \"\\BfpLayer\" + IntegerToString(k);\n   SaveMatrix(Bfp,csv_name);\n   csv_name = IAname + \"\\BipLayer\" + IntegerToString(k);\n   SaveMatrix(Bip,csv_name);\n   csv_name = IAname + \"\\BopLayer\" + IntegerToString(k);\n   SaveMatrix(Bop,csv_name);\n   csv_name = IAname + \"\\BgpLayer\" + IntegerToString(k);\n   SaveMatrix(Bgp,csv_name);\n   csv_name = IAname + \"\\BypLayer\" + IntegerToString(k);\n   SaveMatrix(Byp,csv_name);\n   \n   csv_name = IAname + \"\\WffLayer\" + IntegerToString(k);\n   SaveMatrix(Wff,csv_name);\n   csv_name = IAname + \"\\WifLayer\" + IntegerToString(k);\n   SaveMatrix(Wif,csv_name);\n   csv_name = IAname + \"\\WofLayer\" + IntegerToString(k);\n   SaveMatrix(Wof,csv_name);\n   csv_name = IAname + \"\\WgfLayer\" + IntegerToString(k);\n   SaveMatrix(Wgf,csv_name);\n   csv_name = IAname + \"\\WyfLayer\" + IntegerToString(k);\n   SaveMatrix(Wyf,csv_name);\n   \n   csv_name = IAname + \"\\BffLayer\" + IntegerToString(k);\n   SaveMatrix(Bff,csv_name);\n   csv_name = IAname + \"\\BifLayer\" + IntegerToString(k);\n   SaveMatrix(Bif,csv_name);\n   csv_name = IAname + \"\\BofLayer\" + IntegerToString(k);\n   SaveMatrix(Bof,csv_name);\n   csv_name = IAname + \"\\BgfLayer\" + IntegerToString(k);\n   SaveMatrix(Bgf,csv_name);\n   csv_name = IAname + \"\\ByfLayer\" + IntegerToString(k);\n   SaveMatrix(Byf,csv_name);\n}\nvoid   BiLSTMLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfpLayer\" + IntegerToString(k);\n   Wfp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WipLayer\" + IntegerToString(k);\n   Wip = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WopLayer\" + IntegerToString(k);\n   Wop = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgpLayer\" + IntegerToString(k);\n   Wgp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WypLayer\" + IntegerToString(k);\n   Wyp = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BfpLayer\" + IntegerToString(k);\n   Bfp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BipLayer\" + IntegerToString(k);\n   Bip = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BopLayer\" + IntegerToString(k);\n   Bop = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgpLayer\" + IntegerToString(k);\n   Bgp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BypLayer\" + IntegerToString(k);\n   Byp = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\WffLayer\" + IntegerToString(k);\n   Wff = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WifLayer\" + IntegerToString(k);\n   Wif = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WofLayer\" + IntegerToString(k);\n   Wof = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgfLayer\" + IntegerToString(k);\n   Wgf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WyfLayer\" + IntegerToString(k);\n   Wyf = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BffLayer\" + IntegerToString(k);\n   Bff = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BifLayer\" + IntegerToString(k);\n   Bif = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BofLayer\" + IntegerToString(k);\n   Bof = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgfLayer\" + IntegerToString(k);\n   Bgf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\ByfLayer\" + IntegerToString(k);\n   Byf = LoadMatrix(csv_name);\n\n}\nvoid   BiLSTMLayer::SetAdam(double B1, double B2, double Alph)\n{\n\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|   BiLSTM Layer                                                   |\n//+------------------------------------------------------------------+\n\nclass BiLSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the error\n   virtual void   Update(void);\n   //Save weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   \n   //ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //From Past to Future:\n   //Forget gate\n   matrix Wfp,Bfp,Zfp[],\n          dWfp,dBfp;\n   //Input gate\n   matrix Wip,Bip,Zip[],\n          dWip,dBip;\n   //Output gate\n   matrix Wop,Bop,Zop[],\n          dWop,dBop;\n   //Candidate gate\n   matrix Wgp,Bgp,Zgp[],\n          dWgp,dBgp;\n   //sa\u00edda\n   matrix Wyp,Byp,Zyp[],\n          dWyp,dByp;\n   //Estado Oculto\n   matrix Hp[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cp[];\n   //Entrada\n   matrix xp[],x_hp[];\n  \n  \n   //From Future to Past\n   //Forget gate\n   matrix Wff,Bff,Zff[],\n          dWff,dBff;\n   //Input gate\n   matrix Wif,Bif,Zif[],\n          dWif,dBif;\n   //Output gate\n   matrix Wof,Bof,Zof[],\n          dWof,dBof;\n   //Candidate gate\n   matrix Wgf,Bgf,Zgf[],\n          dWgf,dBgf;\n   //sa\u00edda\n   matrix Wyf,Byf,Zyf[],\n          dWyf,dByf;\n   //Estado Oculto\n   matrix Hf[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cf[];\n   //Entrada\n   matrix xf[],x_hf[];\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mWyp, mWfp, mWop, mWip, mWgp;\n   matrix mByp, mBfp, mBop, mBip, mBgp;\n   //v\n   matrix vWyp, vWfp, vWop, vWip, vWgp;\n   matrix vByp, vBfp, vBop, vBip, vBgp;\n   \n   matrix mWyf, mWff, mWof, mWif, mWgf;\n   matrix mByf, mBff, mBof, mBif, mBgf;\n   //v\n   matrix vWyf, vWff, vWof, vWif, vWgf;\n   matrix vByf, vBff, vBof, vBif, vBgf;\n   \n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   BiLSTM                                                         |\n//+------------------------------------------------------------------+\nvoid BiLSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//From Past to Future\n//=============================\n\n//forget gate\nWfp.Init(N_H,N_H + N_ins);\ndWfp.Init(N_H,N_H + N_ins);\nWfp = InitWeights(Wfp)*xavier_;\n\nBfp.Init(N_H,1);\ndBfp.Init(N_H,1);\nBfp = InitWeights(Bfp)*xavier_;\n\nArrayResize(Zfp,N_ts);\n     \n//input gate\nWip.Init(N_H,N_H + N_ins);\ndWip.Init(N_H,N_H + N_ins);\nWip = InitWeights(Wip)*xavier_;\n\nBip.Init(N_H,1);\ndBip.Init(N_H,1);\nBip = InitWeights(Bip)*xavier_;\n\nArrayResize(Zip,N_ts);\n\n//output gate\nWop.Init(N_H,N_H + N_ins);\ndWop.Init(N_H,N_H + N_ins);\nWop = InitWeights(Wop)*xavier_;\n\nBop.Init(N_H,1);\ndBop.Init(N_H,1);\nBop = InitWeights(Bop)*xavier_;\n\nArrayResize(Zop,N_ts);\n     \n// candidate gate\nWgp.Init(N_H,N_H + N_ins);\ndWgp.Init(N_H,N_H + N_ins);\nWgp = InitWeights(Wgp)*xavier_;\n\nBgp.Init(N_H,1);\ndBgp.Init(N_H,1);\nBgp = InitWeights(Bgp)*xavier_;\n\nArrayResize(Zgp,N_ts);\n\n//Output\nWyp.Init(N_outs,N_H);\ndWyp.Init(N_outs,N_H);\nWyp = InitWeights(Wyp)*xavier_;\n\n\nByp.Init(N_outs,1);\ndByp.Init(N_outs,1);\nByp = InitWeights(Byp)*xavier_;\n\nArrayResize(Zyp,N_ts);\n\n//Estado Oculto\nArrayResize(Hp,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(Cp,N_ts+1);\n\n//Entrada \nArrayResize(xp,N_ts);\nArrayResize(x_hp,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWyp.Init(Wyp.Rows(),Wyp.Cols());\n      vWyp.Init(Wyp.Rows(),Wyp.Cols());  \n      mWyp = ZeroMatrix(mWyp);\n      vWyp = ZeroMatrix(vWyp);\n      \n      mByp.Init(Byp.Rows(),Byp.Cols());\n      vByp.Init(Byp.Rows(),Byp.Cols());\n      mByp= ZeroMatrix(mByp);\n      vByp = ZeroMatrix(vByp);\n      \n      //Forget gate\n      mWfp.Init(Wfp.Rows(),Wfp.Cols());\n      vWfp.Init(Wfp.Rows(),Wfp.Cols());  \n      mWfp = ZeroMatrix(mWfp);\n      vWfp = ZeroMatrix(vWfp);\n      \n      mBfp.Init(Bfp.Rows(),Bfp.Cols());\n      vBfp.Init(Bfp.Rows(),Bfp.Cols());\n      mBfp = ZeroMatrix(mBfp);\n      vBfp = ZeroMatrix(vBfp);\n      \n      //Output Gate\n "
  },
  {
    "filename": "Metrics.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Metrics                                                        |\n//+------------------------------------------------------------------+\n\nclass Metrics : public DeepLearning\n  {\npublic:\n  //Used for multiclass problems, transforms the output matrix \n  //from the softmax layer into an output of zeros and ones where 1 \n  // is the most likely class\n   matrix ArgMax(matrix &X);\n   \n   //Accuracy = Total number of hits over the total number of samples\n   double Accuracy(matrix &R, matrix &Out);\n   \n   //Mean absolute percentage error \n   double MAPE(matrix &R, matrix &Y);\n  };\n\n//+------------------------------------------------------------------+\n//|    Metrics                                                       |\n//+------------------------------------------------------------------+\nmatrix Metrics::ArgMax(matrix &X)\n{\nvector V;\nV.Init(X.Cols());\n\nulong count;\nmatrix M;\nM.Init(X.Rows(),X.Cols());\nfor(int i=0;i<X.Rows();i++)\n   {for(int j=0;j<X.Cols();j++)\n      {V[j] = X[i][j];}\n   count = V.ArgMax();\n   \n   for(int j=0;j<X.Cols();j++)\n     {if(j == count) M[i][j] = 1;\n      if(j != count) M[i][j] = 0;}\n    }\nreturn M; \n}\n\ndouble Metrics::Accuracy(matrix &R, matrix &Out)\n{\nmatrix Y;\nvector v1, v2;\nv1.Init(R.Cols());\n\nY = ArgMax(Out);\nv2.Init(Y.Cols());\n\nulong count1, count2;\ndouble N_samples, N_hits, Accur;\nN_samples = R.Rows();\nN_hits = 0;\n\nfor(int i=0;i<R.Rows();i++)\n  {for(int j=0;j<R.Cols();j++)\n     {v1[j] = R[i][j];\n      v2[j] = Y[i][j];}\n   count1 = v1.ArgMax();\n   count2 = v2.ArgMax();\n   if(count1 == count2) N_hits = N_hits + 1.0;\n   \n  }\n  \nAccur = N_hits/N_samples;\nreturn Accur;\n}\n\ndouble Metrics::MAPE(matrix &R, matrix &Y)\n{\nmatrix Err;\nErr = R - Y; \nErr = Err / R; \nErr = MathAbs(Err);\n\ndouble error; \nerror = Err.Mean();\n\nreturn error; \n}",
    "search_content": "//+------------------------------------------------------------------+\n//|   Metrics                                                        |\n//+------------------------------------------------------------------+\n\nclass Metrics : public DeepLearning\n  {\npublic:\n  //Used for multiclass problems, transforms the output matrix \n  //from the softmax layer into an output of zeros and ones where 1 \n  // is the most likely class\n   matrix ArgMax(matrix &X);\n   \n   //Accuracy = Total number of hits over the total number of samples\n   double Accuracy(matrix &R, matrix &Out);\n   \n   //Mean absolute percentage error \n   double MAPE(matrix &R, matrix &Y);\n  };\n\n//+------------------------------------------------------------------+\n//|    Metrics                                                       |\n//+------------------------------------------------------------------+\nmatrix Metrics::ArgMax(matrix &X)\n{\nvector V;\nV.Init(X.Cols());\n\nulong count;\nmatrix M;\nM.Init(X.Rows(),X.Cols());\nfor(int i=0;i<X.Rows();i++)\n   {for(int j=0;j<X.Cols();j++)\n      {V[j] = X[i][j];}\n   count = V.ArgMax();\n   \n   for(int j=0;j<X.Cols();j++)\n     {if(j == count) M[i][j] = 1;\n      if(j != count) M[i][j] = 0;}\n    }\nreturn M; \n}\n\ndouble Metrics::Accuracy(matrix &R, matrix &Out)\n{\nmatrix Y;\nvector v1, v2;\nv1.Init(R.Cols());\n\nY = ArgMax(Out);\nv2.Init(Y.Cols());\n\nulong count1, count2;\ndouble N_samples, N_hits, Accur;\nN_samples = R.Rows();\nN_hits = 0;\n\nfor(int i=0;i<R.Rows();i++)\n  {for(int j=0;j<R.Cols();j++)\n     {v1[j] = R[i][j];\n      v2[j] = Y[i][j];}\n   count1 = v1.ArgMax();\n   count2 = v2.ArgMax();\n   if(count1 == count2) N_hits = N_hits + 1.0;\n   \n  }\n  \nAccur = N_hits/N_samples;\nreturn Accur;\n}\n\ndouble Metrics::MAPE(matrix &R, matrix &Y)\n{\nmatrix Err;\nErr = R - Y; \nErr = Err / R; \nErr = MathAbs(Err);\n\ndouble error; \nerror = Err.Mean();\n\nreturn error; \n}"
  },
  {
    "filename": "DenseLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Dense Layer                                                    |\n//+------------------------------------------------------------------+\n\nclass DenseLayer : public DeepLearning\n  {\npublic:\n   //Initializes the layer weights and bias from the number of outputs\n   //LR is Learning rate and Op is the optimization method\n   void InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error  \n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Configurar par\u00e2metros do ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\nprivate:\n   //Pesos da camada\n   matrix W;\n   //Grad dos Pesos\n   matrix dW;\n   //Bias da camada\n   matrix B;\n   //Grad do Bias\n   matrix dB;\n   //Vetor de entrada \n   matrix Xe;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimza\u00e7\u00e3o\n   Optim OP;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n      \n  };\n\n//+------------------------------------------------------------------+\n//|   DenseLayer                                                     |\n//+------------------------------------------------------------------+\nvoid DenseLayer::InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n   \n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix DenseLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\nreturn Y;\n}\nmatrix DenseLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex; \n   Ex = W.Transpose().MatMul(Ey);\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   return Ex;\n}\nvoid DenseLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }   \n}\nvoid DenseLayer::SaveWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n\n} \n\nvoid DenseLayer::LoadWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid DenseLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}",
    "search_content": "//+------------------------------------------------------------------+\n//|   Dense Layer                                                    |\n//+------------------------------------------------------------------+\n\nclass DenseLayer : public DeepLearning\n  {\npublic:\n   //Initializes the layer weights and bias from the number of outputs\n   //LR is Learning rate and Op is the optimization method\n   void InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error  \n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Configurar par\u00e2metros do ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\nprivate:\n   //Pesos da camada\n   matrix W;\n   //Grad dos Pesos\n   matrix dW;\n   //Bias da camada\n   matrix B;\n   //Grad do Bias\n   matrix dB;\n   //Vetor de entrada \n   matrix Xe;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimza\u00e7\u00e3o\n   Optim OP;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n      \n  };\n\n//+------------------------------------------------------------------+\n//|   DenseLayer                                                     |\n//+------------------------------------------------------------------+\nvoid DenseLayer::InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n   \n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix DenseLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\nreturn Y;\n}\nmatrix DenseLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex; \n   Ex = W.Transpose().MatMul(Ey);\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   return Ex;\n}\nvoid DenseLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }   \n}\nvoid DenseLayer::SaveWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n\n} \n\nvoid DenseLayer::LoadWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid DenseLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}"
  },
  {
    "filename": "ActivationLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Activation Layer                                               |\n//+------------------------------------------------------------------+\n\nclass ActivationLayer : public DeepLearning\n  {\npublic:\n   \n   void   InitLayer(ActFunction af);\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\n   \nprivate :\n   \n   //Activation function\n   ActFunction AF;\n   //Input that needs to be saved for gradient descent\n   matrix Xs;  \n  };\n\n//+------------------------------------------------------------------+\n//|    Activation Layer                                              |\n//+------------------------------------------------------------------+\n\nvoid ActivationLayer::InitLayer(ActFunction af)\n{\nAF = af;\n}\nmatrix ActivationLayer::Output(matrix &X)\n{\nmatrix Y;\n\nXs = X;\nif(AF == SIGMOID) Y = Sig(X);\nif(AF == TANH)    Y = Tanh(X);\nif(AF == RELU)    Y = ReLU(X);\n\nreturn Y;\n}\nmatrix ActivationLayer::GradDescent(matrix &Ey)\n{\nmatrix dPhi;\n\nmatrix Ex;\nif(AF == SIGMOID) dPhi = dSig(Xs);\nif(AF == TANH)    dPhi = dTanh(Xs);\nif(AF == RELU)    dPhi = dReLU(Xs);\n\nEx = Ey * dPhi;\nreturn Ex;\n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|   Activation Layer                                               |\n//+------------------------------------------------------------------+\n\nclass ActivationLayer : public DeepLearning\n  {\npublic:\n   \n   void   InitLayer(ActFunction af);\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\n   \nprivate :\n   \n   //Activation function\n   ActFunction AF;\n   //Input that needs to be saved for gradient descent\n   matrix Xs;  \n  };\n\n//+------------------------------------------------------------------+\n//|    Activation Layer                                              |\n//+------------------------------------------------------------------+\n\nvoid ActivationLayer::InitLayer(ActFunction af)\n{\nAF = af;\n}\nmatrix ActivationLayer::Output(matrix &X)\n{\nmatrix Y;\n\nXs = X;\nif(AF == SIGMOID) Y = Sig(X);\nif(AF == TANH)    Y = Tanh(X);\nif(AF == RELU)    Y = ReLU(X);\n\nreturn Y;\n}\nmatrix ActivationLayer::GradDescent(matrix &Ey)\n{\nmatrix dPhi;\n\nmatrix Ex;\nif(AF == SIGMOID) dPhi = dSig(Xs);\nif(AF == TANH)    dPhi = dTanh(Xs);\nif(AF == RELU)    dPhi = dReLU(Xs);\n\nEx = Ey * dPhi;\nreturn Ex;\n}\n"
  },
  {
    "filename": "FlattenLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Flatten                                                        |\n//+------------------------------------------------------------------+\n\nclass FlattenLayer : public DeepLearning\n  {\npublic:\n   //Calculates the output of the litter from an input\n   //Transforms each row of matrix X into a column and then puts a column\n   //below column EX: {{1,2},{3,4}} => {{1},{2},{3},{4}}\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights \nprivate: \n   int N_steps;\n   int N_entries;\n  };\n\n//+------------------------------------------------------------------+\n//|    Flatten Layer                                                 |\n//+------------------------------------------------------------------+\n\nmatrix FlattenLayer::Output(matrix &X)\n{\nN_entries = X.Rows();\nN_steps = X.Cols();\nmatrix Y;\nY.Init(N_entries*N_steps,1);\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Y[i*N_entries+j][0] = X[i][j];}}\n\nreturn Y;\n}  \nmatrix FlattenLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex;\nEx.Init(N_entries,N_steps);\n\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Ex[i][j]= Ey[i*N_entries+j][0];}}\n\nreturn Ex;\n}\n\n",
    "search_content": "//+------------------------------------------------------------------+\n//|   Flatten                                                        |\n//+------------------------------------------------------------------+\n\nclass FlattenLayer : public DeepLearning\n  {\npublic:\n   //Calculates the output of the litter from an input\n   //Transforms each row of matrix X into a column and then puts a column\n   //below column EX: {{1,2},{3,4}} => {{1},{2},{3},{4}}\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights \nprivate: \n   int N_steps;\n   int N_entries;\n  };\n\n//+------------------------------------------------------------------+\n//|    Flatten Layer                                                 |\n//+------------------------------------------------------------------+\n\nmatrix FlattenLayer::Output(matrix &X)\n{\nN_entries = X.Rows();\nN_steps = X.Cols();\nmatrix Y;\nY.Init(N_entries*N_steps,1);\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Y[i*N_entries+j][0] = X[i][j];}}\n\nreturn Y;\n}  \nmatrix FlattenLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex;\nEx.Init(N_entries,N_steps);\n\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Ex[i][j]= Ey[i*N_entries+j][0];}}\n\nreturn Ex;\n}\n\n"
  },
  {
    "filename": "SoftmaxLayer.mqh",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|   Softmax Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass softmaxLayer : public DeepLearning\n  {\npublic:\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\nprivate:\n   matrix M; \n  };\n\n//+------------------------------------------------------------------+\n//|     Softmax                                                      |\n//+------------------------------------------------------------------+\nmatrix softmaxLayer::Output(matrix &X)\n{\nmatrix Y;\nY.Init(X.Rows(),X.Cols());\ndouble Sum;\nSum = 0;\n\nfor(int i=0;i<X.Rows();i++)\n  {Sum = Sum + MathExp(X[i][0]);}\nfor(int i=0;i<Y.Rows();i++)\n  {Y[i][0] = MathExp(X[i][0])/Sum;}\n\nM.Init(Y.Rows(),Y.Rows());\n\nfor(int j=0;j<M.Cols();j++)\n  {for(int i=0;i<M.Rows();i++)\n     {M[i][j] = Y[i][0];}}\n\nreturn Y; \n}\nmatrix softmaxLayer::GradDescent(matrix &Ey)\n{\nmatrix S;\nmatrix I;\nI.Init(M.Rows(),M.Cols());\nI.Identity();\nS = M * (I - M.Transpose());\nS = S.MatMul(Ey);\nreturn S;\n}\n",
    "search_content": "//+------------------------------------------------------------------+\n//|   Softmax Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass softmaxLayer : public DeepLearning\n  {\npublic:\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\nprivate:\n   matrix M; \n  };\n\n//+------------------------------------------------------------------+\n//|     Softmax                                                      |\n//+------------------------------------------------------------------+\nmatrix softmaxLayer::Output(matrix &X)\n{\nmatrix Y;\nY.Init(X.Rows(),X.Cols());\ndouble Sum;\nSum = 0;\n\nfor(int i=0;i<X.Rows();i++)\n  {Sum = Sum + MathExp(X[i][0]);}\nfor(int i=0;i<Y.Rows();i++)\n  {Y[i][0] = MathExp(X[i][0])/Sum;}\n\nM.Init(Y.Rows(),Y.Rows());\n\nfor(int j=0;j<M.Cols();j++)\n  {for(int i=0;i<M.Rows();i++)\n     {M[i][j] = Y[i][0];}}\n\nreturn Y; \n}\nmatrix softmaxLayer::GradDescent(matrix &Ey)\n{\nmatrix S;\nmatrix I;\nI.Init(M.Rows(),M.Cols());\nI.Identity();\nS = M * (I - M.Transpose());\nS = S.MatMul(Ey);\nreturn S;\n}\n"
  },
  {
    "filename": "Cube.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Cube mesh.\n */\n\n#include \"Face.h\"\n#include \"Mesh.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/cube_ps.hlsl\" as string ShaderCubeSourcePS;\n#resource \"Shaders/cube_vs.hlsl\" as string ShaderCubeSourceVS;\n#endif\n\n/**\n * Cube mesh.\n */\ntemplate <typename T>\nclass Cube : public Mesh<T> {\n public:\n  Cube(float size_x, float size_y, float size_z, float x = 0.0f, float y = 0.0f, float z = 0.0f)\n      : Mesh(MESH_TYPE_SEPARATE_POINTS) {\n    float half_x = size_x / 2;\n    float half_y = size_y / 2;\n    float half_z = size_z / 2;\n\n    Face<T> f1(x - half_x, y - half_y, z - half_z, x - half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z - half_z, x + half_x, y - half_y, z - half_z);\n\n    Face<T> f2(x + half_x, y - half_y, z + half_z, x + half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z + half_z, x - half_x, y - half_y, z + half_z);\n\n    Face<T> f3(x - half_x, y - half_y, z + half_z, x - half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z - half_z, x - half_x, y - half_y, z - half_z);\n\n    Face<T> f4(x + half_x, y - half_y, z - half_z, x + half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f5(x - half_x, y - half_y, z + half_z, x - half_x, y - half_y, z - half_z, x + half_x, y - half_y,\n               z - half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f6(x - half_x, y + half_y, z - half_z, x - half_x, y + half_y, z + half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y + half_y, z - half_z);\n\n    AddFace(f1);\n    AddFace(f2);\n    AddFace(f3);\n    AddFace(f4);\n    AddFace(f5);\n    AddFace(f6);\n  }\n\n#ifdef __MQL5__\n  /**\n   * Initializes graphics device-related things.\n   */\n  virtual void Initialize(Device* _device) {\n    SetShaderVS(_device.VertexShader(ShaderCubeSourceVS, T::Layout));\n    SetShaderPS(_device.PixelShader(ShaderCubeSourcePS));\n  }\n#endif\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Cube mesh.\n */\n\n#include \"Face.h\"\n#include \"Mesh.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/cube_ps.hlsl\" as string ShaderCubeSourcePS;\n#resource \"Shaders/cube_vs.hlsl\" as string ShaderCubeSourceVS;\n#endif\n\n/**\n * Cube mesh.\n */\ntemplate <typename T>\nclass Cube : public Mesh<T> {\n public:\n  Cube(float size_x, float size_y, float size_z, float x = 0.0f, float y = 0.0f, float z = 0.0f)\n      : Mesh(MESH_TYPE_SEPARATE_POINTS) {\n    float half_x = size_x / 2;\n    float half_y = size_y / 2;\n    float half_z = size_z / 2;\n\n    Face<T> f1(x - half_x, y - half_y, z - half_z, x - half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z - half_z, x + half_x, y - half_y, z - half_z);\n\n    Face<T> f2(x + half_x, y - half_y, z + half_z, x + half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z + half_z, x - half_x, y - half_y, z + half_z);\n\n    Face<T> f3(x - half_x, y - half_y, z + half_z, x - half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z - half_z, x - half_x, y - half_y, z - half_z);\n\n    Face<T> f4(x + half_x, y - half_y, z - half_z, x + half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f5(x - half_x, y - half_y, z + half_z, x - half_x, y - half_y, z - half_z, x + half_x, y - half_y,\n               z - half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f6(x - half_x, y + half_y, z - half_z, x - half_x, y + half_y, z + half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y + half_y, z - half_z);\n\n    AddFace(f1);\n    AddFace(f2);\n    AddFace(f3);\n    AddFace(f4);\n    AddFace(f5);\n    AddFace(f6);\n  }\n\n#ifdef __MQL5__\n  /**\n   * Initializes graphics device-related things.\n   */\n  virtual void Initialize(Device* _device) {\n    SetShaderVS(_device.VertexShader(ShaderCubeSourceVS, T::Layout));\n    SetShaderPS(_device.PixelShader(ShaderCubeSourcePS));\n  }\n#endif\n};\n"
  },
  {
    "filename": "Frontend.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics front-end (display buffer target).\n */\n\n#include \"../Refs.mqh\"\n\nstruct DrawTextQueueItem {\n  float x;\n  float y;\n  string text;\n  unsigned int rgb;\n  unsigned int align;\n};\n\n/**\n * Represents visual target (OS window/canvas for rendering).\n */\nclass Frontend : public Dynamic {\n protected:\n  DrawTextQueueItem draw_text_queue[];\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  bool Start() { return Init(); }\n\n  /**\n   * Deinitializes canvas.\n   */\n  bool End() { return Deinit(); }\n\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() = NULL;\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() = NULL;\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) = NULL;\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) = NULL;\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() = NULL;\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() = NULL;\n\n  /**\n   * Enqueues text to be drawn directly into the pixel buffer. Queue will be processed in the Device::End() method.\n   */\n  virtual void DrawText(float _x, float _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    DrawTextQueueItem _item;\n    _item.x = _x;\n    _item.y = _y;\n    _item.text = _text;\n    _item.rgb = _color;\n    _item.align = _align;\n    Util::ArrayPush(draw_text_queue, _item);\n  }\n\n  void ProcessDrawText() {\n    for (int i = 0; i < ArraySize(draw_text_queue); ++i) {\n      DrawTextQueueItem _item = draw_text_queue[i];\n      DrawTextNow((int)_item.x, (int)_item.y, _item.text, _item.rgb, _item.align);\n    }\n    ArrayResize(draw_text_queue, 0);\n  }\n\n protected:\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {}\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics front-end (display buffer target).\n */\n\n#include \"../Refs.mqh\"\n\nstruct DrawTextQueueItem {\n  float x;\n  float y;\n  string text;\n  unsigned int rgb;\n  unsigned int align;\n};\n\n/**\n * Represents visual target (OS window/canvas for rendering).\n */\nclass Frontend : public Dynamic {\n protected:\n  DrawTextQueueItem draw_text_queue[];\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  bool Start() { return Init(); }\n\n  /**\n   * Deinitializes canvas.\n   */\n  bool End() { return Deinit(); }\n\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() = NULL;\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() = NULL;\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) = NULL;\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) = NULL;\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() = NULL;\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() = NULL;\n\n  /**\n   * Enqueues text to be drawn directly into the pixel buffer. Queue will be processed in the Device::End() method.\n   */\n  virtual void DrawText(float _x, float _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    DrawTextQueueItem _item;\n    _item.x = _x;\n    _item.y = _y;\n    _item.text = _text;\n    _item.rgb = _color;\n    _item.align = _align;\n    Util::ArrayPush(draw_text_queue, _item);\n  }\n\n  void ProcessDrawText() {\n    for (int i = 0; i < ArraySize(draw_text_queue); ++i) {\n      DrawTextQueueItem _item = draw_text_queue[i];\n      DrawTextNow((int)_item.x, (int)_item.y, _item.text, _item.rgb, _item.align);\n    }\n    ArrayResize(draw_text_queue, 0);\n  }\n\n protected:\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {}\n};\n"
  },
  {
    "filename": "Device.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics device.\n */\n\n#include \"../Refs.mqh\"\n#include \"../Util.h\"\n#include \"Frontend.h\"\n#include \"IndexBuffer.h\"\n#include \"Material.h\"\n#include \"Math.h\"\n#include \"Mesh.h\"\n#include \"Shader.h\"\n#include \"VertexBuffer.h\"\n\nenum GFX_DRAW_TEXT_FLAGS { GFX_DRAW_TEXT_FLAG_NONE, GFX_DRAW_TEXT_FLAG_2D_COORD_X, GFX_DRAW_TEXT_FLAG_2D_COORD_Y };\n\nenum ENUM_CLEAR_BUFFER_TYPE { CLEAR_BUFFER_TYPE_COLOR, CLEAR_BUFFER_TYPE_DEPTH };\n\n/**\n * Graphics device.\n */\nclass Device : public Dynamic {\n protected:\n  int context;\n  Ref<Frontend> frontend;\n  DXMatrix mtx_stack[];\n  DXMatrix mtx_world;\n  DXMatrix mtx_view;\n  DXMatrix mtx_projection;\n  DXVector3 lightdir;\n  Material material;\n\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Start(Frontend* _frontend) {\n    frontend = _frontend;\n    DXMatrixIdentity(mtx_world);\n    DXMatrixIdentity(mtx_view);\n    DXMatrixIdentity(mtx_projection);\n    TSR _identity;\n    PushTransform(_identity);\n    lightdir = DXVector3(-0.2f, 0.2f, 1.0f);\n    return Init(_frontend);\n  }\n\n  void PushTransform(const TSR& tsr) {\n    Util::ArrayPush(mtx_stack, mtx_world);\n    DXMatrixMultiply(mtx_world, tsr.ToMatrix(), mtx_world);\n  }\n\n  void PopTransform() { mtx_world = Util::ArrayPop(mtx_stack); }\n\n  /**\n   * Begins render loop.\n   */\n  Device* Begin(unsigned int clear_color = 0) {\n    frontend.Ptr().RenderBegin(context);\n    Clear(clear_color);\n    ClearDepth();\n    RenderBegin();\n    return &this;\n  }\n\n  /**\n   * Ends render loop.\n   */\n  Device* End() {\n    RenderEnd();\n    frontend.Ptr().RenderEnd(context);\n    frontend.Ptr().ProcessDrawText();\n    return &this;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  Device* Stop() {\n    Deinit();\n    return &this;\n  }\n\n  /**\n   * Clears scene's color buffer.\n   */\n  Device* Clear(unsigned int _color = 0xFF000000) {\n    ClearBuffer(CLEAR_BUFFER_TYPE_COLOR, _color);\n    return &this;\n  }\n\n  /**\n   * Begins scene's depth buffer.\n   */\n  Device* ClearDepth() {\n    ClearBuffer(CLEAR_BUFFER_TYPE_DEPTH, 0);\n    return &this;\n  }\n\n  /**\n   * Returns current material.\n   */\n  Material GetMaterial() { return material; }\n\n  /**\n   * Assigns material for later rendering.\n   */\n  void SetMaterial(Material& _material) { material = _material; }\n\n  /**\n   * Returns graphics device context as integer.\n   */\n  int Context() { return context; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[],\n                               string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  template <typename T>\n  VertexBuffer* VertexBuffer(T& data[]) {\n    VertexBuffer* _buff = VertexBuffer();\n    // Unfortunately we can't make this method virtual.\n    if (dynamic_cast<MTDXVertexBuffer*>(_buff) != NULL) {\n// MT5's DirectX.\n#ifdef __debug__\n      Print(\"Filling vertex buffer via MTDXVertexBuffer\");\n#endif\n      ((MTDXVertexBuffer*)_buff).Fill<T>(data);\n    } else {\n      Alert(\"Unsupported vertex buffer device target\");\n    }\n    return _buff;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  virtual VertexBuffer* VertexBuffer() = NULL;\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  void Render(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) { RenderBuffers(_vertices, _indices); }\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) = NULL;\n\n  /**\n   * Renders given mesh.\n   */\n  template <typename T>\n  void Render(Mesh<T>* _mesh, Shader* _vs = NULL, Shader* _ps = NULL) {\n#ifdef __debug__\n    Print(\"Rendering mesh\");\n#endif\n    VertexBuffer* _vertices;\n    IndexBuffer* _indices;\n    _mesh.GetBuffers(&this, _vertices, _indices);\n\n    SetMaterial(_mesh.GetMaterial());\n\n    PushTransform(_mesh.GetTSR());\n\n    SetShader(_vs != NULL ? _vs : _mesh.GetShaderVS());\n    SetShader(_ps != NULL ? _ps : _mesh.GetShaderPS());\n\n    Render(_vertices, _indices);\n\n    PopTransform();\n  }\n\n  /**\n   * Activates shader for rendering.\n   */\n  void SetShader(Shader* _shader) { _shader.Select(); }\n\n  /**\n   * Activates shaders for rendering.\n   */\n  void SetShader(Shader* _shader1, Shader* _shader2) {\n    _shader1.Select();\n    _shader2.Select();\n  }\n\n  /**\n   * Returns front-end's viewport width.\n   */\n  int Width() { return frontend.Ptr().Width(); }\n\n  /**\n   * Returns front-end's viewport height.\n   */\n  int Height() { return frontend.Ptr().Height(); }\n\n  void SetCameraOrtho3D(float _pos_x = 0.0f, float _pos_y = 0.0f, float _pos_z = 0.0f) {\n    DXMatrixOrthoLH(mtx_projection, 1.0f * _pos_z, 1.0f / Width() * Height() * _pos_z, -10000, 10000);\n  }\n\n  DXMatrix GetWorldMatrix() { return mtx_world; }\n\n  void SetWorldMatrix(DXMatrix& _matrix) { mtx_world = _matrix; }\n\n  DXMatrix GetViewMatrix() { return mtx_view; }\n\n  void SetViewMatrix(DXMatrix& _matrix) { mtx_view = _matrix; }\n\n  DXMatrix GetProjectionMatrix() { return mtx_projection; }\n\n  void SetProjectionMatrix(DXMatrix& _matrix) { mtx_projection = _matrix; }\n\n  DXVector3 GetLightDirection() { return lightdir; }\n\n  void SetLightDirection(float x, float y, float z) {\n    lightdir.x = x;\n    lightdir.y = y;\n    lightdir.z = z;\n  }\n\n  /**\n   * Enqueues text to be drawn directly into the pixel buffer. Queue will be processed in the Device::End() method.\n   */\n  void DrawText(float _x, float _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0,\n                unsigned int _flags = 0) {\n    DViewport _viewport;\n    _viewport.x = 0;\n    _viewport.y = 0;\n    _viewport.width = frontend.Ptr().Width();\n    _viewport.height = frontend.Ptr().Height();\n    _viewport.minz = -10000.0f;\n    _viewport.maxz = 10000.0f;\n\n    DXVector3 _vec3_in(_x, _y, 0.0f);\n    DXVector3 _vec3_out;\n    DXVec3Project(_vec3_out, _vec3_in, _viewport, GetProjectionMatrix(), GetViewMatrix(), GetWorldMatrix());\n\n    if ((_flags & GFX_DRAW_TEXT_FLAG_2D_COORD_X) == GFX_DRAW_TEXT_FLAG_2D_COORD_X) {\n      _vec3_out.x = _x;\n    }\n\n    if ((_flags & GFX_DRAW_TEXT_FLAG_2D_COORD_Y) == GFX_DRAW_TEXT_FLAG_2D_COORD_Y) {\n      _vec3_out.y = _y;\n    }\n\n    frontend.Ptr().DrawText(_vec3_out.x, _vec3_out.y, _text, _color, _align);\n  }\n\n protected:\n  /**\n   * Initializes graphics device.\n   */\n  virtual bool Init(Frontend*) = NULL;\n\n  /**\n   * Deinitializes graphics device.\n   */\n  virtual bool Deinit() = NULL;\n\n  /**\n   * Starts rendering loop.\n   */\n  virtual bool RenderBegin() = NULL;\n\n  /**\n   * Ends rendering loop.\n   */\n  virtual bool RenderEnd() = NULL;\n\n  /**\n   * Clears color buffer.\n   */\n  virtual void ClearBuffer(ENUM_CLEAR_BUFFER_TYPE _type, unsigned int _color) = NULL;\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics device.\n */\n\n#include \"../Refs.mqh\"\n#include \"../Util.h\"\n#include \"Frontend.h\"\n#include \"IndexBuffer.h\"\n#include \"Material.h\"\n#include \"Math.h\"\n#include \"Mesh.h\"\n#include \"Shader.h\"\n#include \"VertexBuffer.h\"\n\nenum GFX_DRAW_TEXT_FLAGS { GFX_DRAW_TEXT_FLAG_NONE, GFX_DRAW_TEXT_FLAG_2D_COORD_X, GFX_DRAW_TEXT_FLAG_2D_COORD_Y };\n\nenum ENUM_CLEAR_BUFFER_TYPE { CLEAR_BUFFER_TYPE_COLOR, CLEAR_BUFFER_TYPE_DEPTH };\n\n/**\n * Graphics device.\n */\nclass Device : public Dynamic {\n protected:\n  int context;\n  Ref<Frontend> frontend;\n  DXMatrix mtx_stack[];\n  DXMatrix mtx_world;\n  DXMatrix mtx_view;\n  DXMatrix mtx_projection;\n  DXVector3 lightdir;\n  Material material;\n\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Start(Frontend* _frontend) {\n    frontend = _frontend;\n    DXMatrixIdentity(mtx_world);\n    DXMatrixIdentity(mtx_view);\n    DXMatrixIdentity(mtx_projection);\n    TSR _identity;\n    PushTransform(_identity);\n    lightdir = DXVector3(-0.2f, 0.2f, 1.0f);\n    return Init(_frontend);\n  }\n\n  void PushTransform(const TSR& tsr) {\n    Util::ArrayPush(mtx_stack, mtx_world);\n    DXMatrixMultiply(mtx_world, tsr.ToMatrix(), mtx_world);\n  }\n\n  void PopTransform() { mtx_world = Util::ArrayPop(mtx_stack); }\n\n  /**\n   * Begins render loop.\n   */\n  Device* Begin(unsigned int clear_color = 0) {\n    frontend.Ptr().RenderBegin(context);\n    Clear(clear_color);\n    ClearDepth();\n    RenderBegin();\n    return &this;\n  }\n\n  /**\n   * Ends render loop.\n   */\n  Device* End() {\n    RenderEnd();\n    frontend.Ptr().RenderEnd(context);\n    frontend.Ptr().ProcessDrawText();\n    return &this;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  Device* Stop() {\n    Deinit();\n    return &this;\n  }\n\n  /**\n   * Clears scene's color buffer.\n   */\n  Device* Clear(unsigned int _color = 0xFF000000) {\n    ClearBuffer(CLEAR_BUFFER_TYPE_COLOR, _color);\n    return &this;\n  }\n\n  /**\n   * Begins scene's depth buffer.\n   */\n  Device* ClearDepth() {\n    ClearBuffer(CLEAR_BUFFER_TYPE_DEPTH, 0);\n    return &this;\n  }\n\n  /**\n   * Returns current material.\n   */\n  Material GetMaterial() { return material; }\n\n  /**\n   * Assigns material for later rendering.\n   */\n  void SetMaterial(Material& _material) { material = _material; }\n\n  /**\n   * Returns graphics device context as integer.\n   */\n  int Context() { return context; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[],\n                               string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  template <typename T>\n  VertexBuffer* VertexBuffer(T& data[]) {\n    VertexBuffer* _buff = VertexBuffer();\n    // Unfortunately we can't make this method virtual.\n    if (dynamic_cast<MTDXVertexBuffer*>(_buff) != NULL) {\n// MT5's DirectX.\n#ifdef __debug__\n      Print(\"Filling vertex buffer via MTDXVertexBuffer\");\n#endif\n      ((MTDXVertexBuffer*)_buff).Fill<T>(data);\n    } else {\n      Alert(\"Unsupported vertex buffer device target\");\n    }\n    return _buff;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  virtual VertexBuffer* VertexBuffer() = NULL;\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  void Render(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) { RenderBuffers(_vertices, _indices); }\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) = NULL;\n\n  /**\n   * Renders given mesh.\n   */\n  template <typename T>\n  void Re"
  },
  {
    "filename": "Chart3DType.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart type renderer.\n */\n\n#include \"../Refs.mqh\"\n#include \"Device.h\"\n\nclass Chart3D;\nclass Device;\n\n/**\n * 3D chart type renderer.\n */\nclass Chart3DType : public Dynamic {\n protected:\n  Chart3D* chart3d;\n  Device* device;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DType(Chart3D* _chart3d, Device* _device) : chart3d(_chart3d), device(_device) {}\n\n  Device* GetDevice() { return device; }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {}\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart type renderer.\n */\n\n#include \"../Refs.mqh\"\n#include \"Device.h\"\n\nclass Chart3D;\nclass Device;\n\n/**\n * 3D chart type renderer.\n */\nclass Chart3DType : public Dynamic {\n protected:\n  Chart3D* chart3d;\n  Device* device;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DType(Chart3D* _chart3d, Device* _device) : chart3d(_chart3d), device(_device) {}\n\n  Device* GetDevice() { return device; }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {}\n};\n"
  },
  {
    "filename": "Face.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics face object.\n */\n\n#include \"Math.h\"\n\n// Face flags.\nenum ENUM_FACE_FLAGS { FACE_FLAGS_NONE, FACE_FLAGS_TRIANGLE, FACE_FLAGS_QUAD };\n\n// Face (3 or 4 vertices).\ntemplate <typename T>\nstruct Face {\n  // Flags.\n  ENUM_FACE_FLAGS flags;\n\n  // 3 or 4 points.\n  T points[4];\n\n  /**\n   * Constructor.\n   */\n  Face() { flags = FACE_FLAGS_NONE; }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {\n    flags = FACE_FLAGS_TRIANGLE;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n  }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4,\n       float z4) {\n    flags = FACE_FLAGS_QUAD;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n    points[3].Position.x = x4;\n    points[3].Position.y = y4;\n    points[3].Position.z = z4;\n  }\n\n  void UpdateNormal() {\n    DXVector3 _normal, _v1, _v2;\n\n    DXVec3Subtract(_v1, points[1].Position, points[0].Position);\n    DXVec3Subtract(_v2, points[2].Position, points[0].Position);\n\n    DXVec3Cross(_normal, _v1, _v2);\n    DXVec3Normalize(_normal, _normal);\n\n    for (int i = 0; i < 4; ++i) {\n      points[i].Normal = _normal;\n    }\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics face object.\n */\n\n#include \"Math.h\"\n\n// Face flags.\nenum ENUM_FACE_FLAGS { FACE_FLAGS_NONE, FACE_FLAGS_TRIANGLE, FACE_FLAGS_QUAD };\n\n// Face (3 or 4 vertices).\ntemplate <typename T>\nstruct Face {\n  // Flags.\n  ENUM_FACE_FLAGS flags;\n\n  // 3 or 4 points.\n  T points[4];\n\n  /**\n   * Constructor.\n   */\n  Face() { flags = FACE_FLAGS_NONE; }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {\n    flags = FACE_FLAGS_TRIANGLE;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n  }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4,\n       float z4) {\n    flags = FACE_FLAGS_QUAD;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n    points[3].Position.x = x4;\n    points[3].Position.y = y4;\n    points[3].Position.z = z4;\n  }\n\n  void UpdateNormal() {\n    DXVector3 _normal, _v1, _v2;\n\n    DXVec3Subtract(_v1, points[1].Position, points[0].Position);\n    DXVec3Subtract(_v2, points[2].Position, points[0].Position);\n\n    DXVec3Cross(_normal, _v1, _v2);\n    DXVec3Normalize(_normal, _normal);\n\n    for (int i = 0; i < 4; ++i) {\n      points[i].Normal = _normal;\n    }\n  }\n};\n"
  },
  {
    "filename": "Interface.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Chart events.\n */\n\n#include \"../Util.h\"\n\nenum ENUM_INTERFACE_EVENT {\n  INTERFACE_EVENT_NONE,\n  INTERFACE_EVENT_MOUSE_MOVE,\n  INTERFACE_EVENT_MOUSE_DOWN,\n  INTERFACE_EVENT_MOUSE_UP\n};\n\nstruct InterfaceEvent {\n  ENUM_INTERFACE_EVENT type;\n  struct EventMouse {\n    int x;\n    int y;\n    datetime dt;\n  };\n\n  union EventData {\n    EventMouse mouse;\n  } data;\n};\n\n#ifdef __MQL5__\n/**\n * \"OnChart\" event handler function (MQL5 only).\n *\n * Invoked when the ChartEvent event occurs.\n */\nvoid OnChartEvent(const int id, const long& lparam, const double& dparam, const string& sparam) {\n  datetime _dt;\n  double _mp;\n  int _window = 0;\n  InterfaceEvent _event;\n\n  if (id == CHART_EVENT_MOUSE_MOVE) {\n    Interface::mouse_pos_x = (int)lparam;\n    Interface::mouse_pos_y = (int)dparam;\n    ChartXYToTimePrice(0, Interface::mouse_pos_x, Interface::mouse_pos_y, _window, _dt, _mp);\n    _event.type = INTERFACE_EVENT_MOUSE_MOVE;\n    _event.data.mouse.x = Interface::mouse_pos_x;\n    _event.data.mouse.y = Interface::mouse_pos_y;\n    Interface::FireEvent(_event);\n  }\n}\n#endif\n\ntypedef void (*InterfaceListener)(InterfaceEvent&, void*);\n\nclass Interface {\n public:\n  struct Installation {\n    InterfaceListener listener;\n    void* target;\n  };\n\n  static Installation installations[];\n\n  static bool mouse_was_down;\n  static int mouse_pos_x;\n  static int mouse_pos_y;\n  static bool initialized;\n\n#ifdef __MQL5__\n  static void AddListener(InterfaceListener _listener, void* _target) {\n    if (!initialized) {\n      ChartSetInteger(0, CHART_EVENT_MOUSE_MOVE, true);\n      ChartRedraw();\n      initialized = true;\n    }\n\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      if (installations[i].listener == _listener) {\n        // Listener already added.\n        return;\n      }\n    }\n\n    Installation _installation;\n    _installation.listener = _listener;\n    _installation.target = _target;\n\n    Util::ArrayPush(installations, _installation);\n  }\n\n  static void FireEvent(InterfaceEvent& _event) {\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      Installation _installation = installations[i];\n      _installation.listener(_event, _installation.target);\n    }\n  }\n\n  static int GetMouseX() { return mouse_pos_x; }\n\n  static int GetMouseY() { return mouse_pos_y; }\n#endif\n};\n\n#ifdef __MQL5__\nInterface::Installation Interface::installations[];\nbool Interface::mouse_was_down = false;\nint Interface::mouse_pos_x = 0;\nint Interface::mouse_pos_y = 0;\nbool Interface::initialized = false;\n#endif\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Chart events.\n */\n\n#include \"../Util.h\"\n\nenum ENUM_INTERFACE_EVENT {\n  INTERFACE_EVENT_NONE,\n  INTERFACE_EVENT_MOUSE_MOVE,\n  INTERFACE_EVENT_MOUSE_DOWN,\n  INTERFACE_EVENT_MOUSE_UP\n};\n\nstruct InterfaceEvent {\n  ENUM_INTERFACE_EVENT type;\n  struct EventMouse {\n    int x;\n    int y;\n    datetime dt;\n  };\n\n  union EventData {\n    EventMouse mouse;\n  } data;\n};\n\n#ifdef __MQL5__\n/**\n * \"OnChart\" event handler function (MQL5 only).\n *\n * Invoked when the ChartEvent event occurs.\n */\nvoid OnChartEvent(const int id, const long& lparam, const double& dparam, const string& sparam) {\n  datetime _dt;\n  double _mp;\n  int _window = 0;\n  InterfaceEvent _event;\n\n  if (id == CHART_EVENT_MOUSE_MOVE) {\n    Interface::mouse_pos_x = (int)lparam;\n    Interface::mouse_pos_y = (int)dparam;\n    ChartXYToTimePrice(0, Interface::mouse_pos_x, Interface::mouse_pos_y, _window, _dt, _mp);\n    _event.type = INTERFACE_EVENT_MOUSE_MOVE;\n    _event.data.mouse.x = Interface::mouse_pos_x;\n    _event.data.mouse.y = Interface::mouse_pos_y;\n    Interface::FireEvent(_event);\n  }\n}\n#endif\n\ntypedef void (*InterfaceListener)(InterfaceEvent&, void*);\n\nclass Interface {\n public:\n  struct Installation {\n    InterfaceListener listener;\n    void* target;\n  };\n\n  static Installation installations[];\n\n  static bool mouse_was_down;\n  static int mouse_pos_x;\n  static int mouse_pos_y;\n  static bool initialized;\n\n#ifdef __MQL5__\n  static void AddListener(InterfaceListener _listener, void* _target) {\n    if (!initialized) {\n      ChartSetInteger(0, CHART_EVENT_MOUSE_MOVE, true);\n      ChartRedraw();\n      initialized = true;\n    }\n\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      if (installations[i].listener == _listener) {\n        // Listener already added.\n        return;\n      }\n    }\n\n    Installation _installation;\n    _installation.listener = _listener;\n    _installation.target = _target;\n\n    Util::ArrayPush(installations, _installation);\n  }\n\n  static void FireEvent(InterfaceEvent& _event) {\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      Installation _installation = installations[i];\n      _installation.listener(_event, _installation.target);\n    }\n  }\n\n  static int GetMouseX() { return mouse_pos_x; }\n\n  static int GetMouseY() { return mouse_pos_y; }\n#endif\n};\n\n#ifdef __MQL5__\nInterface::Installation Interface::installations[];\nbool Interface::mouse_was_down = false;\nint Interface::mouse_pos_x = 0;\nint Interface::mouse_pos_y = 0;\nbool Interface::initialized = false;\n#endif\n"
  },
  {
    "filename": "IndexBuffer.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics index buffer.\n */\n\n#include \"../Refs.mqh\"\n\nclass Device;\n\n/**\n * Vertices' index buffer.\n */\nclass IndexBuffer : public Dynamic {\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  IndexBuffer(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) = NULL;\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() = NULL;\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics index buffer.\n */\n\n#include \"../Refs.mqh\"\n\nclass Device;\n\n/**\n * Vertices' index buffer.\n */\nclass IndexBuffer : public Dynamic {\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  IndexBuffer(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) = NULL;\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() = NULL;\n};\n"
  },
  {
    "filename": "Chart3D.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D Chart.\n */\n\n#include \"../Bar.struct.h\"\n#include \"../Indicators/Indi_MA.mqh\"\n#include \"../Instances.h\"\n#include \"../Refs.mqh\"\n#include \"../SerializerConverter.mqh\"\n#include \"../SerializerJson.mqh\"\n#include \"Chart3DCandles.h\"\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Interface.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/chart3d_vs.hlsl\" as string Chart3DShaderSourceVS;\n#resource \"Shaders/chart3d_ps.hlsl\" as string Chart3DShaderSourcePS;\n#endif\n\ntypedef BarOHLC (*Chart3DPriceFetcher)(ENUM_TIMEFRAMES, int);\n\n// Type of the currently rendered 3d chart.\nenum ENUM_CHART3D_TYPE {\n  CHART3D_TYPE_BARS,\n  CHART3D_TYPE_CANDLES,\n  CHART3D_TYPE_LINES,\n};\n\nclass Chart3D;\n\nvoid chart3d_interface_listener(InterfaceEvent& _event, void* _target) {\n  Chart3D* chart3d = (Chart3D*)_target;\n  chart3d.OnInterfaceEvent(_event);\n}\n\n/**\n * 3D chart renderer.\n */\nclass Chart3D : public Dynamic {\n  // Camera offset. Z component indicates number of bars per screen's width.\n  DXVector3 offset;\n\n  // Current chart type.\n  ENUM_CHART3D_TYPE type;\n\n  // References to chart type renderers.\n  Ref<Chart3DType> renderers[3];\n\n  // OHLC prices fetcher callback.\n  Chart3DPriceFetcher price_fetcher;\n\n  // Whether graphics were initialized.\n  bool initialized;\n\n  // Shaders.\n  Ref<Shader> shader_vs;\n  Ref<Shader> shader_ps;\n\n  Chart3DType* current_renderer;\n\n  Instances<Chart3D> instances;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3D(Chart3DPriceFetcher _price_fetcher, ENUM_CHART3D_TYPE _type = CHART3D_TYPE_CANDLES) : instances(&this) {\n    price_fetcher = _price_fetcher;\n    type = _type;\n    offset.x = offset.y = 0.0f;\n    offset.z = 25.0f;\n    initialized = false;\n#ifdef __MQL5__\n    Interface::AddListener(chart3d_interface_listener, &this);\n#endif\n  }\n\n  void OnInterfaceEvent(InterfaceEvent& _event) {\n    if (GetCurrentRenderer() == NULL) {\n      return;\n    }\n\n    Device* _gfx = GetCurrentRenderer().GetDevice();\n\n    _gfx.DrawText(10, 10, \"Event!\");\n  }\n\n  Shader* GetShaderVS() { return shader_vs.Ptr(); }\n\n  Shader* GetShaderPS() { return shader_ps.Ptr(); }\n\n  Chart3DType* GetCurrentRenderer() { return current_renderer; }\n\n  Chart3DType* GetRenderer(Device* _device) {\n    if (!initialized) {\n      // shader_vs = _device.VertexShader(Chart3DShaderSourceVS, Vertex::Layout);\n      // shader_ps = _device.PixelShader(Chart3DShaderSourcePS);\n      initialized = true;\n    }\n\n    if (!renderers[type].IsSet()) {\n      switch (type) {\n        case CHART3D_TYPE_BARS:\n          // renderers[type] = new Chart3DBars(_device);\n          break;\n        case CHART3D_TYPE_CANDLES:\n          renderers[type] = new Chart3DCandles(&this, _device);\n          break;\n        case CHART3D_TYPE_LINES:\n          // renderers[type] = new Chart3DLines(_device);\n          break;\n        default:\n          Alert(\"Internal error: Wrong type for Chart3D in Chart3D::GetRenderer()!\");\n          DebugBreak();\n          return NULL;\n      }\n    }\n\n    current_renderer = renderers[type].Ptr();\n\n    return renderers[type].Ptr();\n  }\n\n  /**\n   * Returns given bar's OHLC.\n   */\n  BarOHLC GetPrice(ENUM_TIMEFRAMES _tf, int _shift) {\n    BarOHLC _ohlc;\n    return _ohlc;\n    // return price_fetcher(_tf, _shift); // @fixme: 'price_fetcher' - internal error #%d\n  }\n\n  /**\n   * Return first shift that are visible on the screen. Values is away from 0.\n   */\n  int GetBarsVisibleShiftStart() { return 80; }\n\n  /**\n   * Return last shift that are visible on the screen. Value is closer to 0.\n   */\n  int GetBarsVisibleShiftEnd() { return 0; }\n\n  /**\n   * Returns lowest price of bars on the screen.\n   */\n  float GetMinBarsPrice() {\n    return (float)ChartStatic::iLow(\n        Symbol(), PERIOD_CURRENT,\n        ChartStatic::iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd(),\n                             GetBarsVisibleShiftEnd()));\n  }\n\n  /**\n   * Returns highest price of bars on the screen.\n   */\n  float GetMaxBarsPrice() {\n    return (float)ChartStatic::iHigh(\n        Symbol(), PERIOD_CURRENT,\n        ChartStatic::iHighest(Symbol(), PERIOD_CURRENT, MODE_HIGH,\n                              GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd(), GetBarsVisibleShiftEnd()));\n  }\n\n  /**\n   * Returns number of bars that are visible on te screen.\n   */\n  int GetBarsVisibleCount() { return GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd() + 1; }\n\n  /**\n   * Returns absolute x coordinate of bar on the screen. Must not be affected by camera's x offset.\n   */\n  float GetBarPositionX(int _shift) { return -(float)GetBarsVisibleCount() * 1.35f / 2.0f + 1.35f * _shift; }\n\n  /**\n   * Returns y coordinate of price on the screen. Takes into consideration zoom and min/max prices on the screen.\n   */\n  float GetPriceScale(float price) {\n    float _scale_y = 40.0f;\n    float _price_min = GetMinBarsPrice();\n    float _price_max = GetMaxBarsPrice();\n    float _result = 1.0f / (_price_max - _price_min) * (price - _price_min) * _scale_y - (_scale_y / 2);\n    return _result;\n  }\n\n  /**\n   * Renders chart.\n   */\n  void Render(Device* _device) {\n    Chart3DType* _type_renderer = GetRenderer(_device);\n\n    BarOHLC _ohlc;\n    // BarOHLC _ohlc = price_fetcher(PERIOD_CURRENT, 0);  // @fixme: 'price_fetcher' - internal error #%d\n\n#ifdef __debug__\n    Print(SerializerConverter::FromObject(_ohlc).ToString<SerializerJson>());\n#endif\n\n    _type_renderer.Render(_device);\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D Chart.\n */\n\n#include \"../Bar.struct.h\"\n#include \"../Indicators/Indi_MA.mqh\"\n#include \"../Instances.h\"\n#include \"../Refs.mqh\"\n#include \"../SerializerConverter.mqh\"\n#include \"../SerializerJson.mqh\"\n#include \"Chart3DCandles.h\"\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Interface.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/chart3d_vs.hlsl\" as string Chart3DShaderSourceVS;\n#resource \"Shaders/chart3d_ps.hlsl\" as string Chart3DShaderSourcePS;\n#endif\n\ntypedef BarOHLC (*Chart3DPriceFetcher)(ENUM_TIMEFRAMES, int);\n\n// Type of the currently rendered 3d chart.\nenum ENUM_CHART3D_TYPE {\n  CHART3D_TYPE_BARS,\n  CHART3D_TYPE_CANDLES,\n  CHART3D_TYPE_LINES,\n};\n\nclass Chart3D;\n\nvoid chart3d_interface_listener(InterfaceEvent& _event, void* _target) {\n  Chart3D* chart3d = (Chart3D*)_target;\n  chart3d.OnInterfaceEvent(_event);\n}\n\n/**\n * 3D chart renderer.\n */\nclass Chart3D : public Dynamic {\n  // Camera offset. Z component indicates number of bars per screen's width.\n  DXVector3 offset;\n\n  // Current chart type.\n  ENUM_CHART3D_TYPE type;\n\n  // References to chart type renderers.\n  Ref<Chart3DType> renderers[3];\n\n  // OHLC prices fetcher callback.\n  Chart3DPriceFetcher price_fetcher;\n\n  // Whether graphics were initialized.\n  bool initialized;\n\n  // Shaders.\n  Ref<Shader> shader_vs;\n  Ref<Shader> shader_ps;\n\n  Chart3DType* current_renderer;\n\n  Instances<Chart3D> instances;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3D(Chart3DPriceFetcher _price_fetcher, ENUM_CHART3D_TYPE _type = CHART3D_TYPE_CANDLES) : instances(&this) {\n    price_fetcher = _price_fetcher;\n    type = _type;\n    offset.x = offset.y = 0.0f;\n    offset.z = 25.0f;\n    initialized = false;\n#ifdef __MQL5__\n    Interface::AddListener(chart3d_interface_listener, &this);\n#endif\n  }\n\n  void OnInterfaceEvent(InterfaceEvent& _event) {\n    if (GetCurrentRenderer() == NULL) {\n      return;\n    }\n\n    Device* _gfx = GetCurrentRenderer().GetDevice();\n\n    _gfx.DrawText(10, 10, \"Event!\");\n  }\n\n  Shader* GetShaderVS() { return shader_vs.Ptr(); }\n\n  Shader* GetShaderPS() { return shader_ps.Ptr(); }\n\n  Chart3DType* GetCurrentRenderer() { return current_renderer; }\n\n  Chart3DType* GetRenderer(Device* _device) {\n    if (!initialized) {\n      // shader_vs = _device.VertexShader(Chart3DShaderSourceVS, Vertex::Layout);\n      // shader_ps = _device.PixelShader(Chart3DShaderSourcePS);\n      initialized = true;\n    }\n\n    if (!renderers[type].IsSet()) {\n      switch (type) {\n        case CHART3D_TYPE_BARS:\n          // renderers[type] = new Chart3DBars(_device);\n          break;\n        case CHART3D_TYPE_CANDLES:\n          renderers[type] = new Chart3DCandles(&this, _device);\n          break;\n        case CHART3D_TYPE_LINES:\n          // renderers[type] = new Chart3DLines(_device);\n          break;\n        default:\n          Alert(\"Internal error: Wrong type for Chart3D in Chart3D::GetRenderer()!\");\n          DebugBreak();\n          return NULL;\n      }\n    }\n\n    current_renderer = renderers[type].Ptr();\n\n    return renderers[type].Ptr();\n  }\n\n  /**\n   * Returns given bar's OHLC.\n   */\n  BarOHLC GetPrice(ENUM_TIMEFRAMES _tf, int _shift) {\n    BarOHLC _ohlc;\n    return _ohlc;\n    // return price_fetcher(_tf, _shift); // @fixme: 'price_fetcher' - internal error #%d\n  }\n\n  /**\n   * Return first shift that are visible on the screen. Values is away from 0.\n   */\n  int GetBarsVisibleShiftStart() { return 80; }\n\n  /**\n   * Return last shift that are visible on the screen. Value is closer to 0.\n   */\n  int GetBarsVisibleShiftEnd() { return 0; }\n\n  /**\n   * Returns lowest price of bars on the screen.\n   */\n  float GetMinBarsPrice() {\n    return (float)ChartStatic::iLow(\n        Symbol(), PERIOD_CURRENT,\n        ChartStatic::iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd(),\n                             GetBarsVisibleShiftEnd()));\n  }\n\n  /**\n   * Returns highest price of bars on the screen.\n  "
  },
  {
    "filename": "Chart3DCandles.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart candles renderer.\n */\n\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Vertex.h\"\n\nclass Chart3D;\n\n/**\n * 3D chart candles renderer.\n */\nclass Chart3DCandles : public Chart3DType {\n  Ref<Cube<Vertex>> cube1;\n  Ref<Cube<Vertex>> cube2;\n  Ref<Cube<Vertex>> cube3;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DCandles(Chart3D* _chart3d, Device* _device) : Chart3DType(_chart3d, _device) {\n    cube1 = new Cube<Vertex>(1.0f, 1.0f, 1.0f);\n    cube2 = new Cube<Vertex>(0.10f, 1.0f, 0.10f);\n    cube3 = new Cube<Vertex>(1.0f, 0.075f, 0.075f);\n  }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {\n    TSR _tsr;\n\n    for (int _shift = chart3d.GetBarsVisibleShiftStart(); _shift != chart3d.GetBarsVisibleShiftEnd(); --_shift) {\n      BarOHLC _ohlc = chart3d.GetPrice(PERIOD_CURRENT, _shift);\n\n      float _height = chart3d.GetPriceScale(_ohlc.GetMaxOC()) - chart3d.GetPriceScale(_ohlc.GetMinOC());\n      float higher = _ohlc.IsBear();\n\n      cube1.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      cube1.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetMinOC()) + _height / 2;\n      cube1.Ptr().GetTSR().scale.y = _height;\n\n      // Print(cube1.Ptr().GetTSR().translation.y);\n\n      cube1.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube1.Ptr());\n\n      cube2.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      float _line_height = chart3d.GetPriceScale(_ohlc.GetHigh()) - chart3d.GetPriceScale(_ohlc.GetLow());\n      cube2.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetLow()) + _line_height / 2;\n      cube2.Ptr().GetTSR().scale.y = _line_height;\n      cube2.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube2.Ptr());\n    }\n\n    int _digits = (int)MarketInfo(Symbol(), MODE_DIGITS);\n    float _pip_pow = (float)MathPow(10, _digits);\n    float _pip_size = 1.0f / (float)MathPow(10, _digits);\n    float _pip_size_m1 = 1.0f / (float)MathPow(10, _digits - 1);\n    float _start = float(int(chart3d.GetMinBarsPrice() * _pip_pow) * _pip_size);\n    float _end = float(int(chart3d.GetMaxBarsPrice() * _pip_pow) * _pip_size);\n\n    // Rendering price lines.\n    for (double _s = _start; _s < _end + _pip_size_m1; _s += _pip_size * 10) {\n      float _y = chart3d.GetPriceScale((float)_s);\n\n      cube3.Ptr().GetTSR().translation.y = _y;\n      cube3.Ptr().GetTSR().scale.x = 200.0f;\n\n      _device.DrawText(5, _y, StringFormat(\"%.\" + IntegerToString(_digits) + \"f\", _s), 0x90FFFFFF, TA_LEFT | TA_VCENTER,\n                       GFX_DRAW_TEXT_FLAG_2D_COORD_X);\n\n      cube3.Ptr().GetMaterial().SetColor(0x333333);\n      _device.Render(cube3.Ptr());\n    }\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart candles renderer.\n */\n\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Vertex.h\"\n\nclass Chart3D;\n\n/**\n * 3D chart candles renderer.\n */\nclass Chart3DCandles : public Chart3DType {\n  Ref<Cube<Vertex>> cube1;\n  Ref<Cube<Vertex>> cube2;\n  Ref<Cube<Vertex>> cube3;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DCandles(Chart3D* _chart3d, Device* _device) : Chart3DType(_chart3d, _device) {\n    cube1 = new Cube<Vertex>(1.0f, 1.0f, 1.0f);\n    cube2 = new Cube<Vertex>(0.10f, 1.0f, 0.10f);\n    cube3 = new Cube<Vertex>(1.0f, 0.075f, 0.075f);\n  }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {\n    TSR _tsr;\n\n    for (int _shift = chart3d.GetBarsVisibleShiftStart(); _shift != chart3d.GetBarsVisibleShiftEnd(); --_shift) {\n      BarOHLC _ohlc = chart3d.GetPrice(PERIOD_CURRENT, _shift);\n\n      float _height = chart3d.GetPriceScale(_ohlc.GetMaxOC()) - chart3d.GetPriceScale(_ohlc.GetMinOC());\n      float higher = _ohlc.IsBear();\n\n      cube1.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      cube1.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetMinOC()) + _height / 2;\n      cube1.Ptr().GetTSR().scale.y = _height;\n\n      // Print(cube1.Ptr().GetTSR().translation.y);\n\n      cube1.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube1.Ptr());\n\n      cube2.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      float _line_height = chart3d.GetPriceScale(_ohlc.GetHigh()) - chart3d.GetPriceScale(_ohlc.GetLow());\n      cube2.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetLow()) + _line_height / 2;\n      cube2.Ptr().GetTSR().scale.y = _line_height;\n      cube2.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube2.Ptr());\n    }\n\n    int _digits = (int)MarketInfo(Symbol(), MODE_DIGITS);\n    float _pip_pow = (float)MathPow(10, _digits);\n    float _pip_size = 1.0f / (float)MathPow(10, _digits);\n    float _pip_size_m1 = 1.0f / (float)MathPow(10, _digits - 1);\n    float _start = float(int(chart3d.GetMinBarsPrice() * _pip_pow) * _pip_size);\n    float _end = float(int(chart3d.GetMaxBarsPrice() * _pip_pow) * _pip_size);\n\n    // Rendering price lines.\n    for (double _s = _start; _s < _end + _pip_size_m1; _s += _pip_size * 10) {\n      float _y = chart3d.GetPriceScale((float)_s);\n\n      cube3.Ptr().GetTSR().translation.y = _y;\n      cube3.Ptr().GetTSR().scale.x = 200.0f;\n\n      _device.DrawText(5, _y, StringFormat(\"%.\" + IntegerToString(_digits) + \"f\", _s), 0x90FFFFFF, TA_LEFT | TA_VCENTER,\n                       GFX_DRAW_TEXT_FLAG_2D_COORD_X);\n\n      cube3.Ptr().GetMaterial().SetColor(0x333333);\n      _device.Render(cube3.Ptr());\n    }\n  }\n};\n"
  },
  {
    "filename": "MT5Frontend.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MT5 graphics front-end (display buffer target).\n */\n\n#include \"../Frontend.h\"\n\n/**\n * MetaTrader 5 chart target.\n */\nclass MT5Frontend : public Frontend {\n  // Target image pixel buffer.\n  unsigned int image[];\n\n  // Previous size of the window.\n  int last_width, last_height;\n\n  // Target image's resource name.\n  string resname;\n\n  // Target image's object name.\n  string objname;\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() {\n    // Hiding 2D chart.\n    ChartSetInteger(0, CHART_SHOW, false);\n    ChartRedraw();\n\n#ifdef __debug__\n    Print(\"MT5 Frontend: LastError: \", GetLastError());\n#endif\n\n    objname = \"MT5_Frontend_\" + IntegerToString(ChartID());\n    resname = \"::MT5_Frontend\" + IntegerToString(ChartID());\n    ObjectCreate(0, objname, OBJ_BITMAP_LABEL, 0, 0, 0);\n    ObjectSetInteger(0, objname, OBJPROP_XDISTANCE, 0);\n    ObjectSetInteger(0, objname, OBJPROP_YDISTANCE, 0);\n#ifdef __debug__\n    Print(\"MT5 Frontend: ObjectCreate/Set: LastError: \", GetLastError());\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n#endif\n    ObjectSetString(ChartID(), objname, OBJPROP_BMPFILE, resname);\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() {\n    ResourceFree(resname);\n    ObjectDelete(0, objname);\n    ChartSetInteger(0, CHART_SHOW, true);\n    ChartRedraw();\n    return true;\n  }\n\n  /**\n   * Resizes target image buffer if needed.\n   */\n  bool Resize() {\n    if (Width() == last_width && Height() == last_height) {\n      return false;\n    }\n\n    ArrayResize(image, Width() * Height());\n#ifdef __debug__\n    Print(\"resname = \", resname, \", image_size = \", ArraySize(image), \", width = \", Width(), \", height = \", Height());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n\n    last_width = Width();\n    last_height = Height();\n\n    return true;\n  }\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderBegin()\");\n    Print(\"Image resize: width = \", Width(), \", height = \", Height());\n#endif\n\n    if (Resize()) {\n      DXContextSetSize(context, Width(), Height());\n    }\n\n#ifdef __debug__\n    Print(\"DXContextSetSize: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderEnd()\");\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n    Print(\"MT5Frontend: DXContextGetColors()\");\n#endif\n    DXContextGetColors(context, image);\n    ProcessDrawText();\n#ifdef __debug__\n    Print(\"DXContextGetColors: LastError: \", GetLastError());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n    ChartRedraw();\n    Sleep(1);\n  }\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() { return (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS); }\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() { return (int)ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS); }\n\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    TextSetFont(\"Arial\", -80, FW_EXTRABOLD, 0);\n#ifdef __debug__\n    Print(\"TextSetFont: LastError = \", GetLastError());\n#endif\n\n    TextOut(_text, _x, _y, _align, image, Width(), Height(), _color, COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"TextOut: LastError = \", GetLastError());\n#endif\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MT5 graphics front-end (display buffer target).\n */\n\n#include \"../Frontend.h\"\n\n/**\n * MetaTrader 5 chart target.\n */\nclass MT5Frontend : public Frontend {\n  // Target image pixel buffer.\n  unsigned int image[];\n\n  // Previous size of the window.\n  int last_width, last_height;\n\n  // Target image's resource name.\n  string resname;\n\n  // Target image's object name.\n  string objname;\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() {\n    // Hiding 2D chart.\n    ChartSetInteger(0, CHART_SHOW, false);\n    ChartRedraw();\n\n#ifdef __debug__\n    Print(\"MT5 Frontend: LastError: \", GetLastError());\n#endif\n\n    objname = \"MT5_Frontend_\" + IntegerToString(ChartID());\n    resname = \"::MT5_Frontend\" + IntegerToString(ChartID());\n    ObjectCreate(0, objname, OBJ_BITMAP_LABEL, 0, 0, 0);\n    ObjectSetInteger(0, objname, OBJPROP_XDISTANCE, 0);\n    ObjectSetInteger(0, objname, OBJPROP_YDISTANCE, 0);\n#ifdef __debug__\n    Print(\"MT5 Frontend: ObjectCreate/Set: LastError: \", GetLastError());\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n#endif\n    ObjectSetString(ChartID(), objname, OBJPROP_BMPFILE, resname);\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() {\n    ResourceFree(resname);\n    ObjectDelete(0, objname);\n    ChartSetInteger(0, CHART_SHOW, true);\n    ChartRedraw();\n    return true;\n  }\n\n  /**\n   * Resizes target image buffer if needed.\n   */\n  bool Resize() {\n    if (Width() == last_width && Height() == last_height) {\n      return false;\n    }\n\n    ArrayResize(image, Width() * Height());\n#ifdef __debug__\n    Print(\"resname = \", resname, \", image_size = \", ArraySize(image), \", width = \", Width(), \", height = \", Height());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n\n    last_width = Width();\n    last_height = Height();\n\n    return true;\n  }\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderBegin()\");\n    Print(\"Image resize: width = \", Width(), \", height = \", Height());\n#endif\n\n    if (Resize()) {\n      DXContextSetSize(context, Width(), Height());\n    }\n\n#ifdef __debug__\n    Print(\"DXContextSetSize: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderEnd()\");\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n    Print(\"MT5Frontend: DXContextGetColors()\");\n#endif\n    DXContextGetColors(context, image);\n    ProcessDrawText();\n#ifdef __debug__\n    Print(\"DXContextGetColors: LastError: \", GetLastError());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n    ChartRedraw();\n    Sleep(1);\n  }\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() { return (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS); }\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() { return (int)ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS); }\n\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    TextSetFont(\"Arial\", -80, FW_EXTRABOLD, 0);\n#ifdef __debug__\n    Print(\"TextSetFont: LastError = \", GetLastError());\n#endif\n\n    TextOut(_text, _x, _y, _align, image, Width(), Height(), _color, COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"TextOut: LastError = \", GetLastError());\n#endif\n  }\n};\n"
  },
  {
    "filename": "MTDXDevice.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device.\n */\n\n#include \"../../Device.h\"\n\nclass MTDXDevice : public Device {\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Init(Frontend* _frontend) {\n#ifdef __debug__\n    Print(\"MTDXDevice: DXContextCreate: width = \", _frontend.Width(), \", height = \", _frontend.Height());\n#endif\n    context = DXContextCreate(_frontend.Width(), _frontend.Height());\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n    Print(\"MTDXDevice: context = \", context);\n#endif\n    _frontend.Init();\n    return true;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  bool Deinit() {\n    DXRelease(context);\n    return true;\n  }\n\n  /**\n   * Starts rendering loop.\n   */\n  virtual bool RenderBegin() { return true; }\n\n  /**\n   * Ends rendering loop.\n   */\n  virtual bool RenderEnd() { return true; }\n\n  /**\n   * Returns DX context's id.\n   */\n  int Context() { return context; }\n\n  /**\n   * Clears color buffer.\n   */\n  /**\n   * Clears color buffer.\n   */\n  virtual void ClearBuffer(ENUM_CLEAR_BUFFER_TYPE _type, unsigned int _color = 0x000000) {\n    if (_type == CLEAR_BUFFER_TYPE_COLOR) {\n      DXVector _dx_color;\n      _dx_color.x = 1.0f / 255.0f * ((_color & 0x00FF0000) >> 16);\n      _dx_color.y = 1.0f / 255.0f * ((_color & 0x0000FF00) >> 8);\n      _dx_color.z = 1.0f / 255.0f * ((_color & 0x000000FF) >> 0);\n      _dx_color.w = 1.0f / 255.0f * ((_color & 0xFF000000) >> 24);\n      DXContextClearColors(context, _dx_color);\n#ifdef __debug__\n      Print(\"DXContextClearColors: LastError: \", GetLastError());\n#endif\n    } else if (_type == CLEAR_BUFFER_TYPE_DEPTH) {\n      DXContextClearDepth(context);\n#ifdef __debug__\n      Print(\"DXContextClearDepth: LastError: \", GetLastError());\n#endif\n    }\n  }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  IndexBuffer* IndexBuffer() { return NULL; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[], string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_VS, _source_code, _entry_point);\n    _shader.SetDataLayout(_layout);\n    return _shader;\n  }\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_PS, _source_code, _entry_point);\n    return _shader;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  VertexBuffer* VertexBuffer() { return new MTDXVertexBuffer(&this); }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) {\n    IndexBuffer* _buffer = new MTDXIndexBuffer(&this);\n    _buffer.Fill(_indices);\n    return _buffer;\n  }\n\n  /**\n   *\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) {\n    DXPrimiveTopologySet(context, DX_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    _vertices.Select();\n    if (_indices == NULL) {\n      if (!DXDraw(context)) {\n#ifdef __debug__\n        Print(\"Can't draw!\");\n#endif\n      }\n#ifdef __debug__\n      Print(\"DXDraw: LastError: \", GetLastError());\n#endif\n    } else {\n      _indices.Select();\n      DXDrawIndexed(context);\n#ifdef __debug__\n      Print(\"DXDrawIndexed: LastError: \", GetLastError());\n#endif\n    }\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device.\n */\n\n#include \"../../Device.h\"\n\nclass MTDXDevice : public Device {\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Init(Frontend* _frontend) {\n#ifdef __debug__\n    Print(\"MTDXDevice: DXContextCreate: width = \", _frontend.Width(), \", height = \", _frontend.Height());\n#endif\n    context = DXContextCreate(_frontend.Width(), _frontend.Height());\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n    Print(\"MTDXDevice: context = \", context);\n#endif\n    _frontend.Init();\n    return true;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  bool Deinit() {\n    DXRelease(context);\n    return true;\n  }\n\n  /**\n   * Starts rendering loop.\n   */\n  virtual bool RenderBegin() { return true; }\n\n  /**\n   * Ends rendering loop.\n   */\n  virtual bool RenderEnd() { return true; }\n\n  /**\n   * Returns DX context's id.\n   */\n  int Context() { return context; }\n\n  /**\n   * Clears color buffer.\n   */\n  /**\n   * Clears color buffer.\n   */\n  virtual void ClearBuffer(ENUM_CLEAR_BUFFER_TYPE _type, unsigned int _color = 0x000000) {\n    if (_type == CLEAR_BUFFER_TYPE_COLOR) {\n      DXVector _dx_color;\n      _dx_color.x = 1.0f / 255.0f * ((_color & 0x00FF0000) >> 16);\n      _dx_color.y = 1.0f / 255.0f * ((_color & 0x0000FF00) >> 8);\n      _dx_color.z = 1.0f / 255.0f * ((_color & 0x000000FF) >> 0);\n      _dx_color.w = 1.0f / 255.0f * ((_color & 0xFF000000) >> 24);\n      DXContextClearColors(context, _dx_color);\n#ifdef __debug__\n      Print(\"DXContextClearColors: LastError: \", GetLastError());\n#endif\n    } else if (_type == CLEAR_BUFFER_TYPE_DEPTH) {\n      DXContextClearDepth(context);\n#ifdef __debug__\n      Print(\"DXContextClearDepth: LastError: \", GetLastError());\n#endif\n    }\n  }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  IndexBuffer* IndexBuffer() { return NULL; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[], string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_VS, _source_code, _entry_point);\n    _shader.SetDataLayout(_layout);\n    return _shader;\n  }\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_PS, _source_code, _entry_point);\n    return _shader;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  VertexBuffer* VertexBuffer() { return new MTDXVertexBuffer(&this); }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) {\n    IndexBuffer* _buffer = new MTDXIndexBuffer(&this);\n    _buffer.Fill(_indices);\n    return _buffer;\n  }\n\n  /**\n   *\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) {\n    DXPrimiveTopologySet(context, DX_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    _vertices.Select();\n    if (_indices == NULL) {\n      if (!DXDraw(context)) {\n#ifdef __debug__\n        Print(\"Can't draw!\");\n#endif\n      }\n#ifdef __debug__\n      Print(\"DXDraw: LastError: \", GetLastError());\n#endif\n    } else {\n      _indices.Select();\n      DXDrawIndexed(context);\n#ifdef __debug__\n      Print(\"DXDrawIndexed: LastError: \", GetLastError());\n#endif\n    }\n  }\n};\n"
  },
  {
    "filename": "MTDXIndexBuffer.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device's index buffer.\n */\n\n#include \"../../IndexBuffer.h\"\n\nclass MTDXIndexBuffer : public IndexBuffer {\n public:\n  MTDXIndexBuffer(Device* _device) : IndexBuffer(_device) {}\n\n protected:\n  int handle;\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) {\n    // handle = DXBufferCreate(Device().Context(), DX_BUFFER_INDEX, &_data);\n    return handle != INVALID_HANDLE;\n  }\n\n  /**\n   * Destructor;\n   */\n  ~MTDXIndexBuffer() { DXRelease(handle); }\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_INDEX, _indices);\n  }\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting indices \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device's index buffer.\n */\n\n#include \"../../IndexBuffer.h\"\n\nclass MTDXIndexBuffer : public IndexBuffer {\n public:\n  MTDXIndexBuffer(Device* _device) : IndexBuffer(_device) {}\n\n protected:\n  int handle;\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) {\n    // handle = DXBufferCreate(Device().Context(), DX_BUFFER_INDEX, &_data);\n    return handle != INVALID_HANDLE;\n  }\n\n  /**\n   * Destructor;\n   */\n  ~MTDXIndexBuffer() { DXRelease(handle); }\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_INDEX, _indices);\n  }\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting indices \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n"
  },
  {
    "filename": "MTDXVertexBuffer.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics vertex buffer.\n */\n\n#include \"../../VertexBuffer.h\"\n\nclass MTDXVertexBuffer : public VertexBuffer {\n  int handle;\n\n public:\n  MTDXVertexBuffer(Device* _device) : VertexBuffer(_device) {}\n\n  ~MTDXVertexBuffer() {\n    // DXRelease(handle);\n  }\n\n public:\n  /**\n   * Creates vertex buffer.\n   */\n  template <typename X>\n  bool Fill(X& _data[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_VERTEX, _data);\n#ifdef __debug__\n    Print(\"Created vb \", handle);\n    Print(\"Fill: LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting vb \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics vertex buffer.\n */\n\n#include \"../../VertexBuffer.h\"\n\nclass MTDXVertexBuffer : public VertexBuffer {\n  int handle;\n\n public:\n  MTDXVertexBuffer(Device* _device) : VertexBuffer(_device) {}\n\n  ~MTDXVertexBuffer() {\n    // DXRelease(handle);\n  }\n\n public:\n  /**\n   * Creates vertex buffer.\n   */\n  template <typename X>\n  bool Fill(X& _data[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_VERTEX, _data);\n#ifdef __debug__\n    Print(\"Created vb \", handle);\n    Print(\"Fill: LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting vb \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n"
  },
  {
    "filename": "MTDXShader.h",
    "source_type": "KOD",
    "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted unversal graphics shader.\n */\n\n#include \"../../Shader.h\"\n\nclass MTDXShader : public Shader {\n  // DX context handle.\n  int handle;\n\n  // DX MVP's C-Buffer handle (register b0).\n  int cbuffer_mvp_handle;\n\n  MVPBuffer mvp_buffer;\n\n  // DX C-Buffer handle. (register b1).\n  int cbuffer_handle;\n\n public:\n  /**\n   * Constructor.\n   */\n  MTDXShader(Device* _device) : Shader(_device) {}\n\n  /**\n   * Destructor.\n   */\n  ~MTDXShader() {\n    DXRelease(cbuffer_handle);\n    DXRelease(cbuffer_mvp_handle);\n    DXRelease(handle);\n  }\n\n  /**\n   * Creates a shader.\n   */\n  bool Create(ENUM_SHADER_TYPE _type, string _source_code, string _entry_point = \"main\") {\n    string error_text;\n\n    handle = DXShaderCreate(GetDevice().Context(), _type == SHADER_TYPE_VS ? DX_SHADER_VERTEX : DX_SHADER_PIXEL,\n                            _source_code, _entry_point, error_text);\n\n#ifdef __debug__\n    Print(\"DXShaderCreate: LastError: \", GetLastError(), \", ErrorText: \", error_text);\n#endif\n\n    cbuffer_handle = 0;\n\n    // Creating MVP buffer.\n    cbuffer_mvp_handle = DXInputCreate(GetDevice().Context(), sizeof(MVPBuffer));\n#ifdef __debug__\n    Print(\"DXInputCreate (mvp): LastError: \", GetLastError());\n#endif\n\n    return true;\n  }\n\n  /**\n   * Sets vertex/pixel data layout to be used by shader.\n   */\n  virtual void SetDataLayout(const ShaderVertexLayout& _layout[]) {\n    // Converting generic layout into MT5 DX's one.\n\n    DXVertexLayout _target_layout[];\n    ArrayResize(_target_layout, ArraySize(_layout));\n\n#ifdef __debug__\n    Print(\"ArrayResize: LastError: \", GetLastError());\n#endif\n\n    int i;\n\n    for (i = 0; i < ArraySize(_layout); ++i) {\n      _target_layout[i].semantic_name = _layout[i].name;\n      _target_layout[i].semantic_index = _layout[i].index;\n      _target_layout[i].format = ParseFormat(_layout[i]);\n    }\n\n#ifdef __debug__\n    for (i = 0; i < ArraySize(_target_layout); ++i) {\n      Print(_target_layout[i].semantic_name, \", \", _target_layout[i].semantic_index, \", \",\n            EnumToString(_target_layout[i].format));\n    }\n\n    Print(\"before DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    DXShaderSetLayout(handle, _target_layout);\n\n#ifdef __debug__\n    Print(\"DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    ResetLastError();\n  }\n\n#ifdef __MQL5__\n  /**\n   * Converts vertex layout's item into required DX's color format.\n   */\n  ENUM_DX_FORMAT ParseFormat(const ShaderVertexLayout& _layout) {\n    if (_layout.type == GFX_VAR_TYPE_FLOAT) {\n      switch (_layout.num_components) {\n        case 1:\n          return DX_FORMAT_R32_FLOAT;\n        case 2:\n          return DX_FORMAT_R32G32_FLOAT;\n        case 3:\n          return DX_FORMAT_R32G32B32_FLOAT;\n        case 4:\n          return DX_FORMAT_R32G32B32A32_FLOAT;\n        default:\n          Alert(\"Too many components in vertex layout!\");\n      }\n    }\n\n    Alert(\"Wrong vertex layout!\");\n    return (ENUM_DX_FORMAT)0;\n  }\n#endif\n\n  /**\n   * Sets custom input buffer for shader.\n   */\n  template <typename X>\n  void SetCBuffer(const X& data) {\n    if (cbuffer_handle == 0) {\n      cbuffer_handle = DXInputCreate(GetDevice().Context(), sizeof(X));\n#ifdef __debug__\n      Print(\"DXInputCreate: LastError: \", GetLastError());\n#endif\n\n      int _input_handles[1];\n      _input_handles[0] = cbuffer_handle;\n\n      DXShaderInputsSet(handle, _input_handles);\n#ifdef __debug__\n      Print(\"DXShaderInputsSet: LastError: \", GetLastError());\n#endif\n    }\n\n    DXInputSet(cbuffer_handle, data);\n#ifdef __debug__\n    Print(\"DXInputSet: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Selectes shader to be used by graphics device for rendering.\n   */\n  virtual void Select() {\n    // Setting MVP transform and material information.\n\n    DXMatrixTranspose(mvp_buffer.world, GetDevice().GetWorldMatrix());\n    DXMatrixTranspose(mvp_buffer.view, GetDevice().GetViewMatrix());\n    DXMatrixTranspose(mvp_buffer.projection, GetDevice().GetProjectionMatrix());\n    mvp_buffer.lightdir = GetDevice().GetLightDirection();\n    mvp_buffer.mat_color = GetDevice().GetMaterial().Color;\n\n    if (cbuffer_handle == 0) {\n      int _input_handles[1];\n      _input_handles[0] = cbuffer_mvp_handle;\n      DXShaderInputsSet(handle, _input_handles);\n    } else {\n      int _input_handles[2];\n      _input_handles[0] = cbuffer_mvp_handle;\n      _input_handles[1] = cbuffer_handle;\n      DXShaderInputsSet(handle, _input_handles);\n    }\n\n#ifdef __debug__\n    Print(\"DXShaderInputsSet: LastError: \", GetLastError());\n#endif\n\n    DXInputSet(cbuffer_mvp_handle, mvp_buffer);\n    DXShaderSet(GetDevice().Context(), handle);\n  }\n};\n",
    "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted unversal graphics shader.\n */\n\n#include \"../../Shader.h\"\n\nclass MTDXShader : public Shader {\n  // DX context handle.\n  int handle;\n\n  // DX MVP's C-Buffer handle (register b0).\n  int cbuffer_mvp_handle;\n\n  MVPBuffer mvp_buffer;\n\n  // DX C-Buffer handle. (register b1).\n  int cbuffer_handle;\n\n public:\n  /**\n   * Constructor.\n   */\n  MTDXShader(Device* _device) : Shader(_device) {}\n\n  /**\n   * Destructor.\n   */\n  ~MTDXShader() {\n    DXRelease(cbuffer_handle);\n    DXRelease(cbuffer_mvp_handle);\n    DXRelease(handle);\n  }\n\n  /**\n   * Creates a shader.\n   */\n  bool Create(ENUM_SHADER_TYPE _type, string _source_code, string _entry_point = \"main\") {\n    string error_text;\n\n    handle = DXShaderCreate(GetDevice().Context(), _type == SHADER_TYPE_VS ? DX_SHADER_VERTEX : DX_SHADER_PIXEL,\n                            _source_code, _entry_point, error_text);\n\n#ifdef __debug__\n    Print(\"DXShaderCreate: LastError: \", GetLastError(), \", ErrorText: \", error_text);\n#endif\n\n    cbuffer_handle = 0;\n\n    // Creating MVP buffer.\n    cbuffer_mvp_handle = DXInputCreate(GetDevice().Context(), sizeof(MVPBuffer));\n#ifdef __debug__\n    Print(\"DXInputCreate (mvp): LastError: \", GetLastError());\n#endif\n\n    return true;\n  }\n\n  /**\n   * Sets vertex/pixel data layout to be used by shader.\n   */\n  virtual void SetDataLayout(const ShaderVertexLayout& _layout[]) {\n    // Converting generic layout into MT5 DX's one.\n\n    DXVertexLayout _target_layout[];\n    ArrayResize(_target_layout, ArraySize(_layout));\n\n#ifdef __debug__\n    Print(\"ArrayResize: LastError: \", GetLastError());\n#endif\n\n    int i;\n\n    for (i = 0; i < ArraySize(_layout); ++i) {\n      _target_layout[i].semantic_name = _layout[i].name;\n      _target_layout[i].semantic_index = _layout[i].index;\n      _target_layout[i].format = ParseFormat(_layout[i]);\n    }\n\n#ifdef __debug__\n    for (i = 0; i < ArraySize(_target_layout); ++i) {\n      Print(_target_layout[i].semantic_name, \", \", _target_layout[i].semantic_index, \", \",\n            EnumToString(_target_layout[i].format));\n    }\n\n    Print(\"before DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    DXShaderSetLayout(handle, _target_layout);\n\n#ifdef __debug__\n    Print(\"DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    ResetLastError();\n  }\n\n#ifdef __MQL5__\n  /**\n   * Converts vertex layout's item into required DX's color format.\n   */\n  ENUM_DX_FORMAT ParseFormat(const ShaderVertexLayout& _layout) {\n    if (_layout.type == GFX_VAR_TYPE_FLOAT) {\n      switch (_layout.num_components) {\n        case 1:\n          return DX_FORMAT_R32_FLOAT;\n        case 2:\n          return DX_FORMAT_R32G32_FLOAT;\n        case 3:\n          return DX_FORMAT_R32G32B32_FLOAT;\n        case 4:\n          return DX_FORMAT_R32G32B32A32_FLOAT;\n        default:\n          Alert(\"Too many components in vertex layout!\");\n      }\n    }\n\n    Alert(\"Wrong vertex layout!\");\n    return (ENUM_DX_FORMAT)0;\n  }\n#endif\n\n  /**\n   * Sets custom input buffer for shader.\n   */\n  template <typename X>\n  void SetCBuffer(const X& data) {\n    if (cbuffer_handle == 0) {\n      cbuffer_handle = DXInputCreate(GetDevice().Context(), sizeof(X));\n#ifdef __debug__\n      Print(\"DXInputCreate: LastError: \", GetLastError());\n#endif\n\n      int _input_handles[1];\n      _input_handles[0] = cbuffer_handle;\n\n      DXShaderInputsSet(handle, _input_handles);\n#ifdef __debug__\n      Print(\"DXShaderInputsSet: LastError: \", GetLastError());\n#endif\n    }\n\n    DXInputSet(cbuffer_handle, data);\n#ifdef __debug__\n    Print(\"DXInputSet: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Selectes shader to be used by graphics device for rendering.\n   */\n  virtual void Select() {\n    // Setting MVP transform and material information.\n\n    DXMatrixTranspose(mvp_buffer.world, GetDevice().GetWorldMatrix());\n    DXMatrixTranspose(mvp_buffer.view, GetDevice().GetViewMatrix());\n    DXMatrixTranspose(mvp_buffer.projection, GetDevice().GetProjectionMatrix());\n    mvp_buf"
  }
]