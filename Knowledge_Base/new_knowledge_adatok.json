[{"filename": "README.md", "path": "new_knowledge/Algorithmic-Trading-main/README.md", "content": "# Algorithmic-Trading\n\nScripts of algorithmic trading systems/strategies in the MQL5 language supported by Metatrader 5. These strategies are purely quantitative strategies applied to Forex markets.\n", "search_content": "# Algorithmic-Trading\n\nScripts of algorithmic trading systems/strategies in the MQL5 language supported by Metatrader 5. These strategies are purely quantitative strategies applied to Forex markets.\n"}, {"filename": "System1.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Single-Strategy-System/System1.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                     System_1.mq5 |\n//|                                                     Spencer Luck |\n//+------------------------------------------------------------------+\n\n// Importing files to use methods\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n\n// Object CTrade as trade\nCTrade trade;\n// Object CPositionInfo as pos_info\nCPositionInfo pos_info;\n\n// Inputs\ninput int JTPO_period = 27;\ninput int JTPO_price = 0;\ninput int Wad_fast_MA = 22;\ninput int Wad_slow_MA = 35;\ninput int Wad_bollinger = 20;\ninput int Wad_bollinger_dev = 2;\ninput int Wad_sens = 150;\ninput int Wad_DZP = 3000;\ninput int Schaff_period = 50;\ninput int Schaff_fast_EMA = 10;\ninput int Schaff_slow_EMA = 15;\ninput int Schaff_smooth = 3;\ninput int Schaff_price = 0;\ninput int MA_period = 6;\ninput ENUM_MA_METHOD MA_mode=MODE_SMA;\ninput int Oscar_period = 7;\ninput int Oscar_signal_period = 11;\n\n// position modifier count\nint positionmodifiercount = 0;\n\nint OnInit()\n  {\n   \n   return(INIT_SUCCEEDED);\n  }\n\nvoid OnDeinit(const int reason)\n  {\n\n  }\n\nvoid OnTick()\n  {\n\n// Restrict code to process only once per bar\n   static datetime timestamp;\n   datetime time = iTime(_Symbol,PERIOD_CURRENT,0); // Time of current candle\n   if(timestamp != time)\n     {\n      timestamp = time;\n\n\n      //ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //J_TPO\n      static int HandleJTPO = iCustom(_Symbol,PERIOD_CURRENT,\"j_tpo\",JTPO_period,JTPO_price);\n      double JTPOArray[];\n      CopyBuffer(HandleJTPO,0,1,2,JTPOArray);\n      ArraySetAsSeries(JTPOArray,true);\n      //Waddah Attar Explosion\n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",Wad_fast_MA,Wad_slow_MA,Wad_bollinger,Wad_bollinger_dev,Wad_sens,Wad_DZP,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // Candle Ratio\n      static int HandleSchaff = iCustom(_Symbol,PERIOD_CURRENT,\"Schaff Trend Cycle\",Schaff_period,Schaff_fast_EMA,Schaff_slow_EMA,Schaff_smooth,Schaff_price);\n      double SchaffArray[];\n      CopyBuffer(HandleSchaff,1,1,2,SchaffArray);\n      ArraySetAsSeries(SchaffArray,true);\n      // Simple Moving Average\n      static int HandleMA = iMA(_Symbol,PERIOD_CURRENT,MA_period,0,MA_mode,PRICE_CLOSE);\n      double ArrayMA [];\n      CopyBuffer(HandleMA,0,1,2,ArrayMA);\n      ArraySetAsSeries(ArrayMA,true);\n      //Oscar\n      static int HandleOscar = iCustom(_Symbol,PERIOD_CURRENT,\"Oscar\",Oscar_period,Oscar_signal_period);\n      //Oscar - Ratio\n      double OscarArray[];\n      CopyBuffer(HandleOscar,0,1,2,OscarArray);\n      ArraySetAsSeries(OscarArray,true);\n      //Oscar - Signal\n      double SignalArray[];\n      CopyBuffer(HandleOscar,1,1,2,SignalArray);\n      ArraySetAsSeries(SignalArray,true);\n\n\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n\n      // Buy conditions\n      bool JTPO_buy = (JTPOArray[0] > 0 && JTPOArray[1] < 0);\n      bool Schaff_buy = (SchaffArray[0] == 1);\n      bool MA_buy = (ArrayMA[0] < CloseArray[0]);\n      bool Oscar_buy = (OscarArray[0] > SignalArray[0]);\n\n\n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n      // Sell conditions\n      bool JTPO_sell = (JTPOArray[0] < 0 && JTPOArray[1] > 0);\n      bool Schaff_sell = (SchaffArray[0] == 2);\n      bool MA_sell = (ArrayMA[0] > CloseArray[0]);\n      bool Oscar_sell = (OscarArray[0] < SignalArray[0]);\n\n\n      // Exit conditions\n      bool Oscar_sell_exit = (OscarArray[0] > SignalArray[0] && OscarArray[1] < SignalArray[1]);\n      bool Oscar_buy_exit = (OscarArray[0] < SignalArray[0] && OscarArray[1] > SignalArray[1]);\n\n\n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  \n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; \n              }\n        }\n\n\n      // Managing positions, modifying second trade (moving SL)\n      // Checking how many positions are open\n\n      int current_open_positions = PositionsTotal(); // Might cause a problem with live testing.\n       \n      if (current_open_positions == 0 && positionmodifiercount == 1)\n      {\n      positionmodifiercount -= 1 ;\n      }\n       \n      if(Buy_opened && current_open_positions == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(AtrArray[0] * 1.5,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor);\n        }\n\n      if(Sell_opened && current_open_positions == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(AtrArray[0] * 1.5,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor);\n        }\n\n\n      // Exit conditions\n\n      if(Buy_opened && Oscar_buy_exit)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && Oscar_sell_exit)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Buy_opened && JTPO_sell)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && JTPO_buy)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Buy_opened && MA_sell)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && MA_buy)\n        {\n         if(pos_info.Symbol()==Symbol())\n            \n          CloseAllPositions();\n        }\n\n\n      // Placing Buy orders\n      if(JTPO_buy  && Wad_vol && Schaff_buy && MA_buy && Oscar_buy)\n        {\n         Print(\"System 16.5 indicates a buy signal\");\n         \n         // Closing open sell positions\n         if(Sell_opened)\n           {\n            if(pos_info.Symbol()==Symbol())\n               trade.PositionClose(pos_info.Ticket());\n           }\n\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         trade.Buy(Lots,_Symbol,ask,sl,tp,\"Buy1\");\n         trade.Buy(Lots,_Symbol,ask,sl,NULL,\"Buy2\");\n\n        }\n\n      // Placing Sell orders\n      if(JTPO_sell && Wad_vol && Schaff_sell && MA_sell && Oscar_sell)\n        {\n         Print(\"System 16.5 indicates a sell signal\");\n\n\n         // Closing open buy positions\n         if(Buy_opened)\n           {\n            if(pos_info.Symbol()==Symbol())\n               trade.PositionClose(pos_info.Ticket());\n           }\n\n         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         trade.Sell(Lots,_Symbol,bid,sl,tp,\"Sell1\");\n         trade.Sell(Lots,_Symbol,bid,sl,NULL,\"Sell2\");\n\n        }\n\n     }\n\n  }\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopBuy(double ask, double AtrFactor)\n  {\n\n// set the stop loss to 150 points\n   double SL=NormalizeDouble(ask-AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n            // get the ticket number\n            ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n\n            // get position open price\n            double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n\n            // calculate the current stop loss\n            double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n            \n            // Assume a min of 2pips \n            double MinTradeStops = 20*_Point;\n               \n   \n            // Check if stop loss is too close to price or if price has moved back past the open price\n            if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n              {\n               CloseAllPositions();\n              }  \n               \n               \n            else\n               {\n                  // move stop loss to open price, therefore zero loss\n                  if(CurrentStopLoss < PositionOpen && positionmodifiercount == 0)\n                    {\n                     trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                     \n                    }\n                  // if current stop loss is more than 150 points\n                  if(CurrentStopLoss < SL && positionmodifiercount == 1)\n                    {\n                     // move the stop loss\n                     trade.PositionModify(PositionTicket,SL,NULL);\n                    }\n                    \n                  if(positionmodifiercount == 0){\n                     positionmodifiercount += 1;\n                    }\n\n               }\n               \n           }\n        }\n     }\n  }\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopSell(double bid, double AtrFactor)\n  {\n\n// set the stop loss to ATR points\n   double SL=NormalizeDouble(bid+AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n           {\n            // get the ticket number\n            ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n\n            // get position open price\n            double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n\n            // calculate the current stop loss\n            double CurrentStopLoss = PositionGetDouble(POSITION_SL); //works\n            \n            // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n             double MinTradeStops = 20*_Point;\n               \n   \n            // Check if stop loss is too close to price or if price has moved back past the open price\n            if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n              {\n                  CloseAllPositions();\n              }\n\n            \n            else\n               {\n            \n               // move stop loss to open price, therefore zero loss\n               if(CurrentStopLoss > PositionOpen && positionmodifiercount == 0)\n                 {\n                 //Print(CurrentStopLoss);\n                  trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                  \n                 }\n               // if current stop loss is more than ATR points\n               if(CurrentStopLoss > SL && positionmodifiercount == 1)\n                 {\n                  // move the stop loss\n                  trade.PositionModify(PositionTicket,SL,NULL);\n                 }\n                 \n               if(positionmodifiercount == 0){\n                 positionmodifiercount += 1;\n                 }\n\n               }\n \n           }\n        }\n     }\n  }\n\n\n\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CloseAllPositions()\n  {\n\n// Count down until there are no positions left\n   for(int i = PositionsTotal()-1; i>=0; i--)\n     {\n     string symbol=PositionGetSymbol(i); // get the symbol of the position\n     if(_Symbol == symbol)\n     \n     { \n      // Get the position number\n      ulong ticket = PositionGetTicket(i);\n\n      // Close the position\n      trade.PositionClose(ticket);\n      }\n     }\n\n\n  }\n\n//+------------------------------------------------------------------+\n//+------------------------------------------------------------------+\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                     System_1.mq5 |\n//|                                                     Spencer Luck |\n//+------------------------------------------------------------------+\n\n// Importing files to use methods\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n\n// Object CTrade as trade\nCTrade trade;\n// Object CPositionInfo as pos_info\nCPositionInfo pos_info;\n\n// Inputs\ninput int JTPO_period = 27;\ninput int JTPO_price = 0;\ninput int Wad_fast_MA = 22;\ninput int Wad_slow_MA = 35;\ninput int Wad_bollinger = 20;\ninput int Wad_bollinger_dev = 2;\ninput int Wad_sens = 150;\ninput int Wad_DZP = 3000;\ninput int Schaff_period = 50;\ninput int Schaff_fast_EMA = 10;\ninput int Schaff_slow_EMA = 15;\ninput int Schaff_smooth = 3;\ninput int Schaff_price = 0;\ninput int MA_period = 6;\ninput ENUM_MA_METHOD MA_mode=MODE_SMA;\ninput int Oscar_period = 7;\ninput int Oscar_signal_period = 11;\n\n// position modifier count\nint positionmodifiercount = 0;\n\nint OnInit()\n  {\n   \n   return(INIT_SUCCEEDED);\n  }\n\nvoid OnDeinit(const int reason)\n  {\n\n  }\n\nvoid OnTick()\n  {\n\n// Restrict code to process only once per bar\n   static datetime timestamp;\n   datetime time = iTime(_Symbol,PERIOD_CURRENT,0); // Time of current candle\n   if(timestamp != time)\n     {\n      timestamp = time;\n\n\n      //ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //J_TPO\n      static int HandleJTPO = iCustom(_Symbol,PERIOD_CURRENT,\"j_tpo\",JTPO_period,JTPO_price);\n      double JTPOArray[];\n      CopyBuffer(HandleJTPO,0,1,2,JTPOArray);\n      ArraySetAsSeries(JTPOArray,true);\n      //Waddah Attar Explosion\n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",Wad_fast_MA,Wad_slow_MA,Wad_bollinger,Wad_bollinger_dev,Wad_sens,Wad_DZP,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // Candle Ratio\n      static int HandleSchaff = iCustom(_Symbol,PERIOD_CURRENT,\"Schaff Trend Cycle\",Schaff_period,Schaff_fast_EMA,Schaff_slow_EMA,Schaff_smooth,Schaff_price);\n      double SchaffArray[];\n      CopyBuffer(HandleSchaff,1,1,2,SchaffArray);\n      ArraySetAsSeries(SchaffArray,true);\n      // Simple Moving Average\n      static int HandleMA = iMA(_Symbol,PERIOD_CURRENT,MA_period,0,MA_mode,PRICE_CLOSE);\n      double ArrayMA [];\n      CopyBuffer(HandleMA,0,1,2,ArrayMA);\n      ArraySetAsSeries(ArrayMA,true);\n      //Oscar\n      static int HandleOscar = iCustom(_Symbol,PERIOD_CURRENT,\"Oscar\",Oscar_period,Oscar_signal_period);\n      //Oscar - Ratio\n      double OscarArray[];\n      CopyBuffer(HandleOscar,0,1,2,OscarArray);\n      ArraySetAsSeries(OscarArray,true);\n      //Oscar - Signal\n      double SignalArray[];\n      CopyBuffer(HandleOscar,1,1,2,SignalArray);\n      ArraySetAsSeries(SignalArray,true);\n\n\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n\n      // Buy conditions\n      bool JTPO_buy = (JTPOArray[0] > 0 && JTPOArray[1] < 0);\n      bool Schaff_buy = (SchaffArray[0] == 1);\n      bool MA_buy = (ArrayMA[0] < CloseArray[0]);\n      bool Oscar_buy = (OscarArray[0] > SignalArray[0]);\n\n\n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n      // Sell conditions\n      bool JTPO_sell = (JTPOArray[0] < 0 && JTPOArray[1] > 0);\n      bool Schaff_sell = (SchaffArray[0] == 2);\n      bool MA_sell = (ArrayMA[0] > CloseArray[0]);\n      bool Oscar_sell = (OscarArray[0] < SignalArray[0]);\n\n\n      // Exit conditions\n      bool Oscar_sell_exit = (OscarArray[0] > SignalArray[0] && OscarArray[1] < SignalArray[1]);\n      bool Oscar_buy_exit = (OscarArray[0] < SignalArray[0] && OscarArray[1] > SignalArray[1]);\n\n\n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  \n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; \n              }\n        }\n\n\n      // Managing positions, modifying second trade (moving SL)\n      // Checking how many positions are open\n\n      int current_open_positions = PositionsTotal(); // Might cause a problem with live testing.\n       \n      if (current_open_positions == 0 && positionmodifiercount == 1)\n      {\n      positionmodifiercount -= 1 ;\n      }\n       \n      if(Buy_opened && current_open_positions == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(AtrArray[0] * 1.5,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor);\n        }\n\n      if(Sell_opened && current_open_positions == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(AtrArray[0] * 1.5,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor);\n        }\n\n\n      // Exit conditions\n\n      if(Buy_opened && Oscar_buy_exit)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && Oscar_sell_exit)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Buy_opened && JTPO_sell)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && JTPO_buy)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Buy_opened && MA_sell)\n        {\n         if(pos_info.Symbol()==Symbol())\n            CloseAllPositions();\n        }\n\n      if(Sell_opened && MA_buy)\n        {\n         if(pos_info.Symbol()==Symbol())\n            \n          CloseAllPositions();\n        }\n\n\n      // Placing Buy orders\n      if(JTPO_buy  && Wad_vol && Schaff_buy && MA_buy && Oscar_buy)\n        {\n         Print(\"System 16.5 indicates a buy signal\");\n         \n         // Closing open sell positions\n         if(Sell_opened)\n           {\n            if(pos_info.Symbol()==Symbol())\n               trade.PositionClose(pos_info.Ticket());\n           }\n\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         trade.Buy(Lots,_Symbol,ask,sl,tp,\"Buy1\");\n         trade.Buy(Lots,_Symbol,ask,sl,NULL,\"Buy2\");\n\n        }\n\n      // Placing Sell orders\n      if(JTPO_sell && Wad_vol && Schaff_sell && MA_sell && Oscar_sell)\n        {\n         Print(\"System 16.5 indicates a sell signal\");\n\n\n         // Closing open buy positions\n         if(Buy_opened)\n           {\n            if(pos_info.Symbol()==Symbol())\n               trade.PositionClose(pos_info.Ticket());\n           }\n\n         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         trade.Sell(Lots,_Symbol,bid,sl,tp,\"Sell1\");\n         trade.Sell(Lots,_Symbol,bid,sl,NULL,\"Sell2\");\n\n        }\n\n     }\n\n  }\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopBuy(double ask, double AtrFactor)\n  {\n\n// set the stop loss to 150 points\n   double SL=NormalizeDouble(ask-AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n            // get the ticket number\n            ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n\n            // get position open price\n            double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n\n            // calculate the current stop loss\n            double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n            \n            // Assume a min of 2pips \n            double MinTradeStops = 20*_Point;\n               \n   \n            // Check if stop loss is too close to price or if price has moved back past the open price\n            if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n              {\n               CloseAllPositions();\n              }  \n               \n               \n            else\n               {\n                  // move stop loss to open price, therefore zero loss\n                  if(CurrentStopLoss < PositionOpen && positionmodifiercount == 0)\n                    {\n                     trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                     \n                    }\n                  // if current stop loss is more than 150 points\n                  if(CurrentStopLoss < SL && positionmodifiercount == 1)\n                    {\n                     // move the stop loss\n                     trade.PositionModify(PositionTicket,SL,NULL);\n                    }\n                    \n                  if(positionmodifiercount == 0){\n                     positionmodifiercount += 1;\n                    }\n\n               }\n               \n           }\n        }\n     }\n  }\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopSell(double bid, double AtrFactor)\n  {\n\n// set the stop loss to ATR points\n   double SL=NormalizeDouble(bid+AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n           {\n            // get the ticket number\n            ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n\n            // get position open price\n            double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n\n            // calculate the current stop loss\n            double CurrentStopLoss = PositionGetDouble(POSITION_SL); //works\n            \n            // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n             double MinTradeStops = 20*_Point;\n               \n   \n            // Check if stop loss is too close to price or if price has moved back past the open price\n            if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n              {\n                  CloseAllPositions();\n              }\n\n            \n            else\n               {\n            \n               // move stop loss to open price, therefore zero loss\n               if(CurrentStopLoss > PositionOpen && positionmodifiercount == 0)\n                 {\n                 //Print(CurrentStopLoss);\n                  trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                  \n                 }\n               // if current stop loss is more than ATR points\n               if(CurrentStopLoss > SL && positionmodifiercount == 1)\n                 {\n                  // move the stop loss\n                  trade.PositionModify(PositionTicket,SL,NULL);\n                 }\n                 \n               if(positionmodifiercount == 0){\n                 positionmodifiercount += 1;\n                 }\n\n               }\n \n           }\n        }\n     }\n  }\n\n\n\n\n\n//+------------------------------------------------------------------+\n//|                                                                  |\n//+------------------------------------------------------------------+\nvoid CloseAllPositions()\n  {\n\n// Count down until there are no positions left\n   for(int i = PositionsTotal()-1; i>=0; i--)\n     {\n     string symbol=PositionGetSymbol(i); // get the symbol of the position\n     if(_Symbol == symbol)\n     \n     { \n      // Get the position number\n      ulong ticket = PositionGetTicket(i);\n\n      // Close the position\n      trade.PositionClose(ticket);\n      }\n     }\n\n\n  }\n\n//+------------------------------------------------------------------+\n//+------------------------------------------------------------------+\n"}, {"filename": "README.md", "path": "new_knowledge/Algorithmic-Trading-main/Single-Strategy-System/README.md", "content": "# Single Strategy System\n\nThis single strategy system only operates off one simple momentum based quantitative trading strategy and is housed all within one script.\n\nThe premise of this strategy is to combine optimized momentum signals from custom MQL5 momentum indicators with the addition of volume filters.\n", "search_content": "# Single Strategy System\n\nThis single strategy system only operates off one simple momentum based quantitative trading strategy and is housed all within one script.\n\nThe premise of this strategy is to combine optimized momentum signals from custom MQL5 momentum indicators with the addition of volume filters.\n"}, {"filename": "CheckSymbolBase.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSymbolBase.mq5", "content": "//+------------------------------------------------------------------+\n//|                                              CheckSymbolBase.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolBase (string BaseSymbol, int OrderType){\n// Provide base symbol in string form. Provide OrderType by providing ORDER_TYPE_BUY/SELL\n\n   double BaseSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n\n   for(int i = PositionsTotal()-1; i>=0; i--)\n   {\n      string CurrencyPair = PositionGetSymbol(i);\n      string CurrentSymbolBase = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_BASE);\n \n      \n      if(PositionGetInteger(POSITION_TYPE)==OrderType)\n      {\n         if(CurrentSymbolBase==BaseSymbol)\n         {\n            //System 1\n            if(PositionGetInteger(POSITION_MAGIC)==001)\n            {\n              System1Count += 1;\n            }\n            //System 2\n            if(PositionGetInteger(POSITION_MAGIC)==002)\n            {\n              System2Count += 1;\n            }\n            //System 3\n            if(PositionGetInteger(POSITION_MAGIC)==003)\n            {\n              System3Count += 1;\n            }\n            //System 4\n            if(PositionGetInteger(POSITION_MAGIC)==004)\n            {\n              System4Count += 1;\n            }\n            //System 5\n            if(PositionGetInteger(POSITION_MAGIC)==005)\n            {\n              System5Count += 1;\n            }\n            //System 6\n            if(PositionGetInteger(POSITION_MAGIC)==006)\n            {\n              System6Count += 1;\n            }\n            //System 7\n            if(PositionGetInteger(POSITION_MAGIC)==007)\n            {\n              System7Count += 1;\n            }\n            //System 8\n            if(PositionGetInteger(POSITION_MAGIC)==008)\n            {\n              System7Count += 1;\n            }\n         }\n         \n      }\n    }\n      \n   // Increment preset risk exposures retrieved from each system\n   if(System1Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n\n   // Returns the total volume exposed to the base symbol currency\n   return BaseSymbolExposure;\n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSymbolBase.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolBase (string BaseSymbol, int OrderType){\n// Provide base symbol in string form. Provide OrderType by providing ORDER_TYPE_BUY/SELL\n\n   double BaseSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n\n   for(int i = PositionsTotal()-1; i>=0; i--)\n   {\n      string CurrencyPair = PositionGetSymbol(i);\n      string CurrentSymbolBase = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_BASE);\n \n      \n      if(PositionGetInteger(POSITION_TYPE)==OrderType)\n      {\n         if(CurrentSymbolBase==BaseSymbol)\n         {\n            //System 1\n            if(PositionGetInteger(POSITION_MAGIC)==001)\n            {\n              System1Count += 1;\n            }\n            //System 2\n            if(PositionGetInteger(POSITION_MAGIC)==002)\n            {\n              System2Count += 1;\n            }\n            //System 3\n            if(PositionGetInteger(POSITION_MAGIC)==003)\n            {\n              System3Count += 1;\n            }\n            //System 4\n            if(PositionGetInteger(POSITION_MAGIC)==004)\n            {\n              System4Count += 1;\n            }\n            //System 5\n            if(PositionGetInteger(POSITION_MAGIC)==005)\n            {\n              System5Count += 1;\n            }\n            //System 6\n            if(PositionGetInteger(POSITION_MAGIC)==006)\n            {\n              System6Count += 1;\n            }\n            //System 7\n            if(PositionGetInteger(POSITION_MAGIC)==007)\n            {\n              System7Count += 1;\n            }\n            //System 8\n            if(PositionGetInteger(POSITION_MAGIC)==008)\n            {\n              System7Count += 1;\n            }\n         }\n         \n      }\n    }\n      \n   // Increment preset risk exposures retrieved from each system\n   if(System1Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      BaseSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      BaseSymbolExposure+=0.01;\n   }\n\n   // Returns the total volume exposed to the base symbol currency\n   return BaseSymbolExposure;\n   \n}"}, {"filename": "CheckSystem1Exit.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem1Exit.mq5", "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem1Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 exit signals\n\nstring CheckSystem1Exit()\n{\n   string Sys1ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n \n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade exit entry signals //\n   // Sell exit signal\n   if(Aroon_buy_signal || JMA_buy_signal)\n   {\n      Print(\"System 1 Sell Exit Signal\");\n      Sys1ExitSignal = \"Sell Exit\";\n   }\n   \n   // Buy exit signal\n   if(Aroon_sell_signal || JMA_sell_signal)\n   {\n      Print(\"System 1 Buy Exit Signal\");\n      Sys1ExitSignal = \"Buy Exit\";\n   }\n   \n\n   return (Sys1ExitSignal);\n\n   \n}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem1Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 exit signals\n\nstring CheckSystem1Exit()\n{\n   string Sys1ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n \n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade exit entry signals //\n   // Sell exit signal\n   if(Aroon_buy_signal || JMA_buy_signal)\n   {\n      Print(\"System 1 Sell Exit Signal\");\n      Sys1ExitSignal = \"Sell Exit\";\n   }\n   \n   // Buy exit signal\n   if(Aroon_sell_signal || JMA_sell_signal)\n   {\n      Print(\"System 1 Buy Exit Signal\");\n      Sys1ExitSignal = \"Buy Exit\";\n   }\n   \n\n   return (Sys1ExitSignal);\n\n   \n}\n"}, {"filename": "CheckSystem3.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem3.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem3.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 entry signals \n\nstring CheckSystem3()\n{\n   string Sys3Signal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n   //Conditions\n      // Buy conditions\n      bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n      bool Klinger_buy = (KlingerArray[0] > KSignalArray[0]);\n      bool Waj_buy = (CloseArray[0] > WajArray[0]);\n      bool Solar_buy = (SolarArray[0] > 0);\n\n      \n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      // Sell conditions\n      bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n      bool Klinger_sell = (KlingerArray[0] < KSignalArray[0]);\n      bool Waj_sell = (CloseArray[0] < WajArray[0]);\n      bool Solar_sell = (SolarArray[0] < 0);\n      \n   //Trade Entry Signals\n   // Buy signal\n   if(Trinity_buy && FVE_buy && Klinger_buy && Waj_buy && Solar_buy && Wad_vol)\n   {\n      Print(\"System 3 Buy Signal\");\n      Sys3Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && FVE_sell && Klinger_sell && Waj_sell && Solar_sell && Wad_vol)\n   {\n      Print(\"System 3 Sell Signal\");\n      Sys3Signal = \"Sell\";\n   }      \n                              \n     return (Sys3Signal);                  \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem3.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 entry signals \n\nstring CheckSystem3()\n{\n   string Sys3Signal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n   //Conditions\n      // Buy conditions\n      bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n      bool Klinger_buy = (KlingerArray[0] > KSignalArray[0]);\n      bool Waj_buy = (CloseArray[0] > WajArray[0]);\n      bool Solar_buy = (SolarArray[0] > 0);\n\n      \n      // Volume condition\n      bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      // Sell conditions\n      bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n      bool Klinger_sell = (KlingerArray[0] < KSignalArray[0]);\n      bool Waj_sell = (CloseArray[0] < WajArray[0]);\n      bool Solar_sell = (SolarArray[0] < 0);\n      \n   //Trade Entry Signals\n   // Buy signal\n   if(Trinity_buy && FVE_buy && Klinger_buy && Waj_buy && Solar_buy && Wad_vol)\n   {\n      Print(\"System 3 Buy Signal\");\n      Sys3Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && FVE_sell && Klinger_sell && Waj_sell && Solar_sell && Wad_vol)\n   {\n      Print(\"System 3 Sell Signal\");\n      Sys3Signal = \"Sell\";\n   }      \n                              \n     return (Sys3Signal);                  \n}"}, {"filename": "CheckSys7.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSys7.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem7.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 7 entry signals\n\nstring CheckSys7()\n{\nstring Sys7Signal =\"\";\n      // ATR\n      static int HandleAtr = iATR(_Symbol,PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //DiDi Index \n      static int handleDiDi = iCustom(_Symbol,PERIOD_CURRENT,\"DidiIndex\",0,2,0,0,3,9,15);\n      //DiDi Fast line\n      double FastDiDiArray[];\n      CopyBuffer(handleDiDi,0,1,2,FastDiDiArray);\n      ArraySetAsSeries(FastDiDiArray,true);\n      //DiDi Slow Line\n      double SlowDiDiArray[];\n      CopyBuffer(handleDiDi,2,1,2,SlowDiDiArray);\n      ArraySetAsSeries(SlowDiDiArray,true); \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,5); \n      double BullsArray[];\n      double BearsArray[];\n      CopyBuffer(HandleASA,0,1,2,BullsArray);\n      CopyBuffer(HandleASA,1,1,2,BearsArray);\n      ArraySetAsSeries(BullsArray,true);\n      ArraySetAsSeries(BearsArray,true);\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      //Modified Explosion \n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"Modified_Explosion\",3,90,15,30,15,2,0);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);      \n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);  \n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //iAnchmom\n      static int HandleIANCH = iCustom(_Symbol,PERIOD_CURRENT,\"ianchmom\",34,20,0,0); \n      double IANCHArray[];\n      CopyBuffer(HandleIANCH,0,1,2,IANCHArray);\n      ArraySetAsSeries(IANCHArray,true);\n      \n     //Conditins\n     bool WaddahVol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n     bool ASA_buy = (BullsArray[0] > BearsArray[0] && BullsArray[1] < BearsArray[1]);\n     bool ASA_sell = (BullsArray[0] < BearsArray[0] && BullsArray[1] > BearsArray[1]);\n     bool AnotherComboBuy = ((FastDiDiArray[0] > SlowDiDiArray[0] && FastDiDiArray[1] < SlowDiDiArray[1]) && ASA_buy && IANCHArray[0] > 0);\n     bool AnotherComboSell = ((FastDiDiArray[0] < SlowDiDiArray[0] && FastDiDiArray[1] > SlowDiDiArray[1]) && ASA_sell && IANCHArray[0] < 0); \n     \n      if (AnotherComboBuy && WaddahVol)\n      {\n      Print(\"System 7 is now long\");\n      Sys7Signal=\"Buy\";\n      }\n      \n      if (AnotherComboSell && WaddahVol)\n      {\n      Print(\"System 7 is now short\");\n      Sys7Signal=\"Sell\";\n      }\n      \n      return(Sys7Signal);\n     \n     \n\n}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem7.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 7 entry signals\n\nstring CheckSys7()\n{\nstring Sys7Signal =\"\";\n      // ATR\n      static int HandleAtr = iATR(_Symbol,PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n      //DiDi Index \n      static int handleDiDi = iCustom(_Symbol,PERIOD_CURRENT,\"DidiIndex\",0,2,0,0,3,9,15);\n      //DiDi Fast line\n      double FastDiDiArray[];\n      CopyBuffer(handleDiDi,0,1,2,FastDiDiArray);\n      ArraySetAsSeries(FastDiDiArray,true);\n      //DiDi Slow Line\n      double SlowDiDiArray[];\n      CopyBuffer(handleDiDi,2,1,2,SlowDiDiArray);\n      ArraySetAsSeries(SlowDiDiArray,true); \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,5); \n      double BullsArray[];\n      double BearsArray[];\n      CopyBuffer(HandleASA,0,1,2,BullsArray);\n      CopyBuffer(HandleASA,1,1,2,BearsArray);\n      ArraySetAsSeries(BullsArray,true);\n      ArraySetAsSeries(BearsArray,true);\n      // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      //Modified Explosion \n      static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"Modified_Explosion\",3,90,15,30,15,2,0);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);      \n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);  \n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //iAnchmom\n      static int HandleIANCH = iCustom(_Symbol,PERIOD_CURRENT,\"ianchmom\",34,20,0,0); \n      double IANCHArray[];\n      CopyBuffer(HandleIANCH,0,1,2,IANCHArray);\n      ArraySetAsSeries(IANCHArray,true);\n      \n     //Conditins\n     bool WaddahVol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n     bool ASA_buy = (BullsArray[0] > BearsArray[0] && BullsArray[1] < BearsArray[1]);\n     bool ASA_sell = (BullsArray[0] < BearsArray[0] && BullsArray[1] > BearsArray[1]);\n     bool AnotherComboBuy = ((FastDiDiArray[0] > SlowDiDiArray[0] && FastDiDiArray[1] < SlowDiDiArray[1]) && ASA_buy && IANCHArray[0] > 0);\n     bool AnotherComboSell = ((FastDiDiArray[0] < SlowDiDiArray[0] && FastDiDiArray[1] > SlowDiDiArray[1]) && ASA_sell && IANCHArray[0] < 0); \n     \n      if (AnotherComboBuy && WaddahVol)\n      {\n      Print(\"System 7 is now long\");\n      Sys7Signal=\"Buy\";\n      }\n      \n      if (AnotherComboSell && WaddahVol)\n      {\n      Print(\"System 7 is now short\");\n      Sys7Signal=\"Sell\";\n      }\n      \n      return(Sys7Signal);\n     \n     \n\n}\n"}, {"filename": "CheckSystem1.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem1.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem1.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 entry signals\n\nstring CheckSystem1()\n{\n   string Sys1Signal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy = (CloseArray[0] > JMAArray[0]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell = (CloseArray[0] < JMAArray[0]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy)\n   {\n      Print(\"System 1 Buy Signal\");\n      Sys1Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell)\n   {\n      Print(\"System 1 Sell Signal\");\n      Sys1Signal = \"Sell\";\n   }\n   \n\n   return (Sys1Signal);\n\n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem1.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 entry signals\n\nstring CheckSystem1()\n{\n   string Sys1Signal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy = (CloseArray[0] > JMAArray[0]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell = (CloseArray[0] < JMAArray[0]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy)\n   {\n      Print(\"System 1 Buy Signal\");\n      Sys1Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell)\n   {\n      Print(\"System 1 Sell Signal\");\n      Sys1Signal = \"Sell\";\n   }\n   \n\n   return (Sys1Signal);\n\n   \n}"}, {"filename": "README.md", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/README.md", "content": "# Multi Strategy System\n\nThis is a trading system comprised of multiple momentum based strategies with exposure control. The main control script is structured such that a large number\nof signals from multiple strategies can be processed simultaneously and trading logic applied.\n", "search_content": "# Multi Strategy System\n\nThis is a trading system comprised of multiple momentum based strategies with exposure control. The main control script is structured such that a large number\nof signals from multiple strategies can be processed simultaneously and trading logic applied.\n"}, {"filename": "CheckSystem8.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem8.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem8.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 8 entry signals\n\nstring CheckSystem8()\n{\n\n   string Sys8Signal=\"\";\n\n         // ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n         double AtrArray[];\n         CopyBuffer(HandleAtr,0,1,2,AtrArray);\n         ArraySetAsSeries(AtrArray,true);\n\n      // SSL\n      static int HandleSSL = iCustom(_Symbol,PERIOD_CURRENT,\"SSL_Channel_Chart\",3,20); \n         double SSLBearArray[];\n         double SSLBullArray[];\n         double SSLArray[];\n         CopyBuffer(HandleSSL,0,1,2,SSLBearArray);\n         CopyBuffer(HandleSSL,1,1,2,SSLBullArray);\n         CopyBuffer(HandleSSL,2,1,2,SSLArray);\n         ArraySetAsSeries(SSLBearArray,true);\n         ArraySetAsSeries(SSLBullArray,true);\n         ArraySetAsSeries(SSLArray,true);\n         \n         \n      // FVE\n      static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0); \n         double FVEArray[];\n         double SignalArray[];\n         CopyBuffer(HandleFVE,0,1,2,FVEArray);\n         CopyBuffer(HandleFVE,1,1,2,SignalArray);\n         ArraySetAsSeries(FVEArray,true);\n         ArraySetAsSeries(SignalArray,true);\n         \n         \n      // ROC\n      static int HandleROC = iCustom(_Symbol,PERIOD_CURRENT,\"ROC\",18);\n         double ROCArray[];\n         CopyBuffer(HandleROC,0,1,2,ROCArray);\n         ArraySetAsSeries(ROCArray,true);\n      \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,0); \n         double BullsArray[];\n         double BearsArray[];\n         CopyBuffer(HandleASA,0,1,2,BullsArray);\n         CopyBuffer(HandleASA,1,1,2,BearsArray);\n         ArraySetAsSeries(BullsArray,true);\n         ArraySetAsSeries(BearsArray,true);\n               // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n         // Buy conditions\n      bool SSL_buy_signal = (SSLArray[0] > 0 && SSLArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n      bool ROC_buy = (ROCArray[0] > 0);\n      bool ASA_buy = (BullsArray[0] > BearsArray[0]);\n\n      \n      // Sell conditions\n      bool SSL_sell_signal = (SSLArray[0] < 0 && SSLArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n      bool ROC_sell = (ROCArray[0] < 0);\n      bool ASA_sell = (BullsArray[0] < BearsArray[0]);\n      \n      if (SSL_buy_signal && FVE_buy && ROC_buy && ASA_buy)\n      {\n      Print(\"System 8 is now long\");\n      Sys8Signal=\"Buy\";\n      }\n      \n      if (SSL_sell_signal && FVE_sell && ROC_sell && ASA_sell)\n      {\n      Print(\"System 8 is now short\");\n      Sys8Signal=\"Sell\";\n      }\n      \n      return(Sys8Signal);\n      \n      \n}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem8.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 8 entry signals\n\nstring CheckSystem8()\n{\n\n   string Sys8Signal=\"\";\n\n         // ATR\n      static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n         double AtrArray[];\n         CopyBuffer(HandleAtr,0,1,2,AtrArray);\n         ArraySetAsSeries(AtrArray,true);\n\n      // SSL\n      static int HandleSSL = iCustom(_Symbol,PERIOD_CURRENT,\"SSL_Channel_Chart\",3,20); \n         double SSLBearArray[];\n         double SSLBullArray[];\n         double SSLArray[];\n         CopyBuffer(HandleSSL,0,1,2,SSLBearArray);\n         CopyBuffer(HandleSSL,1,1,2,SSLBullArray);\n         CopyBuffer(HandleSSL,2,1,2,SSLArray);\n         ArraySetAsSeries(SSLBearArray,true);\n         ArraySetAsSeries(SSLBullArray,true);\n         ArraySetAsSeries(SSLArray,true);\n         \n         \n      // FVE\n      static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0); \n         double FVEArray[];\n         double SignalArray[];\n         CopyBuffer(HandleFVE,0,1,2,FVEArray);\n         CopyBuffer(HandleFVE,1,1,2,SignalArray);\n         ArraySetAsSeries(FVEArray,true);\n         ArraySetAsSeries(SignalArray,true);\n         \n         \n      // ROC\n      static int HandleROC = iCustom(_Symbol,PERIOD_CURRENT,\"ROC\",18);\n         double ROCArray[];\n         CopyBuffer(HandleROC,0,1,2,ROCArray);\n         ArraySetAsSeries(ROCArray,true);\n      \n      // ASA\n      static int HandleASA = iCustom(_Symbol,PERIOD_CURRENT,\"absolute_strength_-_averages\",0,14,5,5,0,0); \n         double BullsArray[];\n         double BearsArray[];\n         CopyBuffer(HandleASA,0,1,2,BullsArray);\n         CopyBuffer(HandleASA,1,1,2,BearsArray);\n         ArraySetAsSeries(BullsArray,true);\n         ArraySetAsSeries(BearsArray,true);\n               // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n   \n         // Buy conditions\n      bool SSL_buy_signal = (SSLArray[0] > 0 && SSLArray[1] < 0);\n      bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n      bool ROC_buy = (ROCArray[0] > 0);\n      bool ASA_buy = (BullsArray[0] > BearsArray[0]);\n\n      \n      // Sell conditions\n      bool SSL_sell_signal = (SSLArray[0] < 0 && SSLArray[1] > 0);\n      bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n      bool ROC_sell = (ROCArray[0] < 0);\n      bool ASA_sell = (BullsArray[0] < BearsArray[0]);\n      \n      if (SSL_buy_signal && FVE_buy && ROC_buy && ASA_buy)\n      {\n      Print(\"System 8 is now long\");\n      Sys8Signal=\"Buy\";\n      }\n      \n      if (SSL_sell_signal && FVE_sell && ROC_sell && ASA_sell)\n      {\n      Print(\"System 8 is now short\");\n      Sys8Signal=\"Sell\";\n      }\n      \n      return(Sys8Signal);\n      \n      \n}\n"}, {"filename": "CheckSystem6JMA.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem6JMA.mq5", "content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem6JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 6 Jurik Moving Average specific entry signals\n\nstring CheckSystem6JMA()\n{\n   string Sys6JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 6 JMA Buy Signal\");\n      Sys6JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 6 JMA Sell Signal\");\n      Sys6JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys6JMASignal);\n\n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem6JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 6 Jurik Moving Average specific entry signals\n\nstring CheckSystem6JMA()\n{\n   string Sys6JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 6 JMA Buy Signal\");\n      Sys6JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 6 JMA Sell Signal\");\n      Sys6JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys6JMASignal);\n\n   \n}"}, {"filename": "CheckSystem1JMA.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem1JMA.mq5", "content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem1JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 with Jurik Moving Average specific entry signals\n\nstring CheckSystem1JMA()\n{\n   string Sys1JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 1 JMA Buy Signal\");\n      Sys1JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 1 JMA Sell Signal\");\n      Sys1JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys1JMASignal);\n\n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem1JMA.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 1 with Jurik Moving Average specific entry signals\n\nstring CheckSystem1JMA()\n{\n   string Sys1JMASignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n\n   // Aroon\n   static int HandleAroon = iCustom(_Symbol,PERIOD_CURRENT,\"aroon\",9,0);\n      double BearsAroonArray[];\n      double BullsAroonArray[];\n      CopyBuffer(HandleAroon,0,1,2,BearsAroonArray);\n      CopyBuffer(HandleAroon,1,1,2,BullsAroonArray);\n      ArraySetAsSeries(BearsAroonArray,true);\n      ArraySetAsSeries(BullsAroonArray,true);\n\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",22,0,22,0);\n      double FVEArray[];\n      double SignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,SignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(SignalArray,true);\n\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      // waddah - color   \n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n      \n\n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n   // JMA\n   static int HandleJMA = iCustom(_Symbol,PERIOD_CURRENT,\"ATR adaptive JMA\",14,0,PRICE_CLOSE);\n      double JMAArray[];\n      CopyBuffer(HandleJMA,0,1,2,JMAArray);\n      ArraySetAsSeries(JMAArray,true);\n      \n\n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Aroon_buy_signal = (BearsAroonArray[0] > BullsAroonArray[0] && BearsAroonArray[1] < BullsAroonArray[1]);\n   bool FVE_buy = (FVEArray[0] > SignalArray[0]);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n   bool JMA_buy_signal = (CloseArray[0] > JMAArray[0] && CloseArray[1] < JMAArray[1]);\n\n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n\n   // Sell conditions\n   bool Aroon_sell_signal = (BearsAroonArray[0] < BullsAroonArray[0] && BearsAroonArray[1] > BullsAroonArray[1]);\n   bool FVE_sell = (FVEArray[0] < SignalArray[0]);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n   bool JMA_sell_signal = (CloseArray[0] < JMAArray[0] && CloseArray[1] > JMAArray[1]);\n   \n\n   // Trade entry signals //\n   // Buy signal\n   if(Aroon_buy_signal && FVE_buy && Wad_vol && UO_buy && JMA_buy_signal)\n   {\n      Print(\"System 1 JMA Buy Signal\");\n      Sys1JMASignal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Aroon_sell_signal && FVE_sell && Wad_vol && UO_sell && JMA_sell_signal)\n   {\n      Print(\"System 1 JMA Sell Signal\");\n      Sys1JMASignal = \"Sell\";\n   }\n   \n\n   return (Sys1JMASignal);\n\n   \n}"}, {"filename": "CheckSymbolProfit.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSymbolProfit.mq5", "content": "//+------------------------------------------------------------------+\n//|                                            CheckSymbolProfit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolProfit (string ProfitSymbol, int OrderType){\n\n   double ProfitSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n   \n      for(int i = PositionsTotal()-1; i>=0; i--)\n      {\n         string CurrencyPair = PositionGetSymbol(i);\n         string CurrentSymbolProfit = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_PROFIT);\n\n         \n         if(PositionGetInteger(POSITION_TYPE)==OrderType)\n         {\n            if(CurrentSymbolProfit==ProfitSymbol)\n            {\n            \n               //System 1\n               if(PositionGetInteger(POSITION_MAGIC)==001)\n               {\n                 System1Count += 1;\n               }\n               //System 2\n               if(PositionGetInteger(POSITION_MAGIC)==002)\n               {\n                 System2Count += 1;\n               }\n               //System 3\n               if(PositionGetInteger(POSITION_MAGIC)==003)\n               {\n                 System3Count += 1;\n               }\n               //System 4\n               if(PositionGetInteger(POSITION_MAGIC)==004)\n               {\n                 System4Count += 1;\n               }\n               //System 5\n               if(PositionGetInteger(POSITION_MAGIC)==005)\n               {\n                 System5Count += 1;\n               }\n               //System 6\n               if(PositionGetInteger(POSITION_MAGIC)==006)\n               {\n                 System6Count += 1;\n               }\n               //System 7\n               if(PositionGetInteger(POSITION_MAGIC)==007)\n               {\n                 System7Count += 1;\n               }\n               //System 8\n               if(PositionGetInteger(POSITION_MAGIC)==008)\n               {\n                 System7Count += 1;\n               }\n               \n            }\n         \n         }\n         \n         \n         \n         \n         \n      }   \n         \n   // Increment preset risk exposures retrieved from each system      \n   if(System1Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   // Returns the total volume exposed to the profit symbol currency\n   return ProfitSymbolExposure;\n   \n}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                            CheckSymbolProfit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\ndouble CheckSymbolProfit (string ProfitSymbol, int OrderType){\n\n   double ProfitSymbolExposure = 0;\n   int System1Count = 0;\n   int System2Count = 0;\n   int System3Count = 0;\n   int System4Count = 0;\n   int System5Count = 0;\n   int System6Count = 0;\n   int System7Count = 0;\n   int System8Count = 0;\n   \n      for(int i = PositionsTotal()-1; i>=0; i--)\n      {\n         string CurrencyPair = PositionGetSymbol(i);\n         string CurrentSymbolProfit = SymbolInfoString(CurrencyPair,SYMBOL_CURRENCY_PROFIT);\n\n         \n         if(PositionGetInteger(POSITION_TYPE)==OrderType)\n         {\n            if(CurrentSymbolProfit==ProfitSymbol)\n            {\n            \n               //System 1\n               if(PositionGetInteger(POSITION_MAGIC)==001)\n               {\n                 System1Count += 1;\n               }\n               //System 2\n               if(PositionGetInteger(POSITION_MAGIC)==002)\n               {\n                 System2Count += 1;\n               }\n               //System 3\n               if(PositionGetInteger(POSITION_MAGIC)==003)\n               {\n                 System3Count += 1;\n               }\n               //System 4\n               if(PositionGetInteger(POSITION_MAGIC)==004)\n               {\n                 System4Count += 1;\n               }\n               //System 5\n               if(PositionGetInteger(POSITION_MAGIC)==005)\n               {\n                 System5Count += 1;\n               }\n               //System 6\n               if(PositionGetInteger(POSITION_MAGIC)==006)\n               {\n                 System6Count += 1;\n               }\n               //System 7\n               if(PositionGetInteger(POSITION_MAGIC)==007)\n               {\n                 System7Count += 1;\n               }\n               //System 8\n               if(PositionGetInteger(POSITION_MAGIC)==008)\n               {\n                 System7Count += 1;\n               }\n               \n            }\n         \n         }\n         \n         \n         \n         \n         \n      }   \n         \n   // Increment preset risk exposures retrieved from each system      \n   if(System1Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System2Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System3Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System4Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System5Count==2)\n   {\n      ProfitSymbolExposure+=0.015;\n   }\n   \n   if(System6Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System7Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   if(System8Count==1)\n   {\n      ProfitSymbolExposure+=0.01;\n   }\n   \n   // Returns the total volume exposed to the profit symbol currency\n   return ProfitSymbolExposure;\n   \n}\n"}, {"filename": "CheckSystem4Exit.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem4Exit.mq5", "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem4Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 exit signals \n\nstring CheckSystem4Exit()\n{\n\n   string Sys4ExitSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n    \n\n   // Trade exit signals //\n   // Buy exit\n   if(QQE_sell_signal)\n   {\n      Print(\"System 4 Buy Exit Signal\");\n      Sys4ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit\n   if(QQE_buy_signal)\n   {\n      Print(\"System 4 Sell Exit Signal\");\n      Sys4ExitSignal = \"Sell Exit\";\n   }\n\n   return (Sys4ExitSignal);\n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem4Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 exit signals \n\nstring CheckSystem4Exit()\n{\n\n   string Sys4ExitSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n    \n\n   // Trade exit signals //\n   // Buy exit\n   if(QQE_sell_signal)\n   {\n      Print(\"System 4 Buy Exit Signal\");\n      Sys4ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit\n   if(QQE_buy_signal)\n   {\n      Print(\"System 4 Sell Exit Signal\");\n      Sys4ExitSignal = \"Sell Exit\";\n   }\n\n   return (Sys4ExitSignal);\n   \n}"}, {"filename": "TradeControlMain.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/TradeControlMain.mq5", "content": "//+------------------------------------------------------------------+\n//|                                           TradeControlScript.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n// System 1\n#include \"CheckSystem1.mq5\"\n#include \"CheckSystem1Exit.mq5\"\n// System 2\n#include \"CheckSystem2.mq5\"\n#include \"CheckSystem2Exit.mq5\"\n// System 3\n#include \"CheckSystem3.mq5\"\n#include \"CheckSystem3Exit.mq5\"\n// System 4\n#include \"CheckSystem4.mq5\"\n#include \"CheckSystem4Exit.mq5\"\n#include \"CheckSystem4AML.mq5\"\n// System 5\n#include \"CheckSystem5.mq5\"\n#include \"CheckSystem5Exit.mq5\"\n// System 6\n#include \"CheckSystem6JMA.mq5\"\n// System 7\n#include \"CheckSys7.mq5\"\n// System 8\n#include \"CheckSystem8.mq5\"\n\n// Check symbol base\n#include \"CheckSymbolBase.mq5\"\n// Check symbol profit\n#include \"CheckSymbolProfit.mq5\"\n\n\nCTrade trade;\nCPositionInfo pos_info;\nCDealInfo m_deal; \n\n// Position modifier count\nint positionmodifiercount = 0;\n\n// Init position count\nint initpositioncount = 0;\n\n// Current symbol base pair\nstring SymbolBase = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_BASE);\n\n// Current symbol profit pair\nstring SymbolProfit = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_PROFIT);\n\n// Currency exposure risk\ndouble ExposureLimit = 0.045;\n\n// Optimization\ninput int Opt_allow = 1;\n\nint OnInit()\n{\n      // Checking for open positions   \n      double askp = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n      \n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  //It is a Buy\n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; // It is a Sell\n              }\n        }\n      \n      if(Buy_opened || Sell_opened){\n         Alert(\"Positions already open\");\n         Print(\"Positions already open, setting init_position_count == 1\");\n         initpositioncount += 1;   \n      }\n\n   return(INIT_SUCCEEDED);\n}\n\nvoid OnDeinit(const int reason)\n{\n\n}\n\nvoid OnTick()\n{\n\n// Executed on tick\n//---------------------------------------------------------------------------------------//\n      // Checking for open positions by EA magic number (trade identifier)\n      // System 1\n      bool AS1_buy_opened=false;  \n      bool AS1_sell_opened=false;\n      // System 2\n      bool AS2_buy_opened=false;  \n      bool AS2_sell_opened=false;\n      // System 3\n      bool AS3_buy_opened=false;\n      bool AS3_sell_opened=false;\n      // System 4\n      bool AS4_buy_opened=false;  \n      bool AS4_sell_opened=false;\n      // System5\n      bool AS5_buy_opened=false;  \n      bool AS5_sell_opened=false;\n      // System6\n      bool AS6_buy_opened=false;\n      bool AS6_sell_opened=false;\n      // System7\n      bool AS7_buy_opened=false;\n      bool AS7_sell_opened=false;\n      // System8\n      bool AS8_buy_opened=false;\n      bool AS8_sell_opened=false;\n\n      if(PositionSelect(_Symbol)==true){\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               AS7_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               AS8_buy_opened=true;\n            } \n                       \n         }\n         else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               AS7_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               AS8_sell_opened=true;\n            } \n                                        \n         }\n      }\n\n//---------------------------------------------------------------------------------------//\n      \n      // Checking trailing stops for systems with trailing stops (1, 3, 5, 6)\n      \n      // Average true range\n      static int HandleATR = iATR(_Symbol, PERIOD_CURRENT,14);\n      double ATRArray[];\n      CopyBuffer(HandleATR,0,1,2,ATRArray);\n      ArraySetAsSeries(ATRArray,true);\n      \n      // System 1. Current open positions1 relates to system 1's open positions.\n      int current_open_positions1 = CountOpenPositions(001);\n\n      if(AS1_buy_opened && current_open_positions1 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         CheckTrailingStopBuyZero(Ask,001);\n        }\n\n      if(AS1_sell_opened && current_open_positions1 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         CheckTrailingStopSellZero(Bid,001);\n        }\n      // System 3. Current open positions3 relates to system 3's open positions.\n      int current_open_positions3 = CountOpenPositions(003);\n          \n      if (current_open_positions3 == 0 && positionmodifiercount == 1)\n         {\n            positionmodifiercount -= 1 ;\n         }\n             \n      if(AS3_buy_opened && current_open_positions3 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor,003);\n        }\n      \n      if(AS3_sell_opened && current_open_positions3 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor,003);\n        }      \n      // System 5. Current open positions5 relates to system 5's open positions.\n      int current_open_positions5 = CountOpenPositions(005);\n          \n      if (current_open_positions5 == 0 && positionmodifiercount == 1)\n         {\n            positionmodifiercount -= 1 ;\n         }\n             \n      if(AS5_buy_opened && current_open_positions5 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor,005);\n        }\n      \n      if(AS5_sell_opened && current_open_positions5 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor,005);\n        }\n\n      int current_open_positions6 = CountOpenPositions(006);\n      // System 6. Current open positions6 relates to system 6's open positions.\n      if(AS6_buy_opened && current_open_positions6 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         CheckTrailingStopBuyZero(Ask,006);\n        }\n\n      if(AS1_sell_opened && current_open_positions1 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         CheckTrailingStopSellZero(Bid,006);\n        }\n\n\n\n// Executed on formation of a new bar\n//---------------------------------------------------------------------------------------//\n\n\n   // Restrict code to process only once per bar\n   static datetime timestamp;\n   datetime time = iTime(_Symbol,PERIOD_CURRENT,0); // Time of current candle\n   if(timestamp != time)\n   {\n      timestamp = time;\n      \n      \n     if(initpositioncount == 0)\n     {\n      \n      CheckSystem1();\n      CheckSystem1Exit();\n      \n      CheckSystem2();\n      CheckSystem2Exit();\n      \n      CheckSystem3();\n      CheckSystem3Exit();\n      \n      CheckSystem4();\n      CheckSystem4Exit();\n      CheckSystem4AML();\n      \n      CheckSystem6JMA();\n      \n      CheckSystem5();\n      CheckSystem5Exit();\n      \n      CheckSys7();    \n      CheckSystem8();\n         \n      \n           \n      // Average true range\n      static int HandleAtr = iATR(_Symbol,PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n//---------------------------------------------------------------------------------------//\n\n      // Checking for open positions by EA magic number\n      // System 1\n      bool S1_buy_opened=false;  \n      bool S1_sell_opened=false;\n      // System 2\n      bool S2_buy_opened=false;  \n      bool S2_sell_opened=false;\n      // System 3\n      bool S3_buy_opened=false;\n      bool S3_sell_opened=false;\n      // System 4\n      bool S4_buy_opened=false;  \n      bool S4_sell_opened=false;\n      // System5\n      bool S5_buy_opened=false;  \n      bool S5_sell_opened=false;\n      // System6\n      bool S6_buy_opened=false;\n      bool S6_sell_opened=false;\n      // System7\n      bool S7_buy_opened=false;\n      bool S7_sell_opened=false;\n      // System8\n      bool S8_buy_opened=false;\n      bool S8_sell_opened=false;\n\n      if(PositionSelect(_Symbol)==true){\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               S1_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               S2_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               S3_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               S4_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               S5_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               S6_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               S7_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               S8_buy_opened=true;\n            } \n                       \n         }\n         else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               S1_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               S2_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               S3_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               S4_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               S5_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               S6_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               S7_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               S8_sell_opened=true;\n            } \n                                        \n         }\n      }\n      \n//---------------------------------------------------------------------------------------//      \n      // Exiting positions\n      // System 1\n      if(S1_buy_opened && (CheckSystem1Exit()==\"Buy Exit\" || CheckSystem1()==\"Sell\"))\n      {\n         CloseAllPositions(001);\n      }\n      \n      if(S1_sell_opened && (CheckSystem1Exit()==\"Sell Exit\" || CheckSystem1()==\"Buy\"))\n      {\n         CloseAllPositions(001);\n      }\n      \n      // System 2\n      if(S2_buy_opened && (CheckSystem2Exit()==\"Buy Exit\" || CheckSystem2()==\"Sell\"))\n      {\n         CloseAllPositions(002);\n      }\n      \n      if(S2_sell_opened && (CheckSystem2Exit()==\"Sell Exit\" || CheckSystem2()==\"Buy\"))\n      {\n         CloseAllPositions(002);\n      }\n      \n      // System 3\n      if(S3_sell_opened && (CheckSystem3()==\"Buy\" || CheckSystem3Exit()==\"Buy Exit\"))\n      {\n         CloseAllPositions(003);\n      }\n      if(S3_buy_opened && (CheckSystem3()==\"Sell\" || CheckSystem3Exit()==\"Sell Exit\"))\n      {\n         CloseAllPositions(003);\n      }\n      \n      // System 4   \n      if(S4_buy_opened && (CheckSystem4Exit()==\"Buy Exit\" || CheckSystem4()==\"Sell\"))\n      {\n         CloseAllPositions(004);\n      }\n      \n      if(S4_sell_opened && (CheckSystem4Exit()==\"Sell Exit\" || CheckSystem4()==\"Buy\"))\n      {\n         CloseAllPositions(004);\n      }\n      \n      // System 5\n      if(S5_buy_opened && (CheckSystem5Exit()==\"Buy Exit\" || CheckSystem5()==\"Sell\"))\n      {\n         CloseAllPositions(005);\n      }\n      \n      if(S5_sell_opened && (CheckSystem5Exit()==\"Sell Exit\" || CheckSystem5()==\"Buy\"))\n      {\n         CloseAllPositions(005);\n      }\n      \n      // System 6\n      if(S6_buy_opened && (CheckSystem1Exit()==\"Buy Exit\" || CheckSystem6JMA()==\"Sell\"))\n      {\n         CloseAllPositions(006);\n      }\n      \n      if(S6_sell_opened && (CheckSystem1Exit()==\"Sell Exit\" || CheckSystem6JMA()==\"Buy\"))\n      {\n         CloseAllPositions(006);\n      }\n      \n      // System 7   \n      if(S7_buy_opened && (CheckSys7()==\"Sell\"))\n      {\n         CloseAllPositions(007);\n      }\n      \n      if(S7_sell_opened && (CheckSys7()==\"Buy\"))\n      {\n         CloseAllPositions(007);\n      } \n      \n      // System 8   \n      if(S8_buy_opened && (CheckSystem8()==\"Sell\"))\n      {\n         CloseAllPositions(008);\n      }\n      \n      if(S8_sell_opened && (CheckSystem8()==\"Buy\"))\n      {\n         CloseAllPositions(008);\n      } \n                   \n     \n             \n//---------------------------------------------------------------------------------------//\n\n      // System 1\n      // Buy orders\n      if(CheckSystem1()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double AtrFactorTP2 = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         double tp2 = ask + AtrFactorTP2;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(001);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 1 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,tp2,\"System 1 Buy: 2nd Trade\");\n         }  \n      }\n      \n      \n      \n      \n      // Sell orders\n      if(CheckSystem1()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double AtrFactorTP2 = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         double tp2 = bid - AtrFactorTP2;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(001);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 1 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,tp2,\"System 1 Sell: 2nd Trade\");  \n         } \n         \n      }\n      \n \n       \n//---------------------------------------------------------------------------------------//\n      \n      // System 2\n      // Buy orders\n      if(CheckSystem2()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(002);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 2 Buy\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem2()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(002);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 2 Sell\");  \n         } \n         \n      }\n//---------------------------------------------------------------------------------------//\n      \n      // System 3\n      // Buy orders\n      if(CheckSystem3()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(003); \n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 3 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,NULL,\"System 3 Buy: 2nd Trade\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem3()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(003);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 3 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,NULL,\"System 3 Sell: 2nd Trade\"); \n         } \n         \n      }       \n//---------------------------------------------------------------------------------------//\n      \n      // System 4\n      // Buy orders AML\n      if(CheckSystem4AML()==\"AML Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(004);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 4 AML Buy\"); \n         } \n         \n      }\n\n      // Sell orders AML\n      if(CheckSystem4AML()==\"AML Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(004);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 4 AML Sell\");  \n         } \n         \n      }\n      \n//---------------------------------------------------------------------------------------//\n      \n      // System 5\n      // Buy orders\n      if(CheckSystem5()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(005); \n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 5 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,NULL,\"System 5 Buy: 2nd Trade\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem5()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(005);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 5 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,NULL,\"System 5 Sell: 2nd Trade\");  \n         } \n         \n      }\n\n\n//---------------------------------------------------------------------------------------//      \n      // System 6\n      // Buy orders JMA\n      if(CheckSystem6JMA()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         \n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(006);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 1 JMA Buy\");\n         } \n         \n      }\n      \n      // Sell orders JMA\n      if(CheckSystem6JMA()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(006);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 1 JMA Sell\");  \n         } \n         \n      } \n\n//---------------------------------------------------------------------------------------//\n      \n      // System 7\n      // Buy orders\n      if(CheckSys7()==\"Buy\")   \n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(007);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 7 Buy\");  \n         }  \n         \n         \n      }\n      // Sell orders\n      if(CheckSys7()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(007);  \n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 7 Sell\"); \n         } \n       \n      \n      }\n//---------------------------------------------------------------------------------------//\n      \n      // System 8\n      // Buy orders\n      if(CheckSystem8() == \"Buy\") \n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n          \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n           trade.SetExpertMagicNumber(008);\n           trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 8 Buy\");   \n         } \n       \n\n                \n      }\n      // Sell orders\n      if(CheckSystem8() == \"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n          \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n           trade.SetExpertMagicNumber(008);\n           trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 8 Sell\");    \n         } \n       \n      \n      }\n   \n   }\n   \n  // If there are positions open, counter is reset and above code is not run   \n   if(initpositioncount == 1)\n      {\n      Print(\"Counter reset\");\n      initpositioncount -= 1;\n      }\n        \n  }\n  \n}\n//---------------------------------------------------------------------------------------//\n\n// FUNCTIONS //\n\n\n//+------------------------------------------------------------------+\n//| Close All Positions                                              |\n//+------------------------------------------------------------------+\n\nvoid CloseAllPositions(ulong Magic)\n  {\n\n// Count down until there are no positions left\n   for(int i = PositionsTotal()-1; i>=0; i--)\n     {\n        string symbol=PositionGetSymbol(i); // get the symbol of the position\n        if(_Symbol == symbol)\n        {\n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // Get the position number\n               ulong ticket = PositionGetTicket(i);\n      \n               // Close the position\n               trade.PositionClose(ticket);\n        \n            } \n         }\n     }\n\n\n  }\n  \n  \n//+------------------------------------------------------------------+\n//| Count Open Positions                                             |\n//+------------------------------------------------------------------+\nint CountOpenPositions(ulong Magic)\n   {\n   \n      int NumberOfOpenPositions = 0;\n      \n      for(int i = PositionsTotal()-1; i>=0; i--)\n      {\n         string CurrencyPair = PositionGetSymbol(i);\n         \n         if(Symbol()==CurrencyPair)\n         {\n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               NumberOfOpenPositions = NumberOfOpenPositions + 1;\n            }     \n         }\n      }\n\n      return NumberOfOpenPositions;      \n\n   } \n\n\n//+------------------------------------------------------------------+\n//| Check Buy Trailing Stop                                                                |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopBuy(double ask, double AtrFactor, ulong Magic)\n  {\n\n// set the stop loss to 150 points\n   double SL=NormalizeDouble(ask-AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n                  \n               if(PositionGetInteger(POSITION_MAGIC)==Magic)\n               {\n           \n                  // get the ticket number\n                  ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n      \n                  // get position open price\n                  double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n      \n                  // calculate the current stop loss\n                  double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n                  \n                  // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                  double MinTradeStops = 20*_Point;\n                     \n         \n                  // Check if stop loss is too close to price or if price has moved back past the open price\n                  if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n                    {\n                     CloseAllPositions(Magic);\n                    }  \n                     \n                     \n                  else\n                     {\n                        // move stop loss to open price, therefore zero loss\n                        if(CurrentStopLoss < PositionOpen && positionmodifiercount == 0)\n                          {\n                           trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                           \n                          }\n                        // if current stop loss is more than 150 points\n                        if(CurrentStopLoss < SL && positionmodifiercount == 1)\n                          {\n                           // move the stop loss\n                           trade.PositionModify(PositionTicket,SL,NULL);\n                          }\n                          \n                        if(positionmodifiercount == 0){\n                           positionmodifiercount += 1;\n                          }\n      \n                     }\n                  \n                }\n           \n          }\n        }\n      }\n    }\n\n\n//+------------------------------------------------------------------+\n//| Check Sell Trailing Stop                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopSell(double bid, double AtrFactor, ulong Magic)\n  {\n\n// set the stop loss to ATR points\n   double SL=NormalizeDouble(bid+AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n            \n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n            \n            \n               if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n                 {\n                  // get the ticket number\n                  ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n      \n                  // get position open price\n                  double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n      \n                  // calculate the current stop loss\n                  double CurrentStopLoss = PositionGetDouble(POSITION_SL); //works\n                  \n                  // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                   double MinTradeStops = 20*_Point;\n                     \n         \n                  // Check if stop loss is too close to price or if price has moved back past the open price\n                  if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n                    {\n                        CloseAllPositions(Magic);\n                    }\n      \n                  \n                  else\n                     {\n                  \n                     // move stop loss to open price, therefore zero loss\n                     if(CurrentStopLoss > PositionOpen && positionmodifiercount == 0)\n                       {\n                       //Print(CurrentStopLoss);\n                        trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                        \n                       }\n                     // if current stop loss is more than ATR points\n                     if(CurrentStopLoss > SL && positionmodifiercount == 1)\n                       {\n                        // move the stop loss\n                        trade.PositionModify(PositionTicket,SL,NULL);\n                       }\n                       \n                     if(positionmodifiercount == 0){\n                       positionmodifiercount += 1;\n                       }\n      \n                     }\n \n          }\n        }\n      }\n    }\n  }\n\n\n//+------------------------------------------------------------------+\n//| Check Buy Trailing Stop to zero                                  |\n//+------------------------------------------------------------------+\n// Moving stop loss to a zero position only\nvoid CheckTrailingStopBuyZero(double ask, ulong Magic)\n  {\n\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n           \n           if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // get the ticket number\n               ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n   \n               // get position open price\n               double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n   \n               // calculate the current stop loss\n               double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n               \n               double TP = PositionGetDouble(POSITION_TP);\n               \n               // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n               double MinTradeStops = 20*_Point;\n                  \n      \n               // Check if stop loss is too close to price or if price has moved back past the open price\n               if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n                 {\n                  CloseAllPositions(Magic);\n                 }  \n                  \n                  \n               else\n                  {\n                     // move stop loss to open price, therefore zero loss\n                     if(CurrentStopLoss < PositionOpen)\n                       {\n                        trade.PositionModify(PositionTicket,PositionOpen,TP);\n                        \n                       }\n   \n                  }\n                      \n           }\n         }\n       }\n     }\n   }\n\n\n//+------------------------------------------------------------------+\n//| Check Sell Trailing Stop to Zero                                 |  \n//+------------------------------------------------------------------+\n// Moving the stop loss to a zero position only\nvoid CheckTrailingStopSellZero(double bid, ulong Magic)\n  {\n\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n           {\n           \n           if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // get the ticket number\n               ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n   \n               // get position open price\n               double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n   \n               // calculate the current stop loss\n               double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n               \n               double TP = PositionGetDouble(POSITION_TP);\n               \n               // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                double MinTradeStops = 20*_Point;\n                  \n      \n               // Check if stop loss is too close to price or if price has moved back past the open price\n               if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n                 {\n                     CloseAllPositions(Magic);\n                 }\n   \n               \n               else\n                  {\n               \n                  // move stop loss to open price, therefore zero loss\n                  if(CurrentStopLoss > PositionOpen)\n                    {\n                    //Print(CurrentStopLoss);\n                     trade.PositionModify(PositionTicket,PositionOpen,TP);\n                     \n                    }\n   \n                  }\n \n           }\n           \n         }\n       }\n     }\n   }\n\n\n//+------------------------------------------------------------------+\n", "search_content": "//+------------------------------------------------------------------+\n//|                                           TradeControlScript.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n#include <Trade/Trade.mqh>\n#include <Trade/PositionInfo.mqh>\n// System 1\n#include \"CheckSystem1.mq5\"\n#include \"CheckSystem1Exit.mq5\"\n// System 2\n#include \"CheckSystem2.mq5\"\n#include \"CheckSystem2Exit.mq5\"\n// System 3\n#include \"CheckSystem3.mq5\"\n#include \"CheckSystem3Exit.mq5\"\n// System 4\n#include \"CheckSystem4.mq5\"\n#include \"CheckSystem4Exit.mq5\"\n#include \"CheckSystem4AML.mq5\"\n// System 5\n#include \"CheckSystem5.mq5\"\n#include \"CheckSystem5Exit.mq5\"\n// System 6\n#include \"CheckSystem6JMA.mq5\"\n// System 7\n#include \"CheckSys7.mq5\"\n// System 8\n#include \"CheckSystem8.mq5\"\n\n// Check symbol base\n#include \"CheckSymbolBase.mq5\"\n// Check symbol profit\n#include \"CheckSymbolProfit.mq5\"\n\n\nCTrade trade;\nCPositionInfo pos_info;\nCDealInfo m_deal; \n\n// Position modifier count\nint positionmodifiercount = 0;\n\n// Init position count\nint initpositioncount = 0;\n\n// Current symbol base pair\nstring SymbolBase = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_BASE);\n\n// Current symbol profit pair\nstring SymbolProfit = SymbolInfoString(_Symbol,SYMBOL_CURRENCY_PROFIT);\n\n// Currency exposure risk\ndouble ExposureLimit = 0.045;\n\n// Optimization\ninput int Opt_allow = 1;\n\nint OnInit()\n{\n      // Checking for open positions   \n      double askp = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n      \n      bool Buy_opened=false;  // variable to hold the result of Buy opened position\n      bool Sell_opened=false; // variables to hold the result of Sell opened position\n\n      if(PositionSelect(_Symbol)==true)\n        {\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY)\n           {\n            Buy_opened=true;  //It is a Buy\n           }\n         else\n            if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL)\n              {\n               Sell_opened=true; // It is a Sell\n              }\n        }\n      \n      if(Buy_opened || Sell_opened){\n         Alert(\"Positions already open\");\n         Print(\"Positions already open, setting init_position_count == 1\");\n         initpositioncount += 1;   \n      }\n\n   return(INIT_SUCCEEDED);\n}\n\nvoid OnDeinit(const int reason)\n{\n\n}\n\nvoid OnTick()\n{\n\n// Executed on tick\n//---------------------------------------------------------------------------------------//\n      // Checking for open positions by EA magic number (trade identifier)\n      // System 1\n      bool AS1_buy_opened=false;  \n      bool AS1_sell_opened=false;\n      // System 2\n      bool AS2_buy_opened=false;  \n      bool AS2_sell_opened=false;\n      // System 3\n      bool AS3_buy_opened=false;\n      bool AS3_sell_opened=false;\n      // System 4\n      bool AS4_buy_opened=false;  \n      bool AS4_sell_opened=false;\n      // System5\n      bool AS5_buy_opened=false;  \n      bool AS5_sell_opened=false;\n      // System6\n      bool AS6_buy_opened=false;\n      bool AS6_sell_opened=false;\n      // System7\n      bool AS7_buy_opened=false;\n      bool AS7_sell_opened=false;\n      // System8\n      bool AS8_buy_opened=false;\n      bool AS8_sell_opened=false;\n\n      if(PositionSelect(_Symbol)==true){\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               AS7_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               AS8_buy_opened=true;\n            } \n                       \n         }\n         else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               AS1_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               AS2_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               AS3_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               AS4_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               AS5_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               AS6_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               AS7_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               AS8_sell_opened=true;\n            } \n                                        \n         }\n      }\n\n//---------------------------------------------------------------------------------------//\n      \n      // Checking trailing stops for systems with trailing stops (1, 3, 5, 6)\n      \n      // Average true range\n      static int HandleATR = iATR(_Symbol, PERIOD_CURRENT,14);\n      double ATRArray[];\n      CopyBuffer(HandleATR,0,1,2,ATRArray);\n      ArraySetAsSeries(ATRArray,true);\n      \n      // System 1. Current open positions1 relates to system 1's open positions.\n      int current_open_positions1 = CountOpenPositions(001);\n\n      if(AS1_buy_opened && current_open_positions1 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         CheckTrailingStopBuyZero(Ask,001);\n        }\n\n      if(AS1_sell_opened && current_open_positions1 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         CheckTrailingStopSellZero(Bid,001);\n        }\n      // System 3. Current open positions3 relates to system 3's open positions.\n      int current_open_positions3 = CountOpenPositions(003);\n          \n      if (current_open_positions3 == 0 && positionmodifiercount == 1)\n         {\n            positionmodifiercount -= 1 ;\n         }\n             \n      if(AS3_buy_opened && current_open_positions3 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor,003);\n        }\n      \n      if(AS3_sell_opened && current_open_positions3 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor,003);\n        }      \n      // System 5. Current open positions5 relates to system 5's open positions.\n      int current_open_positions5 = CountOpenPositions(005);\n          \n      if (current_open_positions5 == 0 && positionmodifiercount == 1)\n         {\n            positionmodifiercount -= 1 ;\n         }\n             \n      if(AS5_buy_opened && current_open_positions5 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopBuy(Ask,AtrFactor,005);\n        }\n      \n      if(AS5_sell_opened && current_open_positions5 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         double AtrFactor = NormalizeDouble(ATRArray[0] * 1,_Digits);\n         CheckTrailingStopSell(Bid,AtrFactor,005);\n        }\n\n      int current_open_positions6 = CountOpenPositions(006);\n      // System 6. Current open positions6 relates to system 6's open positions.\n      if(AS6_buy_opened && current_open_positions6 == 1)\n        {\n         double Ask = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_ASK),_Digits);\n         CheckTrailingStopBuyZero(Ask,006);\n        }\n\n      if(AS1_sell_opened && current_open_positions1 == 1)\n        {\n         double Bid = NormalizeDouble(SymbolInfoDouble(_Symbol,SYMBOL_BID),_Digits);\n         CheckTrailingStopSellZero(Bid,006);\n        }\n\n\n\n// Executed on formation of a new bar\n//---------------------------------------------------------------------------------------//\n\n\n   // Restrict code to process only once per bar\n   static datetime timestamp;\n   datetime time = iTime(_Symbol,PERIOD_CURRENT,0); // Time of current candle\n   if(timestamp != time)\n   {\n      timestamp = time;\n      \n      \n     if(initpositioncount == 0)\n     {\n      \n      CheckSystem1();\n      CheckSystem1Exit();\n      \n      CheckSystem2();\n      CheckSystem2Exit();\n      \n      CheckSystem3();\n      CheckSystem3Exit();\n      \n      CheckSystem4();\n      CheckSystem4Exit();\n      CheckSystem4AML();\n      \n      CheckSystem6JMA();\n      \n      CheckSystem5();\n      CheckSystem5Exit();\n      \n      CheckSys7();    \n      CheckSystem8();\n         \n      \n           \n      // Average true range\n      static int HandleAtr = iATR(_Symbol,PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n//---------------------------------------------------------------------------------------//\n\n      // Checking for open positions by EA magic number\n      // System 1\n      bool S1_buy_opened=false;  \n      bool S1_sell_opened=false;\n      // System 2\n      bool S2_buy_opened=false;  \n      bool S2_sell_opened=false;\n      // System 3\n      bool S3_buy_opened=false;\n      bool S3_sell_opened=false;\n      // System 4\n      bool S4_buy_opened=false;  \n      bool S4_sell_opened=false;\n      // System5\n      bool S5_buy_opened=false;  \n      bool S5_sell_opened=false;\n      // System6\n      bool S6_buy_opened=false;\n      bool S6_sell_opened=false;\n      // System7\n      bool S7_buy_opened=false;\n      bool S7_sell_opened=false;\n      // System8\n      bool S8_buy_opened=false;\n      bool S8_sell_opened=false;\n\n      if(PositionSelect(_Symbol)==true){\n         if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_BUY){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               S1_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               S2_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               S3_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               S4_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               S5_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               S6_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               S7_buy_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               S8_buy_opened=true;\n            } \n                       \n         }\n         else if(PositionGetInteger(POSITION_TYPE)==POSITION_TYPE_SELL){\n         \n            if(PositionGetInteger(POSITION_MAGIC)==001){\n               S1_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==002){\n               S2_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==003){\n               S3_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==004){\n               S4_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==005){\n               S5_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==006){\n               S6_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==007){\n               S7_sell_opened=true;\n            }\n            if(PositionGetInteger(POSITION_MAGIC)==008){\n               S8_sell_opened=true;\n            } \n                                        \n         }\n      }\n      \n//---------------------------------------------------------------------------------------//      \n      // Exiting positions\n      // System 1\n      if(S1_buy_opened && (CheckSystem1Exit()==\"Buy Exit\" || CheckSystem1()==\"Sell\"))\n      {\n         CloseAllPositions(001);\n      }\n      \n      if(S1_sell_opened && (CheckSystem1Exit()==\"Sell Exit\" || CheckSystem1()==\"Buy\"))\n      {\n         CloseAllPositions(001);\n      }\n      \n      // System 2\n      if(S2_buy_opened && (CheckSystem2Exit()==\"Buy Exit\" || CheckSystem2()==\"Sell\"))\n      {\n         CloseAllPositions(002);\n      }\n      \n      if(S2_sell_opened && (CheckSystem2Exit()==\"Sell Exit\" || CheckSystem2()==\"Buy\"))\n      {\n         CloseAllPositions(002);\n      }\n      \n      // System 3\n      if(S3_sell_opened && (CheckSystem3()==\"Buy\" || CheckSystem3Exit()==\"Buy Exit\"))\n      {\n         CloseAllPositions(003);\n      }\n      if(S3_buy_opened && (CheckSystem3()==\"Sell\" || CheckSystem3Exit()==\"Sell Exit\"))\n      {\n         CloseAllPositions(003);\n      }\n      \n      // System 4   \n      if(S4_buy_opened && (CheckSystem4Exit()==\"Buy Exit\" || CheckSystem4()==\"Sell\"))\n      {\n         CloseAllPositions(004);\n      }\n      \n      if(S4_sell_opened && (CheckSystem4Exit()==\"Sell Exit\" || CheckSystem4()==\"Buy\"))\n      {\n         CloseAllPositions(004);\n      }\n      \n      // System 5\n      if(S5_buy_opened && (CheckSystem5Exit()==\"Buy Exit\" || CheckSystem5()==\"Sell\"))\n      {\n         CloseAllPositions(005);\n      }\n      \n      if(S5_sell_opened && (CheckSystem5Exit()==\"Sell Exit\" || CheckSystem5()==\"Buy\"))\n      {\n         CloseAllPositions(005);\n      }\n      \n      // System 6\n      if(S6_buy_opened && (CheckSystem1Exit()==\"Buy Exit\" || CheckSystem6JMA()==\"Sell\"))\n      {\n         CloseAllPositions(006);\n      }\n      \n      if(S6_sell_opened && (CheckSystem1Exit()==\"Sell Exit\" || CheckSystem6JMA()==\"Buy\"))\n      {\n         CloseAllPositions(006);\n      }\n      \n      // System 7   \n      if(S7_buy_opened && (CheckSys7()==\"Sell\"))\n      {\n         CloseAllPositions(007);\n      }\n      \n      if(S7_sell_opened && (CheckSys7()==\"Buy\"))\n      {\n         CloseAllPositions(007);\n      } \n      \n      // System 8   \n      if(S8_buy_opened && (CheckSystem8()==\"Sell\"))\n      {\n         CloseAllPositions(008);\n      }\n      \n      if(S8_sell_opened && (CheckSystem8()==\"Buy\"))\n      {\n         CloseAllPositions(008);\n      } \n                   \n     \n             \n//---------------------------------------------------------------------------------------//\n\n      // System 1\n      // Buy orders\n      if(CheckSystem1()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double AtrFactorTP2 = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         double tp2 = ask + AtrFactorTP2;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(001);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 1 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,tp2,\"System 1 Buy: 2nd Trade\");\n         }  \n      }\n      \n      \n      \n      \n      // Sell orders\n      if(CheckSystem1()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double AtrFactorTP2 = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         double tp2 = bid - AtrFactorTP2;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(001);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 1 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,tp2,\"System 1 Sell: 2nd Trade\");  \n         } \n         \n      }\n      \n \n       \n//---------------------------------------------------------------------------------------//\n      \n      // System 2\n      // Buy orders\n      if(CheckSystem2()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(002);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 2 Buy\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem2()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(002);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 2 Sell\");  \n         } \n         \n      }\n//---------------------------------------------------------------------------------------//\n      \n      // System 3\n      // Buy orders\n      if(CheckSystem3()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(003); \n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 3 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,NULL,\"System 3 Buy: 2nd Trade\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem3()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(003);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 3 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,NULL,\"System 3 Sell: 2nd Trade\"); \n         } \n         \n      }       \n//---------------------------------------------------------------------------------------//\n      \n      // System 4\n      // Buy orders AML\n      if(CheckSystem4AML()==\"AML Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(004);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 4 AML Buy\"); \n         } \n         \n      }\n\n      // Sell orders AML\n      if(CheckSystem4AML()==\"AML Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(004);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 4 AML Sell\");  \n         } \n         \n      }\n      \n//---------------------------------------------------------------------------------------//\n      \n      // System 5\n      // Buy orders\n      if(CheckSystem5()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(005); \n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 5 Buy: 1st Trade\");\n            trade.Buy(Lots2,_Symbol,ask,sl,NULL,\"System 5 Buy: 2nd Trade\");  \n         } \n         \n      }\n      \n      // Sell orders\n      if(CheckSystem5()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Acc_risk2 = AccountInfoDouble(ACCOUNT_BALANCE) * 0.005;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Volume2 = Acc_risk2/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double Lots2 = NormalizeDouble(Volume2,2);\n         // Exposure control\n         double SystemRisk = 0.015;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(005);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 5 Sell: 1st Trade\");\n            trade.Sell(Lots2,_Symbol,bid,sl,NULL,\"System 5 Sell: 2nd Trade\");  \n         } \n         \n      }\n\n\n//---------------------------------------------------------------------------------------//      \n      // System 6\n      // Buy orders JMA\n      if(CheckSystem6JMA()==\"Buy\")\n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         \n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(006);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 1 JMA Buy\");\n         } \n         \n      }\n      \n      // Sell orders JMA\n      if(CheckSystem6JMA()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(006);\n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 1 JMA Sell\");  \n         } \n         \n      } \n\n//---------------------------------------------------------------------------------------//\n      \n      // System 7\n      // Buy orders\n      if(CheckSys7()==\"Buy\")   \n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = ask - AtrFactorSl; \n         double tp = ask + AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(007);\n            trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 7 Buy\");  \n         }  \n         \n         \n      }\n      // Sell orders\n      if(CheckSys7()==\"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1.5;\n         double AtrFactorTP = AtrArray[0] * 1;\n         double sl = bid + AtrFactorSl; \n         double tp = bid - AtrFactorTP;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n            trade.SetExpertMagicNumber(007);  \n            trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 7 Sell\"); \n         } \n       \n      \n      }\n//---------------------------------------------------------------------------------------//\n      \n      // System 8\n      // Buy orders\n      if(CheckSystem8() == \"Buy\") \n      {\n         double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = ask - AtrFactorSl;\n         double tp = ask + AtrFactorTP;\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_BUY);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n         double SellProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n          \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + SellProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n           trade.SetExpertMagicNumber(008);\n           trade.Buy(Lots,_Symbol,ask,sl,tp,\"System 8 Buy\");   \n         } \n       \n\n                \n      }\n      // Sell orders\n      if(CheckSystem8() == \"Sell\")\n      {\n         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);\n         double AtrFactorSl = AtrArray[0] * 1;\n         double AtrFactorTP = AtrArray[0] * 0.67;\n         double Acc_risk = AccountInfoDouble(ACCOUNT_BALANCE) * 0.01;\n         double Volume = Acc_risk/(AtrFactorSl/Point());\n         double Lots = NormalizeDouble(Volume,2);\n         double sl = bid + AtrFactorSl;\n         double tp = bid - AtrFactorTP;\n         // Exposure control\n         double SystemRisk = 0.01;\n         double BasePairExposure = CheckSymbolBase(SymbolBase, ORDER_TYPE_SELL);\n         double TotalBasePairExposure = SystemRisk + BasePairExposure;\n         double ProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_SELL);\n         double BuyProfitPairExposure = CheckSymbolProfit(SymbolProfit, ORDER_TYPE_BUY);\n          \n         double TotalProfitPairExposure = SystemRisk + ProfitPairExposure;\n         if((TotalProfitPairExposure + BuyProfitPairExposure) < ExposureLimit && TotalBasePairExposure < ExposureLimit)\n         {\n           trade.SetExpertMagicNumber(008);\n           trade.Sell(Lots,_Symbol,bid,sl,tp,\"System 8 Sell\");    \n         } \n       \n      \n      }\n   \n   }\n   \n  // If there are positions open, counter is reset and above code is not run   \n   if(initpositioncount == 1)\n      {\n      Print(\"Counter reset\");\n      initpositioncount -= 1;\n      }\n        \n  }\n  \n}\n//---------------------------------------------------------------------------------------//\n\n// FUNCTIONS //\n\n\n//+------------------------------------------------------------------+\n//| Close All Positions                                              |\n//+------------------------------------------------------------------+\n\nvoid CloseAllPositions(ulong Magic)\n  {\n\n// Count down until there are no positions left\n   for(int i = PositionsTotal()-1; i>=0; i--)\n     {\n        string symbol=PositionGetSymbol(i); // get the symbol of the position\n        if(_Symbol == symbol)\n        {\n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // Get the position number\n               ulong ticket = PositionGetTicket(i);\n      \n               // Close the position\n               trade.PositionClose(ticket);\n        \n            } \n         }\n     }\n\n\n  }\n  \n  \n//+------------------------------------------------------------------+\n//| Count Open Positions                                             |\n//+------------------------------------------------------------------+\nint CountOpenPositions(ulong Magic)\n   {\n   \n      int NumberOfOpenPositions = 0;\n      \n      for(int i = PositionsTotal()-1; i>=0; i--)\n      {\n         string CurrencyPair = PositionGetSymbol(i);\n         \n         if(Symbol()==CurrencyPair)\n         {\n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               NumberOfOpenPositions = NumberOfOpenPositions + 1;\n            }     \n         }\n      }\n\n      return NumberOfOpenPositions;      \n\n   } \n\n\n//+------------------------------------------------------------------+\n//| Check Buy Trailing Stop                                                                |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopBuy(double ask, double AtrFactor, ulong Magic)\n  {\n\n// set the stop loss to 150 points\n   double SL=NormalizeDouble(ask-AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n                  \n               if(PositionGetInteger(POSITION_MAGIC)==Magic)\n               {\n           \n                  // get the ticket number\n                  ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n      \n                  // get position open price\n                  double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n      \n                  // calculate the current stop loss\n                  double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n                  \n                  // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                  double MinTradeStops = 20*_Point;\n                     \n         \n                  // Check if stop loss is too close to price or if price has moved back past the open price\n                  if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n                    {\n                     CloseAllPositions(Magic);\n                    }  \n                     \n                     \n                  else\n                     {\n                        // move stop loss to open price, therefore zero loss\n                        if(CurrentStopLoss < PositionOpen && positionmodifiercount == 0)\n                          {\n                           trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                           \n                          }\n                        // if current stop loss is more than 150 points\n                        if(CurrentStopLoss < SL && positionmodifiercount == 1)\n                          {\n                           // move the stop loss\n                           trade.PositionModify(PositionTicket,SL,NULL);\n                          }\n                          \n                        if(positionmodifiercount == 0){\n                           positionmodifiercount += 1;\n                          }\n      \n                     }\n                  \n                }\n           \n          }\n        }\n      }\n    }\n\n\n//+------------------------------------------------------------------+\n//| Check Sell Trailing Stop                                                                  |\n//+------------------------------------------------------------------+\nvoid CheckTrailingStopSell(double bid, double AtrFactor, ulong Magic)\n  {\n\n// set the stop loss to ATR points\n   double SL=NormalizeDouble(bid+AtrFactor,_Digits);\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n            \n            if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n            \n            \n               if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n                 {\n                  // get the ticket number\n                  ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n      \n                  // get position open price\n                  double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n      \n                  // calculate the current stop loss\n                  double CurrentStopLoss = PositionGetDouble(POSITION_SL); //works\n                  \n                  // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                   double MinTradeStops = 20*_Point;\n                     \n         \n                  // Check if stop loss is too close to price or if price has moved back past the open price\n                  if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n                    {\n                        CloseAllPositions(Magic);\n                    }\n      \n                  \n                  else\n                     {\n                  \n                     // move stop loss to open price, therefore zero loss\n                     if(CurrentStopLoss > PositionOpen && positionmodifiercount == 0)\n                       {\n                       //Print(CurrentStopLoss);\n                        trade.PositionModify(PositionTicket,PositionOpen,NULL);\n                        \n                       }\n                     // if current stop loss is more than ATR points\n                     if(CurrentStopLoss > SL && positionmodifiercount == 1)\n                       {\n                        // move the stop loss\n                        trade.PositionModify(PositionTicket,SL,NULL);\n                       }\n                       \n                     if(positionmodifiercount == 0){\n                       positionmodifiercount += 1;\n                       }\n      \n                     }\n \n          }\n        }\n      }\n    }\n  }\n\n\n//+------------------------------------------------------------------+\n//| Check Buy Trailing Stop to zero                                  |\n//+------------------------------------------------------------------+\n// Moving stop loss to a zero position only\nvoid CheckTrailingStopBuyZero(double ask, ulong Magic)\n  {\n\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_BUY)\n           {\n           \n           if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // get the ticket number\n               ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n   \n               // get position open price\n               double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n   \n               // calculate the current stop loss\n               double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n               \n               double TP = PositionGetDouble(POSITION_TP);\n               \n               // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n               double MinTradeStops = 20*_Point;\n                  \n      \n               // Check if stop loss is too close to price or if price has moved back past the open price\n               if((ask - PositionOpen) <= MinTradeStops || ask < PositionOpen)\n                 {\n                  CloseAllPositions(Magic);\n                 }  \n                  \n                  \n               else\n                  {\n                     // move stop loss to open price, therefore zero loss\n                     if(CurrentStopLoss < PositionOpen)\n                       {\n                        trade.PositionModify(PositionTicket,PositionOpen,TP);\n                        \n                       }\n   \n                  }\n                      \n           }\n         }\n       }\n     }\n   }\n\n\n//+------------------------------------------------------------------+\n//| Check Sell Trailing Stop to Zero                                 |  \n//+------------------------------------------------------------------+\n// Moving the stop loss to a zero position only\nvoid CheckTrailingStopSellZero(double bid, ulong Magic)\n  {\n\n\n// go through all positions\n   for(int i=PositionsTotal()-1; i>=0; i--)\n     {\n      string symbol=PositionGetSymbol(i); // get the symbol of the position\n\n\n      if(_Symbol == symbol) // if the current symbol of the pair is equal\n        {\n\n         if(PositionGetInteger(POSITION_TYPE)==ORDER_TYPE_SELL)\n           {\n           \n           if(PositionGetInteger(POSITION_MAGIC)==Magic)\n            {\n               // get the ticket number\n               ulong PositionTicket = PositionGetInteger(POSITION_TICKET);\n   \n               // get position open price\n               double PositionOpen = NormalizeDouble(PositionGetDouble(POSITION_PRICE_OPEN),_Digits);\n   \n               // calculate the current stop loss\n               double CurrentStopLoss = PositionGetDouble(POSITION_SL);\n               \n               double TP = PositionGetDouble(POSITION_TP);\n               \n               // Assume a min of 2pips. Run SymbolInfoInteger(SYMBOL_TRADE_STOPS_LEVEL) other brokers \n                double MinTradeStops = 20*_Point;\n                  \n      \n               // Check if stop loss is too close to price or if price has moved back past the open price\n               if((PositionOpen - bid) <= MinTradeStops || bid > PositionOpen)\n                 {\n                     CloseAllPositions(Magic);\n                 }\n   \n               \n               else\n                  {\n               \n                  // move stop loss to open price, therefore zero loss\n                  if(CurrentStopLoss > PositionOpen)\n                    {\n                    //Print(CurrentStopLoss);\n                     trade.PositionModify(PositionTicket,PositionOpen,TP);\n                     \n                    }\n   \n                  }\n \n           }\n           \n         }\n       }\n     }\n   }\n\n\n//+------------------------------------------------------------------+\n"}, {"filename": "CheckSystem2.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem2.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem2.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 entry signals\n\nstring CheckSystem2()\n{\n   string Sys2Signal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n   bool Solar_buy = (SolarArray[0] > 0);\n\n \n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      \n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n   bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n   bool Solar_sell = (SolarArray[0] < 0);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(Trinity_buy && Wad_vol && FVE_buy && Solar_buy)\n   {\n      Print(\"System 2 Buy Signal\");\n      Sys2Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && Wad_vol && FVE_sell && Solar_sell)\n   {\n      Print(\"System 2 Sell Signal\");\n      Sys2Signal = \"Sell\";\n   }\n   \n\n   return (Sys2Signal);\n\n   \n}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem2.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 entry signals\n\nstring CheckSystem2()\n{\n   string Sys2Signal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool FVE_buy = (FVEArray[0] > FSignalArray[0]);\n   bool Solar_buy = (SolarArray[0] > 0);\n\n \n   // Volume condition\n   bool Wad_vol = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0]);\n      \n      \n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n   bool FVE_sell = (FVEArray[0] < FSignalArray[0]);\n   bool Solar_sell = (SolarArray[0] < 0);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(Trinity_buy && Wad_vol && FVE_buy && Solar_buy)\n   {\n      Print(\"System 2 Buy Signal\");\n      Sys2Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(Trinity_sell && Wad_vol && FVE_sell && Solar_sell)\n   {\n      Print(\"System 2 Sell Signal\");\n      Sys2Signal = \"Sell\";\n   }\n   \n\n   return (Sys2Signal);\n\n   \n}\n"}, {"filename": "CheckSystem5.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem5.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem5.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 entry signals \n\nstring CheckSystem5()\n{\n   string Sys5Signal = \"\";\n   \n   // Indicator inputs //\n   int QQE_smooth_factor = 5;\n   int Trinity_period = 30;\n   int Trinity_smooth = 34;\n   int Wad_fast_MA = 20;\n   int Wad_slow_MA = 40;\n   int Wad_bollinger = 20;\n   int Wad_bollinger_dev = 2;\n   int Wad_sens = 150;\n   int Wad_DZP = 3000;\n   int UO_Oscillator = 3;\n   int UO_period = 14;\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n   bool Trinity_buy = (TrinityArray[0] > 0);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n      \n      \n   // Volume conditions\n   bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n   bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n   bool Trinity_sell = (TrinityArray[0] < 0);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 5 Buy Signal\");\n      Sys5Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 5 Sell Signal\");\n      Sys5Signal = \"Sell\";\n   }\n   \n\n   return (Sys5Signal);\n\n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem5.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 entry signals \n\nstring CheckSystem5()\n{\n   string Sys5Signal = \"\";\n   \n   // Indicator inputs //\n   int QQE_smooth_factor = 5;\n   int Trinity_period = 30;\n   int Trinity_smooth = 34;\n   int Wad_fast_MA = 20;\n   int Wad_slow_MA = 40;\n   int Wad_bollinger = 20;\n   int Wad_bollinger_dev = 2;\n   int Wad_sens = 150;\n   int Wad_DZP = 3000;\n   int UO_Oscillator = 3;\n   int UO_period = 14;\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n   bool Trinity_buy = (TrinityArray[0] > 0);\n   bool UO_buy = (Value1Array[0] > Value2Array[0]);\n      \n      \n   // Volume conditions\n   bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n   bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n   bool Trinity_sell = (TrinityArray[0] < 0);\n   bool UO_sell = (Value1Array[0] < Value2Array[0]);\n\n\n   // Trade entry signals //\n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 5 Buy Signal\");\n      Sys5Signal = \"Buy\";\n   }\n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 5 Sell Signal\");\n      Sys5Signal = \"Sell\";\n   }\n   \n\n   return (Sys5Signal);\n\n   \n}"}, {"filename": "CheckSystem4.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem4.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem4.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 entry signals \n\nstring CheckSystem4()\n{\n\n   string Sys4Signal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    \n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    \n\n   \n   // Trade entry signals //   \n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 4 Buy Signal\");\n      Sys4Signal = \"Buy\";\n   }\n   \n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 4 Sell Signal\");\n      Sys4Signal = \"Sell\";\n   }\n   \n   \n   return (Sys4Signal);\n   \n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                                 CheckSystem4.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 entry signals \n\nstring CheckSystem4()\n{\n\n   string Sys4Signal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    \n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    \n\n   \n   // Trade entry signals //   \n   // Buy signal\n   if(QQE_buy_signal && Trinity_buy && Wad_vol_buy && UO_buy)\n   {\n      Print(\"System 4 Buy Signal\");\n      Sys4Signal = \"Buy\";\n   }\n   \n   \n   // Sell signal\n   if(QQE_sell_signal && Trinity_sell && Wad_vol_sell && UO_sell)\n   {\n      Print(\"System 4 Sell Signal\");\n      Sys4Signal = \"Sell\";\n   }\n   \n   \n   return (Sys4Signal);\n   \n   \n}"}, {"filename": "CheckSystem2Exit.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem2Exit.mq5", "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem2Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 exit signals \n\nstring CheckSystem2Exit()\n{\n   string Sys2ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n\n\n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n\n\n   // Trade Exit signals //\n   // Buy exit signal\n   if(Trinity_sell)\n   {\n      Print(\"System 2 Buy Exit Signal\");\n      Sys2ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Trinity_buy)\n   {\n      Print(\"System 2 Sell Exit Signal\");\n      Sys2ExitSignal = \"Sell Exit\";\n   }\n   \n   \n   return (Sys2ExitSignal);\n\n}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem2Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 2 exit signals \n\nstring CheckSystem2Exit()\n{\n   string Sys2ExitSignal = \"\";\n\n\n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // Std Dev\n   static int HandleSTD = iStdDev(_Symbol,PERIOD_CURRENT,7,0,MODE_SMA,PRICE_CLOSE);\n      double STDArray[];\n      CopyBuffer(HandleSTD,0,1,2,STDArray);\n      ArraySetAsSeries(STDArray,true);\n         \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true); \n         \n         \n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",20,0,20,0); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n         \n         \n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",1,0,15,15); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n               \n    \n   // Getting the close price of candle\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n\n   // Buy conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n\n\n   // Sell conditions\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n\n\n   // Trade Exit signals //\n   // Buy exit signal\n   if(Trinity_sell)\n   {\n      Print(\"System 2 Buy Exit Signal\");\n      Sys2ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Trinity_buy)\n   {\n      Print(\"System 2 Sell Exit Signal\");\n      Sys2ExitSignal = \"Sell Exit\";\n   }\n   \n   \n   return (Sys2ExitSignal);\n\n}\n"}, {"filename": "CheckSystem5Exit.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem5Exit.mq5", "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem5Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 exit signals \n\nstring CheckSystem5Exit()\n{\n   \n   string Sys5ExitSignal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n      \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n\n   // Trade exit signals //\n   // Buy exit signal\n   if(QQE_sell_signal)\n   {\n      Print(\"System 5 Buy Exit Signal\");\n      Sys5ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(QQE_buy_signal)\n   {\n      Print(\"System 5 Sell Exit Signal\");\n      Sys5ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys5ExitSignal);\n   \n}", "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem5Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 5 exit signals \n\nstring CheckSystem5Exit()\n{\n   \n   string Sys5ExitSignal = \"\";\n   \n   // Indicators //\n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n  \n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n         \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n\n\n   // Buy conditions\n   bool QQE_buy_signal = (RSIArray[0] > SmoothArray[0] && RSIArray[1] < SmoothArray[1]);\n\n      \n   // Sell conditions\n   bool QQE_sell_signal = (RSIArray[0] < SmoothArray[0] && RSIArray[1] > SmoothArray[1]);\n\n\n   // Trade exit signals //\n   // Buy exit signal\n   if(QQE_sell_signal)\n   {\n      Print(\"System 5 Buy Exit Signal\");\n      Sys5ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(QQE_buy_signal)\n   {\n      Print(\"System 5 Sell Exit Signal\");\n      Sys5ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys5ExitSignal);\n   \n}"}, {"filename": "CheckSystem3Exit.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem3Exit.mq5", "content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem3Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 exit signals \n\nstring CheckSystem3Exit()\n{\n   string Sys3ExitSignal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      \n   //Conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n    \n   bool Buy_Exit_Signal = Trinity_sell;\n   bool Sell_Exit_Signal = Trinity_buy;\n    \n   //Trade Exit Signals\n   // Buy exit signal\n   if(Buy_Exit_Signal)\n   {\n      Print(\"System 3 Buy Exit Signal\");\n      Sys3ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Sell_Exit_Signal)\n   {\n      Print(\"System 3 Sell Exit Signal\");\n      Sys3ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys3ExitSignal);\n}      ", "search_content": "//+------------------------------------------------------------------+\n//|                                             CheckSystem3Exit.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 3 exit signals \n\nstring CheckSystem3Exit()\n{\n   string Sys3ExitSignal = \"\";\n   \n   //Indicator Inputs\n   // Inputs\n    int FVE_period = 20;\n    int FVE_method = 0;\n    int Signal_line_period = 20;\n    int Signal_line_method = 0;\n    int Klinger_fast_period = 50;\n    int Klinger_slow_period = 100;\n    int Klinger_signal_period = 20;\n    int Solar_npr = 1;\n    int Solar_event = 0;\n    int Solar_period = 15;\n    int Solar_smooth = 15;\n    \n   // Indicators \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n   // FVE\n   static int HandleFVE = iCustom(_Symbol,PERIOD_CURRENT,\"FVE\",FVE_period,FVE_method,Signal_line_period,Signal_line_method); \n      double FVEArray[];\n      double FSignalArray[];\n      CopyBuffer(HandleFVE,0,1,2,FVEArray);\n      CopyBuffer(HandleFVE,1,1,2,FSignalArray);\n      ArraySetAsSeries(FVEArray,true);\n      ArraySetAsSeries(FSignalArray,true);\n   // Klinger   \n   static int HandleKlinger = iCustom(_Symbol,PERIOD_CURRENT,\"Klinger Oscillator MT5 Indicator\",Klinger_fast_period,Klinger_slow_period,Klinger_signal_period); \n      double KlingerArray[];\n      double KSignalArray[];\n      CopyBuffer(HandleKlinger,0,1,2,KlingerArray);\n      CopyBuffer(HandleKlinger,1,1,2,KSignalArray);\n      ArraySetAsSeries(KlingerArray,true);\n      ArraySetAsSeries(KSignalArray,true);\n   // Wajdyss\n   static int HandleWaj = iCustom(_Symbol,PERIOD_CURRENT,\"wajdyss_Ichimoku_Indicator\",26,0);\n      double WajArray[];\n      CopyBuffer(HandleWaj,0,1,2,WajArray);\n      ArraySetAsSeries(WajArray,true);\n   // Solar winds\n   static int HandleSolar = iCustom(_Symbol,PERIOD_CURRENT,\"Solar Winds\",Solar_npr,Solar_event,Solar_period,Solar_smooth); \n      double SolarArray[];\n      CopyBuffer(HandleSolar,0,1,2,SolarArray);\n      ArraySetAsSeries(SolarArray,true);\n   // Getting the close price of candle\n      double CloseArray[];\n      CopyClose(_Symbol,PERIOD_CURRENT,1,2,CloseArray);\n      ArraySetAsSeries(CloseArray,true);\n      \n   //Conditions\n   bool Trinity_buy = (TrinityArray[0] > 0 && TrinityArray[1] < 0);\n   bool Trinity_sell = (TrinityArray[0] < 0 && TrinityArray[1] > 0);\n    \n   bool Buy_Exit_Signal = Trinity_sell;\n   bool Sell_Exit_Signal = Trinity_buy;\n    \n   //Trade Exit Signals\n   // Buy exit signal\n   if(Buy_Exit_Signal)\n   {\n      Print(\"System 3 Buy Exit Signal\");\n      Sys3ExitSignal = \"Buy Exit\";\n   }\n   \n   // Sell exit signal\n   if(Sell_Exit_Signal)\n   {\n      Print(\"System 3 Sell Exit Signal\");\n      Sys3ExitSignal = \"Sell Exit\";\n   }\n\n\n   return (Sys3ExitSignal);\n}      "}, {"filename": "CheckSystem4AML.mq5", "path": "new_knowledge/Algorithmic-Trading-main/Multi-Strategy-System/CheckSystem4AML.mq5", "content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem4AML.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 Advanced Market Line specific entry signals \n\nstring CheckSystem4AML()\n{\n\n   string Sys4AMLSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    bool AML_buy_signal = (CloseArray[0] > AMLArray[0] && CloseArray[1] < AMLArray[1]);\n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    bool AML_sell_signal = (CloseArray[0] < AMLArray[0] && CloseArray[1] > AMLArray[1]);\n\n   \n   // Trade entry signals //   \n   // AML buy signal\n   if(QQE_buy && Trinity_buy && Wad_vol_buy && UO_buy && AML_buy_signal)\n   {\n      Print(\"System 4 AML Buy Signal\");\n      Sys4AMLSignal = \"AML Buy\";\n   }\n      \n   // AML sell signal\n   if(QQE_sell && Trinity_sell && Wad_vol_sell && UO_sell && AML_sell_signal)\n   {\n      Print(\"System 4 AML Sell Signal\");\n      Sys4AMLSignal = \"AML Sell\";\n   }\n\n   return (Sys4AMLSignal);\n   \n}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                              CheckSystem4AML.mq5 |\n//|                              Spencer Luck and Thiyagan Marimuthu |\n//+------------------------------------------------------------------+\n\n// Trading strategy 4 Advanced Market Line specific entry signals \n\nstring CheckSystem4AML()\n{\n\n   string Sys4AMLSignal = \"\";\n        \n   // Indicators // \n   // ATR\n   static int HandleAtr = iATR(_Symbol, PERIOD_CURRENT,14);\n      double AtrArray[];\n      CopyBuffer(HandleAtr,0,1,2,AtrArray);\n      ArraySetAsSeries(AtrArray,true);\n\n   // QQE\n   static int HandleQQE = iCustom(_Symbol,PERIOD_CURRENT,\"QQE\",5,50,false,false,false);\n      double RSIArray[];\n      double SmoothArray[];\n      CopyBuffer(HandleQQE,0,1,2,RSIArray);\n      CopyBuffer(HandleQQE,1,1,2,SmoothArray);\n      ArraySetAsSeries(RSIArray,true);\n      ArraySetAsSeries(SmoothArray,true);\n     \n              \n   // Trinity Impulse\n   static int HandleTrinity = iCustom(_Symbol,PERIOD_CURRENT,\"trinity-impulse\",30,34,MODE_LWMA,PRICE_WEIGHTED,VOLUME_TICK);\n      double TrinityArray[];\n      CopyBuffer(HandleTrinity,0,1,2,TrinityArray);\n      ArraySetAsSeries(TrinityArray,true);\n         \n         \n   //Waddah Attar Explosion\n   static int handleWAD = iCustom(_Symbol,PERIOD_CURRENT,\"waddah_attar_explosion\",20,40,20,2,150,3000,15,15,false,500,false,false,false,false);\n      //waddah - MACD\n      double MACDWADarray[];\n      CopyBuffer(handleWAD,0,1,2,MACDWADarray);\n      ArraySetAsSeries(MACDWADarray,true);\n      //waddah - Signal Line\n      double SLWADarray[];\n      CopyBuffer(handleWAD,2,1,2,SLWADarray);\n      ArraySetAsSeries(SLWADarray,true);\n      //waddah - Dead Zone Pip\n      double DZPWADarray[];\n      CopyBuffer(handleWAD,3,1,2,DZPWADarray);\n      ArraySetAsSeries(DZPWADarray,true);\n      //waddah - color\n      double ColorArray[];\n      CopyBuffer(handleWAD,1,1,2,ColorArray);\n      ArraySetAsSeries(ColorArray,true);\n         \n         \n   // Universal Oscillator\n   static int HandleUO = iCustom(_Symbol,PERIOD_CURRENT,\"universaloscillator\",3,14);\n      double Value1Array[];\n      double Value2Array[];\n      CopyBuffer(HandleUO,0,1,2,Value1Array);\n      CopyBuffer(HandleUO,1,1,2,Value2Array);\n      ArraySetAsSeries(Value1Array,true);\n      ArraySetAsSeries(Value2Array,true);\n         \n   // AML\n   static int HandleAML = iCustom(_Symbol,PERIOD_CURRENT,\"AML\",7,6,0);\n      double AMLArray[];\n      CopyBuffer(HandleAML,0,1,2,AMLArray);\n      ArraySetAsSeries(AMLArray,true);\n         \n   // Close price\n   double CloseArray[];\n   CopyClose(_Symbol,PERIOD_CURRENT,1,3,CloseArray);\n   ArraySetAsSeries(CloseArray,true);\n\n   \n    // Buy conditions\n    bool QQE_buy = (RSIArray[0] > SmoothArray[0]);\n    bool Trinity_buy = (TrinityArray[0] > 0);\n    bool UO_buy = (Value1Array[0] > Value2Array[0]);\n    bool AML_buy_signal = (CloseArray[0] > AMLArray[0] && CloseArray[1] < AMLArray[1]);\n      \n      \n    // Volume conditions\n    bool Wad_vol_buy = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 1.0);\n    bool Wad_vol_sell = (MACDWADarray[0] > SLWADarray[0] && MACDWADarray [0] > DZPWADarray[0] && ColorArray[0] == 2.0);\n\n            \n    // Sell conditions\n    bool QQE_sell = (RSIArray[0] < SmoothArray[0]);\n    bool Trinity_sell = (TrinityArray[0] < 0);\n    bool UO_sell = (Value1Array[0] < Value2Array[0]);\n    bool AML_sell_signal = (CloseArray[0] < AMLArray[0] && CloseArray[1] > AMLArray[1]);\n\n   \n   // Trade entry signals //   \n   // AML buy signal\n   if(QQE_buy && Trinity_buy && Wad_vol_buy && UO_buy && AML_buy_signal)\n   {\n      Print(\"System 4 AML Buy Signal\");\n      Sys4AMLSignal = \"AML Buy\";\n   }\n      \n   // AML sell signal\n   if(QQE_sell && Trinity_sell && Wad_vol_sell && UO_sell && AML_sell_signal)\n   {\n      Print(\"System 4 AML Sell Signal\");\n      Sys4AMLSignal = \"AML Sell\";\n   }\n\n   return (Sys4AMLSignal);\n   \n}\n"}, {"filename": "DeepLearning.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/DeepLearning.mqh", "content": "#include <DeepLearningLibrary.mqh>\n\nclass DeepLearning\n  {\npublic:\n   //-------------------------------\n   // Define the cost functions and its derivatives\n   class Loss;\n   // Define metrics for evaluation\n   class Metrics;\n   \n   //-------------------------------\n   // Dense Connected Layer\n   class DenseLayer;\n   // Activation Function Layer \n   class ActivationLayer;\n   // Softmax function Layer\n   class SoftmaxLayer;\n   // Dropout Layer to Enhance Overffiting\n   class DropoutLayer;\n\n   //--------------------------------\n   // Convolutional Neural Net Layer\n   class ConvolutionalLayer;\n   // Max Pooling Layer\n   class MaxPoolingLayer;\n   // Flatten Layer\n   class FlattenLayer;\n   // Sum Convolutional Layer\n   class SumConvLayer;\n\n   //--------------------------------\n   //Long Short-Term Memory Layer\n   class LSTMLayer;\n   // Bidirectional LSTM layer\n   class BiLSTMLayer;\n   \n   \n   //Methods\n   virtual matrix    Output(matrix &X)                {return X*0;   }\n   virtual matrix    GradDescent(matrix &Ey)          {return Ey*0;  }\n   virtual void      Update(void)                     {              }\n   virtual void      SaveWeights(int k,string IAname) {              }\n   virtual void      LoadWeights(int k,string IAname) {              }\n   virtual void      SetDrop(double Drop)             {              }\n   virtual void      SetAdam(double B1, double B2, double Alph) {    }\n   \n   \n   \n   //=============================\n   matrix   InitWeights(matrix &M);\n   matrix   ZeroMatrix(matrix &M);\n   void     SaveMatrix(matrix &M, string M_name);\n   matrix   LoadMatrix(string M_name);\n   matrix   Concatenate(matrix &X, matrix &H);\n   \n   //Convolution \n   matrix VertConvV(matrix &A, matrix &B);\n   matrix VertConvF(matrix &A, matrix &B);\n   matrix VertInv(matrix &A);\n   \n   matrix HorConvV(matrix &A, matrix &B);\n   matrix HorConvF(matrix &A, matrix &B);\n   matrix HorInv(matrix &A);\n   \n   //Activation\n   matrix Sig(matrix &X);\n   matrix Tanh(matrix &X);\n   matrix ReLU(matrix &X);\n   \n   matrix dSig(matrix &X);\n   matrix dTanh(matrix &X);\n   matrix dReLU(matrix &X);\n   \n   //ADAM optimizer\n   matrix AdamM(matrix &m, matrix &dX,double beta1);\n   matrix AdamV(matrix &v, matrix &dX,double beta2);\n   matrix Adam(double it, matrix &m, matrix &v,double beta1, double beta2, double alpha);\n   \n   \n  };\n \n//+------------------------------------------------------------------+\n//|   Deep Learning Methodes                                         |\n//+------------------------------------------------------------------+\nmatrix DeepLearning::InitWeights(matrix &M)\n{\n   matrix W;\n   W = M;\n   for(int i=0;i<W.Rows();i++)\n     {for(int j=0;j<W.Cols();j++)\n        {W[i][j] = (2.0*(MathRand()/32766.0) -1.0);}}\n         \nreturn W;\n}\nmatrix DeepLearning::ZeroMatrix(matrix &M)\n{\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = 0;}}\n      \nreturn M;\n}\nvoid DeepLearning::SaveMatrix(matrix &M,string M_name)\n{\n   //transforma a matrix M num vetor de strings\n   ulong Srows , SCols;\n   Srows = M.Rows();\n   SCols = M.Cols();\n   string csv_name;\n   csv_name = M_name;\n   \n   string V[];\n   ArrayResize(V,Srows);\n   \n   //Zera o vetor de strings\n   for(int i=0;i<ArraySize(V);i++)\n     {V[i] = NULL;}\n      \n   //Prepara o vetor com as classes \n\n   for(int i=0;i<Srows;i++)\n     {for(int j=0;j<SCols;j++)\n         {\n         if(j == SCols-1) V[i] = V[i] + DoubleToString(M[i][j]);\n         else V[i] = V[i] + DoubleToString(M[i][j]) + \",\";}}     \n   \n   //Abre o arquivo para ser escrito\n   int h=FileOpen(csv_name,FILE_WRITE|FILE_ANSI|FILE_CSV);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE) Alert(\"Error opening file\");\n   \n   for(int i=0;i<Srows;i++)\n      {\n      FileWrite(h,V[i]);\n      }\n   FileClose(h);\n}\nmatrix DeepLearning::LoadMatrix(string M_name)\n{\n   //Le apenas a primeira linha para saber o n\u00famero de colunas\n   string L1;\n   string csv_name;\n   csv_name = M_name;\n   //Abre o arquivo para ser lido\n   int h1=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_TXT);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h1==INVALID_HANDLE)   Alert(\"Error opening file\");\n   L1 = FileReadString(h1);\n   FileClose(h1);\n   \n   //L1 possui agora a primeira linha da matriz\n   //L\u00ea quantas colunas s\u00e3o pelo n\u00famero de v\u00edrgulas\n   \n   int num_columns = 1; \n   \n   for(int i=0;i<L1.Length();i++)\n     {\n      if(L1.Substr(i,1) == \",\") num_columns++;\n     }\n   \n   //Abre o arquivo para ser lido\n   int h=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_CSV,\",\");\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE)   Alert(\"Error opening file\");\n\n   string read_x;\n   string m[]; //Vetor que receber\u00e1 os dados\n   int    m_size = 0;\n   \n   matrix A;   // Matriz que retornar\u00e1 com os dados\n   int A_size = 0;\n   //Come\u00e7a com a leitura da primeira linha\n   \n   while(!FileIsEnding(h))\n   {\n      ArrayResize(m,m_size+1);\n      read_x = FileReadString(h);   // L\u00ea o conteudo at\u00e9 a virgula \u00e9 passa pra pr\u00f3xima\n      m[m_size] = read_x;\n   if(!FileIsEnding(h)) m_size++;  \n   }\n   FileClose(h);\n   \n   int num_rows;\n   num_rows = (m_size + 1)/num_columns;\n   \n   if(((m_size +1)% num_columns) != 0 )   Alert(\"Error the matrix data is incomplete\");\n   else\n   {\n   \n   //Preparar a Matriz A\n   A.Init(num_rows,num_columns);\n   \n   for(int i=0;i<num_rows;i++)\n      {for(int j=0;j<num_columns;j++)\n        {A[i][j] = StringToDouble(m[i * num_columns + j]);}}         \n   //==========\n   }\nreturn A;\n}\nmatrix DeepLearning::Concatenate(matrix &X,matrix &H)\n{\nif(X.Cols() != H.Cols()) Alert(\"The number of Cols of X and H must be equal\");\n\nmatrix M;\nM.Init(X.Rows() + H.Rows(),X.Cols());\n\nulong lim;\nlim = X.Rows();\n\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(i < lim) M[i][j] = X[i][j];\n      if(i >= lim) M[i][j] = H[i-lim][j];}}\n      \nreturn M;\n}\n\n//+------------------------------------------------------------------+\n//|    Convolutional Methodes                                        |\n//+------------------------------------------------------------------+\n\nmatrix DeepLearning::VertConvV(matrix &A,matrix &B)\n{\nif(A.Cols() != B.Cols())\n  {Alert(\"matrices with different number of Columns\");\n  return A*0;\n  }\nmatrix U,D,C;\nU = A;\nD = B;\nif(U.Rows() < D.Rows())\n  {C = U;\n   U = D;\n   D = C;\n   }\nD = VertInv(D);\n\nmatrix Conv; \nConv.Init(U.Rows()-D.Rows()+1,U.Cols());\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n      \n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {for(int k=0;k<D.Rows();k++)\n        {Conv[i][j] = Conv[i][j] + U[i+k][j]*D[k][j];}}}\n      \nreturn Conv;\n}\nmatrix DeepLearning::HorConvV(matrix &A,matrix &B)\n{\nif(A.Rows() != B.Rows())\n  {Alert(\"matrices with different number of Rows\");\n  return A*0;\n  }\nmatrix U,D,C;\nU = A;\nD = B;\nif(U.Cols() < D.Cols())\n  {C = U;\n   U = D;\n   D = C;\n   }\nD = HorInv(D);\n\nmatrix Conv; \nConv.Init(U.Rows(), U.Cols() - D.Cols() + 1);\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n      \n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {for(int k=0;k<D.Cols();k++)\n        {Conv[i][j] += U[i][j+k]*D[i][k];}}}\n      \nreturn Conv;\n}\nmatrix DeepLearning::VertConvF(matrix &A,matrix &B)\n{\nif(A.Cols() != B.Cols())\n  {Alert(\"matrices with different number of Columns\");\n  return A*0;\n  }\n\nmatrix U,D,E;\n\nU = A;\nD = B;\n\nif(U.Rows() < D.Rows())\n  {E = U;\n   U = D;\n   D = E;\n   }\nmatrix Conv;\nConv.Init(U.Rows()+2*D.Rows()-2,U.Cols());\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n\nulong c = B.Rows()-1;\nfor(int i=c;i<Conv.Rows()-c;i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {\n      Conv[i][j] = U[i-c][j];\n     }\n   \n  }\n\nmatrix CF;\n   CF= VertConvV(Conv,D);\nreturn CF;\n}\nmatrix DeepLearning::HorConvF(matrix &A,matrix &B)\n{\nif(A.Rows() != B.Rows())\n  {Alert(\"matrices with different number of Rows\");\n  return A*0;\n  }\n\nmatrix U,D,E;\n\nU = A;\nD = B;\n\nif(U.Rows() < D.Rows())\n  {E = U;\n   U = D;\n   D = E;\n   }\nmatrix Conv;\nConv.Init(U.Rows(),U.Cols() + 2*D.Cols() -2);\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n\nulong c = B.Cols()-1;\n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=c;j<Conv.Cols()-c;j++)\n     {\n      Conv[i][j] = U[i][j-c];\n     }\n   \n  }\n\nmatrix CF;\n   CF= HorConvV(Conv,D);\nreturn CF;\n}\nmatrix DeepLearning::VertInv(matrix &A)\n{\nmatrix B;\nB.Init(A.Rows(),A.Cols());\nfor(int i=0;i<A.Rows();i++)\n  {for(int j=0;j<A.Cols();j++)\n     {B[i][j] = A[A.Rows()-i-1][j];}}\n\n\nreturn B;\n}\nmatrix DeepLearning::HorInv(matrix &A)\n{\nmatrix B;\nB.Init(A.Rows(),A.Cols());\nfor(int i=0;i<A.Rows();i++)\n  {for(int j=0;j<A.Cols();j++)\n     {B[i][j] = A[i][A.Cols()-j-1];}}\n\n\nreturn B;\n}\n\n//+------------------------------------------------------------------+\n//|    Activation Methodes                                           |\n//+------------------------------------------------------------------+\n\nmatrix DeepLearning::Sig(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = 1.0/(1.0 + MathExp((-1)*M[i][j]));}}\n     \nreturn M;\n      \n}\nmatrix DeepLearning::Tanh(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = (MathExp(M[i][j])-MathExp((-1.0)*M[i][j]))/(MathExp(M[i][j])+MathExp((-1.0)*M[i][j]));}}\n     \nreturn M;\n}\nmatrix DeepLearning::ReLU(matrix &X)\n{\nmatrix M;\nM = X; \nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(M[i][j] > 0) M[i][j] = M[i][j];\n      if(M[i][j] <=0) M[i][j] = 0.01*M[i][j];}}\n\nreturn M;     \n}\n\nmatrix DeepLearning::dSig(matrix &X)\n{\nmatrix M;\nM = X; \n\nM = Sig(M);\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = M[i][j]*(1.0 - M[i][j]);}}\n\nreturn M;  \n}\nmatrix DeepLearning::dTanh(matrix &X)\n{\nmatrix M;\nM = X; \n\nM = Tanh(M);\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = (1.0 - M[i][j]*M[i][j]);}}\n\nreturn M;  \n}\nmatrix DeepLearning::dReLU(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(M[i][j] > 0) M[i][j] = 1;\n      if(M[i][j] <= 0) M[i][j] = 0.01;}}\n      \nreturn M;\n}\n//+------------------------------------------------------------------+\n//|   Optimizers                                                     |\n//+------------------------------------------------------------------+\nmatrix DeepLearning::AdamM(matrix &m, matrix &dX,double beta1)\n{\nmatrix mt;\nmt.Init(dX.Rows(),dX.Cols());\nmt = m * beta1;\nmt = mt + dX * (1-beta1);\nreturn mt;\n}\nmatrix  DeepLearning::AdamV(matrix &v, matrix &dX,double beta2)\n{\nmatrix vt;\nvt = beta2*v;\nvt = vt + dX * dX * (1-beta2);\nreturn vt; \n}\nmatrix DeepLearning::Adam(double it, matrix &m, matrix &v,double beta1,double beta2, double alpha)\n{\nmatrix D, mt, vt; \n\nmt = m * (1/(1-MathPow(beta1,it)));\nvt = v * (1/(1-MathPow(beta2,it)));\n\nvt = MathSqrt(vt) + 1e-8; \nD = m / vt;\nD = D * alpha;\nreturn D; \n}\n\n#include <Layers\\LossLayer.mqh>\n#include <Layers\\MetricsLayer.mqh>\n\n#include <Layers\\DenseLayer.mqh>\n#include <Layers\\ActivationLayer.mqh>\n#include <Layers\\DropoutLayer.mqh>\n\n#include <Layers\\ConvolutionalLayer.mqh>\n#include <Layers\\MaxPoolingLayer.mqh>\n#include <Layers\\FlattenLayer.mqh>\n#include <Layers\\SumConvLayer.mqh>\n\n#include <Layers\\LSTMLayer.mqh>\n#include <Layers\\BiLSTMLayer.mqh>\n\n\n\n\n\n\n\n\n\n", "search_content": "#include <DeepLearningLibrary.mqh>\n\nclass DeepLearning\n  {\npublic:\n   //-------------------------------\n   // Define the cost functions and its derivatives\n   class Loss;\n   // Define metrics for evaluation\n   class Metrics;\n   \n   //-------------------------------\n   // Dense Connected Layer\n   class DenseLayer;\n   // Activation Function Layer \n   class ActivationLayer;\n   // Softmax function Layer\n   class SoftmaxLayer;\n   // Dropout Layer to Enhance Overffiting\n   class DropoutLayer;\n\n   //--------------------------------\n   // Convolutional Neural Net Layer\n   class ConvolutionalLayer;\n   // Max Pooling Layer\n   class MaxPoolingLayer;\n   // Flatten Layer\n   class FlattenLayer;\n   // Sum Convolutional Layer\n   class SumConvLayer;\n\n   //--------------------------------\n   //Long Short-Term Memory Layer\n   class LSTMLayer;\n   // Bidirectional LSTM layer\n   class BiLSTMLayer;\n   \n   \n   //Methods\n   virtual matrix    Output(matrix &X)                {return X*0;   }\n   virtual matrix    GradDescent(matrix &Ey)          {return Ey*0;  }\n   virtual void      Update(void)                     {              }\n   virtual void      SaveWeights(int k,string IAname) {              }\n   virtual void      LoadWeights(int k,string IAname) {              }\n   virtual void      SetDrop(double Drop)             {              }\n   virtual void      SetAdam(double B1, double B2, double Alph) {    }\n   \n   \n   \n   //=============================\n   matrix   InitWeights(matrix &M);\n   matrix   ZeroMatrix(matrix &M);\n   void     SaveMatrix(matrix &M, string M_name);\n   matrix   LoadMatrix(string M_name);\n   matrix   Concatenate(matrix &X, matrix &H);\n   \n   //Convolution \n   matrix VertConvV(matrix &A, matrix &B);\n   matrix VertConvF(matrix &A, matrix &B);\n   matrix VertInv(matrix &A);\n   \n   matrix HorConvV(matrix &A, matrix &B);\n   matrix HorConvF(matrix &A, matrix &B);\n   matrix HorInv(matrix &A);\n   \n   //Activation\n   matrix Sig(matrix &X);\n   matrix Tanh(matrix &X);\n   matrix ReLU(matrix &X);\n   \n   matrix dSig(matrix &X);\n   matrix dTanh(matrix &X);\n   matrix dReLU(matrix &X);\n   \n   //ADAM optimizer\n   matrix AdamM(matrix &m, matrix &dX,double beta1);\n   matrix AdamV(matrix &v, matrix &dX,double beta2);\n   matrix Adam(double it, matrix &m, matrix &v,double beta1, double beta2, double alpha);\n   \n   \n  };\n \n//+------------------------------------------------------------------+\n//|   Deep Learning Methodes                                         |\n//+------------------------------------------------------------------+\nmatrix DeepLearning::InitWeights(matrix &M)\n{\n   matrix W;\n   W = M;\n   for(int i=0;i<W.Rows();i++)\n     {for(int j=0;j<W.Cols();j++)\n        {W[i][j] = (2.0*(MathRand()/32766.0) -1.0);}}\n         \nreturn W;\n}\nmatrix DeepLearning::ZeroMatrix(matrix &M)\n{\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = 0;}}\n      \nreturn M;\n}\nvoid DeepLearning::SaveMatrix(matrix &M,string M_name)\n{\n   //transforma a matrix M num vetor de strings\n   ulong Srows , SCols;\n   Srows = M.Rows();\n   SCols = M.Cols();\n   string csv_name;\n   csv_name = M_name;\n   \n   string V[];\n   ArrayResize(V,Srows);\n   \n   //Zera o vetor de strings\n   for(int i=0;i<ArraySize(V);i++)\n     {V[i] = NULL;}\n      \n   //Prepara o vetor com as classes \n\n   for(int i=0;i<Srows;i++)\n     {for(int j=0;j<SCols;j++)\n         {\n         if(j == SCols-1) V[i] = V[i] + DoubleToString(M[i][j]);\n         else V[i] = V[i] + DoubleToString(M[i][j]) + \",\";}}     \n   \n   //Abre o arquivo para ser escrito\n   int h=FileOpen(csv_name,FILE_WRITE|FILE_ANSI|FILE_CSV);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE) Alert(\"Error opening file\");\n   \n   for(int i=0;i<Srows;i++)\n      {\n      FileWrite(h,V[i]);\n      }\n   FileClose(h);\n}\nmatrix DeepLearning::LoadMatrix(string M_name)\n{\n   //Le apenas a primeira linha para saber o n\u00famero de colunas\n   string L1;\n   string csv_name;\n   csv_name = M_name;\n   //Abre o arquivo para ser lido\n   int h1=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_TXT);\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h1==INVALID_HANDLE)   Alert(\"Error opening file\");\n   L1 = FileReadString(h1);\n   FileClose(h1);\n   \n   //L1 possui agora a primeira linha da matriz\n   //L\u00ea quantas colunas s\u00e3o pelo n\u00famero de v\u00edrgulas\n   \n   int num_columns = 1; \n   \n   for(int i=0;i<L1.Length();i++)\n     {\n      if(L1.Substr(i,1) == \",\") num_columns++;\n     }\n   \n   //Abre o arquivo para ser lido\n   int h=FileOpen(csv_name,FILE_READ|FILE_ANSI|FILE_CSV,\",\");\n   //Se o arquivo n\u00e3o \u00e9 aberto devidamente o handle \u00e9 inv\u00e1lido\n   if(h==INVALID_HANDLE)   Alert(\"Error opening file\");\n\n   string read_x;\n   string m[]; //Vetor que receber\u00e1 os dados\n   int    m_size = 0;\n   \n   matrix A;   // Matriz que retornar\u00e1 com os dados\n   int A_size = 0;\n   //Come\u00e7a com a leitura da primeira linha\n   \n   while(!FileIsEnding(h))\n   {\n      ArrayResize(m,m_size+1);\n      read_x = FileReadString(h);   // L\u00ea o conteudo at\u00e9 a virgula \u00e9 passa pra pr\u00f3xima\n      m[m_size] = read_x;\n   if(!FileIsEnding(h)) m_size++;  \n   }\n   FileClose(h);\n   \n   int num_rows;\n   num_rows = (m_size + 1)/num_columns;\n   \n   if(((m_size +1)% num_columns) != 0 )   Alert(\"Error the matrix data is incomplete\");\n   else\n   {\n   \n   //Preparar a Matriz A\n   A.Init(num_rows,num_columns);\n   \n   for(int i=0;i<num_rows;i++)\n      {for(int j=0;j<num_columns;j++)\n        {A[i][j] = StringToDouble(m[i * num_columns + j]);}}         \n   //==========\n   }\nreturn A;\n}\nmatrix DeepLearning::Concatenate(matrix &X,matrix &H)\n{\nif(X.Cols() != H.Cols()) Alert(\"The number of Cols of X and H must be equal\");\n\nmatrix M;\nM.Init(X.Rows() + H.Rows(),X.Cols());\n\nulong lim;\nlim = X.Rows();\n\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(i < lim) M[i][j] = X[i][j];\n      if(i >= lim) M[i][j] = H[i-lim][j];}}\n      \nreturn M;\n}\n\n//+------------------------------------------------------------------+\n//|    Convolutional Methodes                                        |\n//+------------------------------------------------------------------+\n\nmatrix DeepLearning::VertConvV(matrix &A,matrix &B)\n{\nif(A.Cols() != B.Cols())\n  {Alert(\"matrices with different number of Columns\");\n  return A*0;\n  }\nmatrix U,D,C;\nU = A;\nD = B;\nif(U.Rows() < D.Rows())\n  {C = U;\n   U = D;\n   D = C;\n   }\nD = VertInv(D);\n\nmatrix Conv; \nConv.Init(U.Rows()-D.Rows()+1,U.Cols());\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n      \n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {for(int k=0;k<D.Rows();k++)\n        {Conv[i][j] = Conv[i][j] + U[i+k][j]*D[k][j];}}}\n      \nreturn Conv;\n}\nmatrix DeepLearning::HorConvV(matrix &A,matrix &B)\n{\nif(A.Rows() != B.Rows())\n  {Alert(\"matrices with different number of Rows\");\n  return A*0;\n  }\nmatrix U,D,C;\nU = A;\nD = B;\nif(U.Cols() < D.Cols())\n  {C = U;\n   U = D;\n   D = C;\n   }\nD = HorInv(D);\n\nmatrix Conv; \nConv.Init(U.Rows(), U.Cols() - D.Cols() + 1);\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n      \n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {for(int k=0;k<D.Cols();k++)\n        {Conv[i][j] += U[i][j+k]*D[i][k];}}}\n      \nreturn Conv;\n}\nmatrix DeepLearning::VertConvF(matrix &A,matrix &B)\n{\nif(A.Cols() != B.Cols())\n  {Alert(\"matrices with different number of Columns\");\n  return A*0;\n  }\n\nmatrix U,D,E;\n\nU = A;\nD = B;\n\nif(U.Rows() < D.Rows())\n  {E = U;\n   U = D;\n   D = E;\n   }\nmatrix Conv;\nConv.Init(U.Rows()+2*D.Rows()-2,U.Cols());\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n\nulong c = B.Rows()-1;\nfor(int i=c;i<Conv.Rows()-c;i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {\n      Conv[i][j] = U[i-c][j];\n     }\n   \n  }\n\nmatrix CF;\n   CF= VertConvV(Conv,D);\nreturn CF;\n}\nmatrix DeepLearning::HorConvF(matrix &A,matrix &B)\n{\nif(A.Rows() != B.Rows())\n  {Alert(\"matrices with different number of Rows\");\n  return A*0;\n  }\n\nmatrix U,D,E;\n\nU = A;\nD = B;\n\nif(U.Rows() < D.Rows())\n  {E = U;\n   U = D;\n   D = E;\n   }\nmatrix Conv;\nConv.Init(U.Rows(),U.Cols() + 2*D.Cols() -2);\n\n//Zera a matriz\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=0;j<Conv.Cols();j++)\n     {Conv[i][j] = 0;}}\n\nulong c = B.Cols()-1;\n\nfor(int i=0;i<Conv.Rows();i++)\n  {for(int j=c;j<Conv.Cols()-c;j++)\n     {\n      Conv[i][j] = U[i][j-c];\n     }\n   \n  }\n\nmatrix CF;\n   CF= HorConvV(Conv,D);\nreturn CF;\n}\nmatrix DeepLearning::VertInv(matrix &A)\n{\nmatrix B;\nB.Init(A.Rows(),A.Cols());\nfor(int i=0;i<A.Rows();i++)\n  {for(int j=0;j<A.Cols();j++)\n     {B[i][j] = A[A.Rows()-i-1][j];}}\n\n\nreturn B;\n}\nmatrix DeepLearning::HorInv(matrix &A)\n{\nmatrix B;\nB.Init(A.Rows(),A.Cols());\nfor(int i=0;i<A.Rows();i++)\n  {for(int j=0;j<A.Cols();j++)\n     {B[i][j] = A[i][A.Cols()-j-1];}}\n\n\nreturn B;\n}\n\n//+------------------------------------------------------------------+\n//|    Activation Methodes                                           |\n//+------------------------------------------------------------------+\n\nmatrix DeepLearning::Sig(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = 1.0/(1.0 + MathExp((-1)*M[i][j]));}}\n     \nreturn M;\n      \n}\nmatrix DeepLearning::Tanh(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = (MathExp(M[i][j])-MathExp((-1.0)*M[i][j]))/(MathExp(M[i][j])+MathExp((-1.0)*M[i][j]));}}\n     \nreturn M;\n}\nmatrix DeepLearning::ReLU(matrix &X)\n{\nmatrix M;\nM = X; \nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(M[i][j] > 0) M[i][j] = M[i][j];\n      if(M[i][j] <=0) M[i][j] = 0.01*M[i][j];}}\n\nreturn M;     \n}\n\nmatrix DeepLearning::dSig(matrix &X)\n{\nmatrix M;\nM = X; \n\nM = Sig(M);\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = M[i][j]*(1.0 - M[i][j]);}}\n\nreturn M;  \n}\nmatrix DeepLearning::dTanh(matrix &X)\n{\nmatrix M;\nM = X; \n\nM = Tanh(M);\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {M[i][j] = (1.0 - M[i][j]*M[i][j]);}}\n\nreturn M;  \n}\nmatrix DeepLearning::dReLU(matrix &X)\n{\nmatrix M;\nM = X;\nfor(int i=0;i<M.Rows();i++)\n  {for(int j=0;j<M.Cols();j++)\n     {if(M[i][j] > 0) M[i][j] = 1;\n      if(M[i][j] <= 0) M[i][j] = 0.01;}}\n      \nreturn M;\n}\n//+------------------------------------------------------------------+\n//|   Optimizers                                                     |\n//+------------------------------------------------------------------+\nmatrix DeepLearning::AdamM(matrix &m, matrix &dX,double beta1)\n{\nmatrix mt;\nmt.Init(dX.Rows(),dX.Cols());\nmt = m * beta1;\nmt = mt + dX * (1-beta1);\nreturn mt;\n}\nmatrix  DeepLearning::AdamV(matrix &v, matrix &dX,double beta2)\n{\nmatrix vt;\nvt = beta2*v;\nvt = vt + dX * dX * (1-beta2);\nreturn vt; \n}\nmatrix DeepLearning::Adam(double it, matrix &m, matrix &v,double beta1,double beta2, double alpha)\n{\nmatrix D, mt, vt; \n\nmt = m * (1/(1-MathPow(beta1,it)));\nvt = v * (1/(1-MathPow(beta2,it)));\n\nvt = MathSqrt(vt) + 1e-8; \nD = m / vt;\nD = D * alpha;\nreturn D; \n}\n\n#include <Layers\\LossLayer.mqh>\n#include <Layers\\MetricsLayer.mqh>\n\n#include <Layers\\DenseLayer.mqh>\n#include <Layers\\ActivationLayer.mqh>\n#include <Layers\\DropoutLayer.mqh>\n\n#include <Layers\\ConvolutionalLayer.mqh>\n#include <Layers\\MaxPoolingLayer.mqh>\n#include <Layers\\FlattenLayer.mqh>\n#include <Layers\\SumConvLayer.mqh>\n\n#include <Layers\\LSTMLayer.mqh>\n#include <Layers\\BiLSTMLayer.mqh>\n\n\n\n\n\n\n\n\n\n"}, {"filename": "README.md", "path": "new_knowledge/Deep-Learning-for-MQL5-master/README.md", "content": "<img src=\"https://github.com/joaopaulo-souza/Deep-Learning-for-MQL5/blob/master/robot-trader.jpeg\">\n\n# Deep Learning for MetaTrader5\n\nIntroducing a cutting-edge DeepLearning library tailor-made for MetaTrader 5 users. This library is equipped with some of the most advanced machine learning neural networks to enhance the trading experience and the making of expert advisors. \n\nThe array of features includes:\n\n* **Dense Layer**: Ensuring robust connections and optimal information flow.\n* **Dropout Layer**: Enhancing model reliability by preventing overfitting.\n* **Convolutional Layer**: Perfect for extracting intricate patterns from your data.\n* **Max Pooling Layer**: Reducing dimensionality while retaining crucial information.\n* **Concatenation Layer**: Seamlessly merging different layers for a comprehensive analysis.\n* **LSTM Layer**: Leveraging long-term dependencies for superior sequence prediction.\n* **BiLSTM Layer**: Capturing both past and future data trends for more accurate forecasting.\n* **Flatten Layer**: Streamlining your data for final output processing.\n\nThe file DeepLearning.mqh must be stored in the includes directory of MetaTrader5\nThe file TimeSeries.mqh must be stored in the includes directory of MetaTrader5\nThe directory Layers must also be stored in the includes directory of MetaTrader5\n\nThe file Example.mq5 is an example of use of the library. And must be stored in Experts directory of MetaTrader5\n\nThe file Delhi.csv is the dataset used. And must be stored in Files directory of MetaTrader5 \n\n**The instructions of how to use the library are given in the Example.mq5 file. And also explained in the DeepLearning.mqh and TimeSeries.mqh files**\n\nFurther explanation of the dataset can be found in: \nhttps://www.kaggle.com/datasets/mahirkukreja/delhi-weather-data\n\n\n", "search_content": "<img src=\"https://github.com/joaopaulo-souza/Deep-Learning-for-MQL5/blob/master/robot-trader.jpeg\">\n\n# Deep Learning for MetaTrader5\n\nIntroducing a cutting-edge DeepLearning library tailor-made for MetaTrader 5 users. This library is equipped with some of the most advanced machine learning neural networks to enhance the trading experience and the making of expert advisors. \n\nThe array of features includes:\n\n* **Dense Layer**: Ensuring robust connections and optimal information flow.\n* **Dropout Layer**: Enhancing model reliability by preventing overfitting.\n* **Convolutional Layer**: Perfect for extracting intricate patterns from your data.\n* **Max Pooling Layer**: Reducing dimensionality while retaining crucial information.\n* **Concatenation Layer**: Seamlessly merging different layers for a comprehensive analysis.\n* **LSTM Layer**: Leveraging long-term dependencies for superior sequence prediction.\n* **BiLSTM Layer**: Capturing both past and future data trends for more accurate forecasting.\n* **Flatten Layer**: Streamlining your data for final output processing.\n\nThe file DeepLearning.mqh must be stored in the includes directory of MetaTrader5\nThe file TimeSeries.mqh must be stored in the includes directory of MetaTrader5\nThe directory Layers must also be stored in the includes directory of MetaTrader5\n\nThe file Example.mq5 is an example of use of the library. And must be stored in Experts directory of MetaTrader5\n\nThe file Delhi.csv is the dataset used. And must be stored in Files directory of MetaTrader5 \n\n**The instructions of how to use the library are given in the Example.mq5 file. And also explained in the DeepLearning.mqh and TimeSeries.mqh files**\n\nFurther explanation of the dataset can be found in: \nhttps://www.kaggle.com/datasets/mahirkukreja/delhi-weather-data\n\n\n"}, {"filename": "DeepLearningLibrary.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/DeepLearningLibrary.mqh", "content": "enum ActFunction\n  {\n   SIGMOID,\n   TANH,\n   RELU,\n  };\n  \nenum Optim\n  {\n   STD,\n   ADAM,\n  };\n  \nenum CONV_DIR\n  {\n   VERT,\n   HORZ,\n  };", "search_content": "enum ActFunction\n  {\n   SIGMOID,\n   TANH,\n   RELU,\n  };\n  \nenum Optim\n  {\n   STD,\n   ADAM,\n  };\n  \nenum CONV_DIR\n  {\n   VERT,\n   HORZ,\n  };"}, {"filename": "LICENSE.txt", "path": "new_knowledge/Deep-Learning-for-MQL5-master/LICENSE.txt", "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.", "search_content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>."}, {"filename": "TimeSeriesData.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/TimeSeriesData.mqh", "content": "#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000<\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000\\\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000 \u0000c\u0000a\u0000n\u0000v\u0000a\u0000s\u0000;\u0000\n\u0000\n\u0000#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000 \u0000<\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000s\u0000\\\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000/\u0000/\u0000-\u0000-\u0000-\u0000\n\u0000\n\u0000\n\u0000\n\u0000c\u0000l\u0000a\u0000s\u0000s\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000p\u0000u\u0000b\u0000l\u0000i\u0000c\u0000:\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000o\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000l\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000d\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000E\u0000s\u0000c\u0000r\u0000e\u0000v\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000W\u0000r\u0000i\u0000t\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000,\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000c\u0000o\u0000m\u0000 \u0000o\u0000s\u0000 \u0000p\u0000a\u0000s\u0000s\u0000o\u0000s\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000m\u0000p\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000p\u0000a\u0000s\u0000s\u0000a\u0000r\u0000 \u0000p\u0000e\u0000l\u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000r\u0000e\u0000a\u0000l\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000a\u0000r\u0000 \u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000s\u0000 \u0000s\u0000a\u0000\u0000d\u0000a\u0000s\u0000 \u0000r\u0000e\u0000a\u0000i\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000a\u0000 \u0000o\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000r\u0000a\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000a\u0000 \u0000m\u0000\u0000d\u0000i\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000e\u0000a\u0000n\u0000 \u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\u0000x\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000a\u0000x\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\u0000n\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000}\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000/\u0000/\u0000|\u0000 \u0000 \u0000 \u0000M\u0000e\u0000t\u0000h\u0000o\u0000d\u0000e\u0000s\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000|\u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000X\u0000;\u0000 \u0000\n\u0000\n\u0000X\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000r\u0000=\u0000i\u0000;\u0000r\u0000<\u0000i\u0000+\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000r\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000r\u0000-\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000r\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000X\u0000 \u0000=\u0000 \u0000X\u0000.\u0000T\u0000r\u0000a\u0000n\u0000s\u0000p\u0000o\u0000s\u0000e\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000;\u0000\n\u0000\n\u0000Y\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u00001\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000Y\u0000[\u00000\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000+\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000i\u0000<\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000i\u0000n\u0000t\u0000 \u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000E\u0000n\u0000t\u0000r\u0000a\u0000d\u0000a\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000x\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000x\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000x\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000i\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000S\u0000a\u0000\u0000d\u0000a\u0000s\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000y\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000y\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000y\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000[\u0000i\u0000]\u0000[\u0000c\u0000o\u0000l\u0000u\u0000m\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000*\u0000b\u0000o\u0000o\u0000l\u0000 \u0000 \u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000l\u0000o\u0000n\u0000g\u0000 \u0000 \u0000 \u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000 \u0000I\u0000D\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000 \u0000n\u0000a\u0000m\u0000e\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000n\u0000a\u0000m\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000u\u0000b\u0000w\u0000i\u0000n\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000u\u0000b\u0000-\u0000w\u0000i\u0000n\u0000d\u0000o\u0000w\u0000 \u0000i\u0000n\u0000d\u0000e\u0000x\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00002\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00002\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000)\u0000*\u0000/\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000A\u0000 \u0000f\u0000u\u0000n\u0000\u0000\u0000o\u0000 \u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000 \u0000\u0000 \u0000d\u0000a\u0000d\u0000a\u0000 \u0000a\u0000c\u0000i\u0000m\u0000a\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u00000\u0000,\u0000\"\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000\"\u0000,\u00000\u0000,\u00003\u00000\u0000,\u00003\u00000\u0000,\u00001\u00005\u00000\u00000\u0000,\u00009\u00000\u00000\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000d\u0000i\u0000c\u0000i\u0000o\u0000n\u0000a\u0000 \u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000 \u0000n\u0000a\u0000 \u0000c\u0000u\u0000r\u0000v\u0000a\u0000.\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000y\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000O\u0000s\u0000 \u0000t\u0000r\u0000e\u0000c\u0000h\u0000o\u0000s\u0000 \u0000\"\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000\"\u0000 \u0000n\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00002\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u00000\u0000,\u0000y\u00002\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000\u0000o\u0000 \u0000n\u0000e\u0000c\u0000e\u0000s\u0000s\u0000\u0000r\u0000i\u0000o\u0000s\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000u\u0000d\u0000a\u0000 \u0000o\u0000s\u0000 \u0000n\u0000o\u0000m\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000X\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000m\u0000 \u0000o\u0000 \u0000t\u0000a\u0000m\u0000a\u0000n\u0000h\u0000o\u0000 \u0000d\u0000a\u0000 \u0000f\u0000o\u0000n\u0000t\u0000e\u0000,\u0000 \u0000n\u0000\u0000o\u0000 \u0000f\u0000u\u0000n\u0000c\u0000i\u0000o\u0000n\u0000a\u0000.\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000Y\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000P\u0000l\u0000o\u0000t\u0000A\u0000l\u0000l\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000U\u0000p\u0000d\u0000a\u0000t\u0000e\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000P\u0000l\u0000o\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000]\u0000,\u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000]\u0000,\u0000x\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000,\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000x\u0000,\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000i\u0000f\u0000(\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000)\u0000 \u0000!\u0000=\u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000P\u0000r\u0000i\u0000n\u0000t\u0000(\u0000\"\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000 \u0000a\u0000n\u0000d\u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000 \u0000w\u0000i\u0000t\u0000h\u0000 \u0000d\u0000i\u0000f\u0000e\u0000r\u0000e\u0000n\u0000t\u0000 \u0000s\u0000i\u0000z\u0000e\u0000s\u0000\"\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000E\u0000s\u0000c\u0000r\u0000e\u0000v\u0000e\u0000 \u0000o\u0000s\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000e\u0000s\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000e\u0000m\u0000 \u0000p\u0000l\u0000o\u0000t\u0000a\u0000d\u0000o\u0000s\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000x\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000i\u0000;\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000]\u0000[\u00000\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000i\u0000]\u0000[\u00000\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000*\u0000b\u0000o\u0000o\u0000l\u0000 \u0000 \u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000l\u0000o\u0000n\u0000g\u0000 \u0000 \u0000 \u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000 \u0000I\u0000D\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000 \u0000n\u0000a\u0000m\u0000e\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000n\u0000a\u0000m\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000u\u0000b\u0000w\u0000i\u0000n\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000u\u0000b\u0000-\u0000w\u0000i\u0000n\u0000d\u0000o\u0000w\u0000 \u0000i\u0000n\u0000d\u0000e\u0000x\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00002\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00002\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000)\u0000*\u0000/\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000A\u0000 \u0000f\u0000u\u0000n\u0000\u0000\u0000o\u0000 \u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000 \u0000\u0000 \u0000d\u0000a\u0000d\u0000a\u0000 \u0000a\u0000c\u0000i\u0000m\u0000a\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u00000\u0000,\u0000\"\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000\"\u0000,\u00000\u0000,\u00003\u00000\u0000,\u00003\u00000\u0000,\u00009\u00005\u00000\u0000,\u00005\u00005\u00000\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000d\u0000i\u0000c\u0000i\u0000o\u0000n\u0000a\u0000 \u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000 \u0000n\u0000a\u0000 \u0000c\u0000u\u0000r\u0000v\u0000a\u0000.\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000O\u0000s\u0000 \u0000t\u0000r\u0000e\u0000c\u0000h\u0000o\u0000s\u0000 \u0000\"\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000\"\u0000 \u0000n\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00002\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000\u0000o\u0000 \u0000n\u0000e\u0000c\u0000e\u0000s\u0000s\u0000\u0000r\u0000i\u0000o\u0000s\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000u\u0000d\u0000a\u0000 \u0000o\u0000s\u0000 \u0000n\u0000o\u0000m\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000X\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000m\u0000 \u0000o\u0000 \u0000t\u0000a\u0000m\u0000a\u0000n\u0000h\u0000o\u0000 \u0000d\u0000a\u0000 \u0000f\u0000o\u0000n\u0000t\u0000e\u0000,\u0000 \u0000n\u0000\u0000o\u0000 \u0000f\u0000u\u0000n\u0000c\u0000i\u0000o\u0000n\u0000a\u0000.\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000Y\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000P\u0000l\u0000o\u0000t\u0000A\u0000l\u0000l\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000U\u0000p\u0000d\u0000a\u0000t\u0000e\u0000(\u0000)\u0000;\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000X\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000X\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000a\u0000n\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000s\u0000t\u0000d\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000i\u0000n\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000e\u0000a\u0000n\u0000 \u0000=\u0000 \u0000M\u0000e\u0000a\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000_\u0000f\u0000i\u0000l\u0000t\u0000e\u0000r\u0000 \u0000=\u00003\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000a\u0000 \u0000m\u0000\u0000d\u0000i\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000-\u0000 \u0000m\u0000e\u0000a\u0000n\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000o\u0000s\u0000 \u0000O\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000l\u0000=\u00000\u0000;\u0000l\u0000<\u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000_\u0000f\u0000i\u0000l\u0000t\u0000e\u0000r\u0000;\u0000l\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000c\u0000a\u0000m\u0000a\u0000d\u0000a\u0000 \u0000d\u0000e\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000M\u0000a\u0000t\u0000h\u0000A\u0000b\u0000s\u0000(\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000>\u0000 \u00003\u0000*\u0000s\u0000t\u0000d\u0000)\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u00000\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000I\u0000n\u0000t\u0000e\u0000r\u0000p\u0000o\u0000l\u0000a\u0000 \u0000o\u0000s\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000=\u0000 \u00000\u0000)\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000(\u0000X\u0000[\u0000i\u0000-\u00001\u0000]\u0000[\u0000j\u0000]\u0000 \u0000+\u0000 \u0000X\u0000[\u0000i\u0000+\u00001\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000/\u0000 \u00002\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000R\u0000e\u0000c\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000i\u0000v\u0000i\u0000d\u0000e\u0000 \u0000p\u0000e\u0000l\u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000/\u0000s\u0000t\u0000d\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u0000M\u0000a\u0000x\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u0000M\u0000i\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000(\u00001\u0000.\u00005\u0000 \u0000*\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000/\u0000(\u0000m\u0000a\u0000x\u0000 \u0000-\u0000 \u0000m\u0000i\u0000n\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000e\u0000a\u0000n\u0000 \u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000M\u0000 \u0000=\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000m\u0000e\u0000 \u0000=\u0000 \u0000m\u0000e\u0000 \u0000+\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u0000m\u0000e\u0000 \u0000/\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000M\u0000 \u0000=\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000s\u0000t\u0000d\u0000;\u0000\n\u0000\n\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000,\u0000s\u0000u\u0000m\u0000;\u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000e\u0000a\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000-\u00001\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u0000s\u0000u\u0000m\u0000 \u0000+\u0000 \u0000M\u0000a\u0000t\u0000h\u0000P\u0000o\u0000w\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000-\u0000m\u0000e\u0000,\u00002\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u0000s\u0000u\u0000m\u0000 \u0000/\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000M\u0000a\u0000t\u0000h\u0000S\u0000q\u0000r\u0000t\u0000(\u0000s\u0000u\u0000m\u0000)\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000s\u0000t\u0000d\u0000;\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000i\u0000n\u0000;\u0000 \u0000\n\u0000\n\u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000<\u0000 \u0000m\u0000i\u0000n\u0000)\u0000 \u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000i\u0000n\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000a\u0000x\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000>\u0000 \u0000m\u0000a\u0000x\u0000)\u0000 \u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000R\u0000e\u0000a\u0000d\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u0000e\u0000 \u0000a\u0000p\u0000e\u0000n\u0000a\u0000s\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000a\u0000b\u0000e\u0000r\u0000 \u0000o\u0000 \u0000n\u0000\u0000m\u0000e\u0000r\u0000o\u0000 \u0000d\u0000e\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000L\u00001\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u00001\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000R\u0000E\u0000A\u0000D\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000T\u0000X\u0000T\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\u0000o\u0000 \u0000\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\u0000 \u0000i\u0000n\u0000v\u0000\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u00001\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000L\u00001\u0000 \u0000=\u0000 \u0000F\u0000i\u0000l\u0000e\u0000R\u0000e\u0000a\u0000d\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000h\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u00001\u0000 \u0000p\u0000o\u0000s\u0000s\u0000u\u0000i\u0000 \u0000a\u0000g\u0000o\u0000r\u0000a\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000 \u0000d\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u0000\u0000 \u0000q\u0000u\u0000a\u0000n\u0000t\u0000a\u0000s\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000s\u0000 \u0000s\u0000\u0000o\u0000 \u0000p\u0000e\u0000l\u0000o\u0000 \u0000n\u0000\u0000m\u0000e\u0000r\u0000o\u0000 \u0000d\u0000e\u0000 \u0000v\u0000\u0000r\u0000g\u0000u\u0000l\u0000a\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000 \u0000=\u0000 \u00001\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000L\u00001\u0000.\u0000L\u0000e\u0000n\u0000g\u0000t\u0000h\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000L\u00001\u0000.\u0000S\u0000u\u0000b\u0000s\u0000t\u0000r\u0000(\u0000i\u0000,\u00001\u0000)\u0000 \u0000=\u0000=\u0000 \u0000\"\u0000,\u0000\"\u0000)\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000+\u0000+\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000R\u0000E\u0000A\u0000D\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000C\u0000S\u0000V\u0000,\u0000\"\u0000,\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\u0000o\u0000 \u0000\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\u0000 \u0000i\u0000n\u0000v\u0000\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000m\u0000[\u0000]\u0000;\u0000 \u0000/\u0000/\u0000V\u0000e\u0000t\u0000o\u0000r\u0000 \u0000q\u0000u\u0000e\u0000 \u0000r\u0000e\u0000c\u0000e\u0000b\u0000e\u0000r\u0000\u0000 \u0000o\u0000s\u0000 \u0000d\u0000a\u0000d\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000A\u0000;\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000M\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000q\u0000u\u0000e\u0000 \u0000r\u0000e\u0000t\u0000o\u0000r\u0000n\u0000a\u0000r\u0000\u0000 \u0000c\u0000o\u0000m\u0000 \u0000o\u0000s\u0000 \u0000d\u0000a\u0000d\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000A\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000o\u0000m\u0000e\u0000\u0000a\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000 \u0000l\u0000e\u0000i\u0000t\u0000u\u0000r\u0000a\u0000 \u0000d\u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000w\u0000h\u0000i\u0000l\u0000e\u0000(\u0000!\u0000F\u0000i\u0000l\u0000e\u0000I\u0000s\u0000E\u0000n\u0000d\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000m\u0000,\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000+\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000 \u0000=\u0000 \u0000F\u0000i\u0000l\u0000e\u0000R\u0000e\u0000a\u0000d\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000;\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000L\u0000\u0000 \u0000o\u0000 \u0000c\u0000o\u0000n\u0000t\u0000e\u0000u\u0000d\u0000o\u0000 \u0000a\u0000t\u0000\u0000 \u0000a\u0000 \u0000v\u0000i\u0000r\u0000g\u0000u\u0000l\u0000a\u0000 \u0000\u0000 \u0000p\u0000a\u0000s\u0000s\u0000a\u0000 \u0000p\u0000r\u0000a\u0000 \u0000p\u0000r\u0000\u0000x\u0000i\u0000m\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000m\u0000[\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000]\u0000 \u0000=\u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000!\u0000F\u0000i\u0000l\u0000e\u0000I\u0000s\u0000E\u0000n\u0000d\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000)\u0000 \u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000+\u0000+\u0000;\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000 \u0000=\u0000 \u0000(\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000+\u0000 \u00001\u0000)\u0000/\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000(\u0000(\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000+\u00001\u0000)\u0000%\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000)\u0000 \u0000!\u0000=\u0000 \u00000\u0000 \u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000t\u0000h\u0000e\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000d\u0000a\u0000t\u0000a\u0000 \u0000i\u0000s\u0000 \u0000i\u0000n\u0000c\u0000o\u0000m\u0000p\u0000l\u0000e\u0000t\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000e\u0000l\u0000s\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000r\u0000e\u0000p\u0000a\u0000r\u0000a\u0000r\u0000 \u0000a\u0000 \u0000M\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000A\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000A\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000,\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000A\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000T\u0000o\u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000(\u0000m\u0000[\u0000i\u0000 \u0000*\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000 \u0000+\u0000 \u0000j\u0000]\u0000)\u0000;\u0000}\u0000}\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000A\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000W\u0000r\u0000i\u0000t\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000,\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000t\u0000r\u0000a\u0000n\u0000s\u0000f\u0000o\u0000r\u0000m\u0000a\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000 \u0000n\u0000u\u0000m\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000d\u0000e\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000S\u0000r\u0000o\u0000w\u0000s\u0000 \u0000,\u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000S\u0000r\u0000o\u0000w\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000V\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000V\u0000,\u0000S\u0000r\u0000o\u0000w\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000Z\u0000e\u0000r\u0000a\u0000 \u0000o\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000d\u0000e\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000V\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000N\u0000U\u0000L\u0000L\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000r\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000o\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000s\u0000 \u0000c\u0000l\u0000a\u0000s\u0000s\u0000e\u0000s\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000S\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000S\u0000C\u0000o\u0000l\u0000s\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000j\u0000 \u0000=\u0000=\u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000-\u00001\u0000)\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000+\u0000 \u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000T\u0000o\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000e\u0000l\u0000s\u0000e\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000+\u0000 \u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000T\u0000o\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000+\u0000 \u0000\"\u0000,\u0000\"\u0000;\u0000}\u0000}\u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000e\u0000s\u0000c\u0000r\u0000i\u0000t\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000W\u0000R\u0000I\u0000T\u0000E\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000C\u0000S\u0000V\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\u0000o\u0000 \u0000\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\u0000 \u0000i\u0000n\u0000v\u0000\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000S\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000W\u0000r\u0000i\u0000t\u0000e\u0000(\u0000h\u0000,\u0000V\u0000[\u0000i\u0000]\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u0000)\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000 \u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000*\u0000(\u00001\u0000-\u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000,\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000-\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000/\u0000/\u0000i\u0000f\u0000(\u0000i\u0000 \u0000<\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000i\u0000 \u0000>\u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000}\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000r\u0000a\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000 \u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000*\u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000,\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000-\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000i\u0000 \u0000<\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000i\u0000f\u0000(\u0000i\u0000 \u0000>\u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000;\u0000\n\u0000\n\u0000}\u0000", "search_content": "#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000<\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000\\\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000C\u0000a\u0000n\u0000v\u0000a\u0000s\u0000 \u0000c\u0000a\u0000n\u0000v\u0000a\u0000s\u0000;\u0000\n\u0000\n\u0000#\u0000i\u0000n\u0000c\u0000l\u0000u\u0000d\u0000e\u0000 \u0000<\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000s\u0000\\\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000m\u0000q\u0000h\u0000>\u0000\n\u0000\n\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000/\u0000/\u0000-\u0000-\u0000-\u0000\n\u0000\n\u0000\n\u0000\n\u0000c\u0000l\u0000a\u0000s\u0000s\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000p\u0000u\u0000b\u0000l\u0000i\u0000c\u0000:\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000o\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000a\u0000r\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000P\u0000l\u0000o\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000l\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000d\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000E\u0000s\u0000c\u0000r\u0000e\u0000v\u0000e\u0000r\u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000W\u0000r\u0000i\u0000t\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000,\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000c\u0000o\u0000m\u0000 \u0000o\u0000s\u0000 \u0000p\u0000a\u0000s\u0000s\u0000o\u0000s\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000m\u0000p\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000p\u0000a\u0000s\u0000s\u0000a\u0000r\u0000 \u0000p\u0000e\u0000l\u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000r\u0000e\u0000a\u0000l\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000a\u0000r\u0000 \u0000a\u0000 \u0000r\u0000e\u0000d\u0000e\u0000 \u0000n\u0000e\u0000u\u0000r\u0000a\u0000l\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000e\u0000v\u0000o\u0000l\u0000v\u0000e\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000s\u0000 \u0000s\u0000a\u0000\u0000d\u0000a\u0000s\u0000 \u0000r\u0000e\u0000a\u0000i\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000a\u0000 \u0000o\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000e\u0000s\u0000t\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000u\u0000m\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000,\u0000 \u0000s\u0000e\u0000g\u0000u\u0000n\u0000d\u0000o\u0000 \u0000a\u0000 \u0000p\u0000o\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000m\u0000 \u0000d\u0000e\u0000 \u0000t\u0000r\u0000e\u0000i\u0000n\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000r\u0000a\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000a\u0000 \u0000m\u0000\u0000d\u0000i\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000e\u0000a\u0000n\u0000 \u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\u0000x\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000a\u0000x\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000C\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000 \u0000m\u0000\u0000n\u0000i\u0000m\u0000o\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000 \u0000d\u0000e\u0000 \u0000u\u0000m\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000M\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000}\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000/\u0000/\u0000|\u0000 \u0000 \u0000 \u0000M\u0000e\u0000t\u0000h\u0000o\u0000d\u0000e\u0000s\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000|\u0000\n\u0000\n\u0000/\u0000/\u0000+\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000-\u0000+\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000F\u0000e\u0000a\u0000t\u0000u\u0000r\u0000e\u0000s\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000X\u0000;\u0000 \u0000\n\u0000\n\u0000X\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000r\u0000=\u0000i\u0000;\u0000r\u0000<\u0000i\u0000+\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000r\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000r\u0000-\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000r\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000X\u0000 \u0000=\u0000 \u0000X\u0000.\u0000T\u0000r\u0000a\u0000n\u0000s\u0000p\u0000o\u0000s\u0000e\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000R\u0000e\u0000a\u0000l\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000(\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000i\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000;\u0000\n\u0000\n\u0000Y\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u00001\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000Y\u0000[\u00000\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000+\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000O\u0000u\u0000t\u0000p\u0000u\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000,\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000;\u0000i\u0000<\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000t\u0000e\u0000p\u0000s\u0000]\u0000[\u00000\u0000]\u0000 \u0000=\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000P\u0000l\u0000o\u0000t\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000i\u0000n\u0000t\u0000 \u0000c\u0000o\u0000l\u0000u\u0000m\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000i\u0000n\u0000t\u0000 \u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000N\u0000_\u0000e\u0000n\u0000t\u0000r\u0000i\u0000e\u0000s\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000E\u0000n\u0000t\u0000r\u0000a\u0000d\u0000a\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000x\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000x\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000x\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000i\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000S\u0000a\u0000\u0000d\u0000a\u0000s\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000y\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000y\u0000,\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000y\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000[\u0000i\u0000]\u0000[\u0000c\u0000o\u0000l\u0000u\u0000m\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000*\u0000b\u0000o\u0000o\u0000l\u0000 \u0000 \u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000l\u0000o\u0000n\u0000g\u0000 \u0000 \u0000 \u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000 \u0000I\u0000D\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000 \u0000n\u0000a\u0000m\u0000e\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000n\u0000a\u0000m\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000u\u0000b\u0000w\u0000i\u0000n\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000u\u0000b\u0000-\u0000w\u0000i\u0000n\u0000d\u0000o\u0000w\u0000 \u0000i\u0000n\u0000d\u0000e\u0000x\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00002\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00002\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000)\u0000*\u0000/\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000A\u0000 \u0000f\u0000u\u0000n\u0000\u0000\u0000o\u0000 \u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000 \u0000\u0000 \u0000d\u0000a\u0000d\u0000a\u0000 \u0000a\u0000c\u0000i\u0000m\u0000a\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u00000\u0000,\u0000\"\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000\"\u0000,\u00000\u0000,\u00003\u00000\u0000,\u00003\u00000\u0000,\u00001\u00005\u00000\u00000\u0000,\u00009\u00000\u00000\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000d\u0000i\u0000c\u0000i\u0000o\u0000n\u0000a\u0000 \u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000 \u0000n\u0000a\u0000 \u0000c\u0000u\u0000r\u0000v\u0000a\u0000.\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000y\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000O\u0000s\u0000 \u0000t\u0000r\u0000e\u0000c\u0000h\u0000o\u0000s\u0000 \u0000\"\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000\"\u0000 \u0000n\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00002\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u00000\u0000,\u0000y\u00002\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000\u0000o\u0000 \u0000n\u0000e\u0000c\u0000e\u0000s\u0000s\u0000\u0000r\u0000i\u0000o\u0000s\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000u\u0000d\u0000a\u0000 \u0000o\u0000s\u0000 \u0000n\u0000o\u0000m\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000X\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000m\u0000 \u0000o\u0000 \u0000t\u0000a\u0000m\u0000a\u0000n\u0000h\u0000o\u0000 \u0000d\u0000a\u0000 \u0000f\u0000o\u0000n\u0000t\u0000e\u0000,\u0000 \u0000n\u0000\u0000o\u0000 \u0000f\u0000u\u0000n\u0000c\u0000i\u0000o\u0000n\u0000a\u0000.\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000Y\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000P\u0000l\u0000o\u0000t\u0000A\u0000l\u0000l\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000U\u0000p\u0000d\u0000a\u0000t\u0000e\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000 \u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000P\u0000l\u0000o\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000]\u0000,\u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000]\u0000,\u0000x\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000,\u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000x\u0000,\u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000i\u0000f\u0000(\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000)\u0000 \u0000!\u0000=\u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000)\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000P\u0000r\u0000i\u0000n\u0000t\u0000(\u0000\"\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000 \u0000a\u0000n\u0000d\u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000 \u0000w\u0000i\u0000t\u0000h\u0000 \u0000d\u0000i\u0000f\u0000e\u0000r\u0000e\u0000n\u0000t\u0000 \u0000s\u0000i\u0000z\u0000e\u0000s\u0000\"\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000E\u0000s\u0000c\u0000r\u0000e\u0000v\u0000e\u0000 \u0000o\u0000s\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000e\u0000s\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000e\u0000m\u0000 \u0000p\u0000l\u0000o\u0000t\u0000a\u0000d\u0000o\u0000s\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000x\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000i\u0000;\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000[\u0000i\u0000]\u0000[\u00000\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000[\u0000i\u0000]\u0000[\u00000\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000/\u0000/\u0000P\u0000l\u0000o\u0000t\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000*\u0000b\u0000o\u0000o\u0000l\u0000 \u0000 \u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000l\u0000o\u0000n\u0000g\u0000 \u0000 \u0000 \u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000c\u0000h\u0000a\u0000r\u0000t\u0000 \u0000I\u0000D\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000 \u0000n\u0000a\u0000m\u0000e\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000n\u0000a\u0000m\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000u\u0000b\u0000w\u0000i\u0000n\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000u\u0000b\u0000-\u0000w\u0000i\u0000n\u0000d\u0000o\u0000w\u0000 \u0000i\u0000n\u0000d\u0000e\u0000x\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00001\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00001\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000s\u0000u\u0000p\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000e\u0000s\u0000q\u0000u\u0000e\u0000r\u0000d\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000x\u00002\u0000,\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000x\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000o\u0000n\u0000s\u0000t\u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000 \u0000y\u00002\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000y\u00002\u0000 \u0000c\u0000o\u0000o\u0000r\u0000d\u0000i\u0000n\u0000a\u0000t\u0000e\u0000 \u0000(\u0000c\u0000a\u0000n\u0000t\u0000o\u0000 \u0000i\u0000n\u0000f\u0000e\u0000r\u0000i\u0000o\u0000r\u0000 \u0000d\u0000i\u0000r\u0000e\u0000i\u0000t\u0000o\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000)\u0000*\u0000/\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000A\u0000 \u0000f\u0000u\u0000n\u0000\u0000\u0000o\u0000 \u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000 \u0000\u0000 \u0000d\u0000a\u0000d\u0000a\u0000 \u0000a\u0000c\u0000i\u0000m\u0000a\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000r\u0000e\u0000a\u0000t\u0000e\u0000(\u00000\u0000,\u0000\"\u0000G\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000\"\u0000,\u00000\u0000,\u00003\u00000\u0000,\u00003\u00000\u0000,\u00009\u00005\u00000\u0000,\u00005\u00005\u00000\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000d\u0000i\u0000c\u0000i\u0000o\u0000n\u0000a\u0000 \u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000 \u0000n\u0000a\u0000 \u0000c\u0000u\u0000r\u0000v\u0000a\u0000.\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000Y\u0000_\u0000t\u0000r\u0000u\u0000e\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000O\u0000s\u0000 \u0000t\u0000r\u0000e\u0000c\u0000h\u0000o\u0000s\u0000 \u0000\"\u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00001\u0000 \u0000=\u0000 \u0000\"\u0000 \u0000n\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000C\u0000C\u0000u\u0000r\u0000v\u0000e\u0000 \u0000*\u0000C\u0000u\u0000r\u0000v\u0000e\u00002\u0000 \u0000=\u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000A\u0000d\u0000d\u0000(\u0000x\u0000,\u0000Y\u0000_\u0000p\u0000r\u0000e\u0000d\u0000,\u0000C\u0000U\u0000R\u0000V\u0000E\u0000_\u0000L\u0000I\u0000N\u0000E\u0000S\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000s\u0000\u0000o\u0000 \u0000n\u0000e\u0000c\u0000e\u0000s\u0000s\u0000\u0000r\u0000i\u0000o\u0000s\u0000.\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000u\u0000d\u0000a\u0000 \u0000o\u0000s\u0000 \u0000n\u0000o\u0000m\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000g\u0000r\u0000\u0000f\u0000i\u0000c\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000X\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000m\u0000 \u0000o\u0000 \u0000t\u0000a\u0000m\u0000a\u0000n\u0000h\u0000o\u0000 \u0000d\u0000a\u0000 \u0000f\u0000o\u0000n\u0000t\u0000e\u0000,\u0000 \u0000n\u0000\u0000o\u0000 \u0000f\u0000u\u0000n\u0000c\u0000i\u0000o\u0000n\u0000a\u0000.\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000X\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000(\u0000\"\u0000Y\u0000 \u0000-\u0000 \u0000a\u0000x\u0000i\u0000s\u0000\"\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000Y\u0000A\u0000x\u0000i\u0000s\u0000(\u0000)\u0000.\u0000N\u0000a\u0000m\u0000e\u0000S\u0000i\u0000z\u0000e\u0000(\u00001\u00002\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000C\u0000u\u0000r\u0000v\u0000e\u0000P\u0000l\u0000o\u0000t\u0000A\u0000l\u0000l\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000g\u0000r\u0000a\u0000p\u0000h\u0000i\u0000c\u0000.\u0000U\u0000p\u0000d\u0000a\u0000t\u0000e\u0000(\u0000)\u0000;\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000N\u0000o\u0000r\u0000m\u0000a\u0000l\u0000i\u0000z\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000X\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000X\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000a\u0000n\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000s\u0000t\u0000d\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000i\u0000n\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000e\u0000a\u0000n\u0000 \u0000=\u0000 \u0000M\u0000e\u0000a\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000_\u0000f\u0000i\u0000l\u0000t\u0000e\u0000r\u0000 \u0000=\u00003\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000a\u0000 \u0000m\u0000\u0000d\u0000i\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000-\u0000 \u0000m\u0000e\u0000a\u0000n\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000o\u0000s\u0000 \u0000O\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000l\u0000=\u00000\u0000;\u0000l\u0000<\u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000_\u0000f\u0000i\u0000l\u0000t\u0000e\u0000r\u0000;\u0000l\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000T\u0000i\u0000r\u0000a\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000c\u0000a\u0000m\u0000a\u0000d\u0000a\u0000 \u0000d\u0000e\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000M\u0000a\u0000t\u0000h\u0000A\u0000b\u0000s\u0000(\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000>\u0000 \u00003\u0000*\u0000s\u0000t\u0000d\u0000)\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u00000\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000I\u0000n\u0000t\u0000e\u0000r\u0000p\u0000o\u0000l\u0000a\u0000 \u0000o\u0000s\u0000 \u0000v\u0000a\u0000l\u0000o\u0000r\u0000e\u0000s\u0000 \u0000d\u0000o\u0000s\u0000 \u0000o\u0000u\u0000t\u0000l\u0000i\u0000e\u0000r\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000=\u0000 \u00000\u0000)\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000(\u0000X\u0000[\u0000i\u0000-\u00001\u0000]\u0000[\u0000j\u0000]\u0000 \u0000+\u0000 \u0000X\u0000[\u0000i\u0000+\u00001\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000/\u0000 \u00002\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000R\u0000e\u0000c\u0000a\u0000l\u0000c\u0000u\u0000l\u0000a\u0000 \u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000D\u0000i\u0000v\u0000i\u0000d\u0000e\u0000 \u0000p\u0000e\u0000l\u0000o\u0000 \u0000d\u0000e\u0000s\u0000v\u0000i\u0000o\u0000 \u0000p\u0000a\u0000d\u0000r\u0000\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000/\u0000s\u0000t\u0000d\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u0000M\u0000a\u0000x\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u0000M\u0000i\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000(\u00001\u0000.\u00005\u0000 \u0000*\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000/\u0000(\u0000m\u0000a\u0000x\u0000 \u0000-\u0000 \u0000m\u0000i\u0000n\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000e\u0000a\u0000n\u0000 \u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000M\u0000 \u0000=\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000m\u0000e\u0000 \u0000=\u0000 \u0000m\u0000e\u0000 \u0000+\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u0000m\u0000e\u0000 \u0000/\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000S\u0000t\u0000d\u0000D\u0000e\u0000v\u0000i\u0000a\u0000t\u0000i\u0000o\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000M\u0000 \u0000=\u0000 \u0000X\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000s\u0000t\u0000d\u0000;\u0000\n\u0000\n\u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000e\u0000,\u0000s\u0000u\u0000m\u0000;\u0000\n\u0000\n\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000e\u0000a\u0000n\u0000(\u0000X\u0000,\u0000j\u0000)\u0000;\u0000\n\u0000\n\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000-\u00001\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u0000s\u0000u\u0000m\u0000 \u0000+\u0000 \u0000M\u0000a\u0000t\u0000h\u0000P\u0000o\u0000w\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000-\u0000m\u0000e\u0000,\u00002\u0000)\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000\n\u0000\n\u0000s\u0000u\u0000m\u0000 \u0000=\u0000 \u0000s\u0000u\u0000m\u0000 \u0000/\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000s\u0000t\u0000d\u0000 \u0000=\u0000 \u0000M\u0000a\u0000t\u0000h\u0000S\u0000q\u0000r\u0000t\u0000(\u0000s\u0000u\u0000m\u0000)\u0000;\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000s\u0000t\u0000d\u0000;\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000i\u0000n\u0000;\u0000 \u0000\n\u0000\n\u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000<\u0000 \u0000m\u0000i\u0000n\u0000)\u0000 \u0000m\u0000i\u0000n\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000i\u0000n\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000M\u0000a\u0000x\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000X\u0000,\u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000j\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u00000\u0000;\u0000 \u0000\n\u0000\n\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000X\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000>\u0000 \u0000m\u0000a\u0000x\u0000)\u0000 \u0000m\u0000a\u0000x\u0000 \u0000=\u0000 \u0000X\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000m\u0000a\u0000x\u0000;\u0000 \u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000R\u0000e\u0000a\u0000d\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u0000e\u0000 \u0000a\u0000p\u0000e\u0000n\u0000a\u0000s\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000a\u0000b\u0000e\u0000r\u0000 \u0000o\u0000 \u0000n\u0000\u0000m\u0000e\u0000r\u0000o\u0000 \u0000d\u0000e\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000L\u00001\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u00001\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000R\u0000E\u0000A\u0000D\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000T\u0000X\u0000T\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\u0000o\u0000 \u0000\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\u0000 \u0000i\u0000n\u0000v\u0000\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u00001\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000L\u00001\u0000 \u0000=\u0000 \u0000F\u0000i\u0000l\u0000e\u0000R\u0000e\u0000a\u0000d\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000h\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u00001\u0000 \u0000p\u0000o\u0000s\u0000s\u0000u\u0000i\u0000 \u0000a\u0000g\u0000o\u0000r\u0000a\u0000 \u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000 \u0000d\u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000z\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000L\u0000\u0000 \u0000q\u0000u\u0000a\u0000n\u0000t\u0000a\u0000s\u0000 \u0000c\u0000o\u0000l\u0000u\u0000n\u0000a\u0000s\u0000 \u0000s\u0000\u0000o\u0000 \u0000p\u0000e\u0000l\u0000o\u0000 \u0000n\u0000\u0000m\u0000e\u0000r\u0000o\u0000 \u0000d\u0000e\u0000 \u0000v\u0000\u0000r\u0000g\u0000u\u0000l\u0000a\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000 \u0000=\u0000 \u00001\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000L\u00001\u0000.\u0000L\u0000e\u0000n\u0000g\u0000t\u0000h\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000L\u00001\u0000.\u0000S\u0000u\u0000b\u0000s\u0000t\u0000r\u0000(\u0000i\u0000,\u00001\u0000)\u0000 \u0000=\u0000=\u0000 \u0000\"\u0000,\u0000\"\u0000)\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000+\u0000+\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000R\u0000E\u0000A\u0000D\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000C\u0000S\u0000V\u0000,\u0000\"\u0000,\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\u0000o\u0000 \u0000\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\u0000 \u0000i\u0000n\u0000v\u0000\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000m\u0000[\u0000]\u0000;\u0000 \u0000/\u0000/\u0000V\u0000e\u0000t\u0000o\u0000r\u0000 \u0000q\u0000u\u0000e\u0000 \u0000r\u0000e\u0000c\u0000e\u0000b\u0000e\u0000r\u0000\u0000 \u0000o\u0000s\u0000 \u0000d\u0000a\u0000d\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000 \u0000 \u0000 \u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000A\u0000;\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000M\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000q\u0000u\u0000e\u0000 \u0000r\u0000e\u0000t\u0000o\u0000r\u0000n\u0000a\u0000r\u0000\u0000 \u0000c\u0000o\u0000m\u0000 \u0000o\u0000s\u0000 \u0000d\u0000a\u0000d\u0000o\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000A\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000=\u0000 \u00000\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000C\u0000o\u0000m\u0000e\u0000\u0000a\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000 \u0000l\u0000e\u0000i\u0000t\u0000u\u0000r\u0000a\u0000 \u0000d\u0000a\u0000 \u0000p\u0000r\u0000i\u0000m\u0000e\u0000i\u0000r\u0000a\u0000 \u0000l\u0000i\u0000n\u0000h\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000w\u0000h\u0000i\u0000l\u0000e\u0000(\u0000!\u0000F\u0000i\u0000l\u0000e\u0000I\u0000s\u0000E\u0000n\u0000d\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000m\u0000,\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000+\u00001\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000 \u0000=\u0000 \u0000F\u0000i\u0000l\u0000e\u0000R\u0000e\u0000a\u0000d\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000;\u0000 \u0000 \u0000 \u0000/\u0000/\u0000 \u0000L\u0000\u0000 \u0000o\u0000 \u0000c\u0000o\u0000n\u0000t\u0000e\u0000u\u0000d\u0000o\u0000 \u0000a\u0000t\u0000\u0000 \u0000a\u0000 \u0000v\u0000i\u0000r\u0000g\u0000u\u0000l\u0000a\u0000 \u0000\u0000 \u0000p\u0000a\u0000s\u0000s\u0000a\u0000 \u0000p\u0000r\u0000a\u0000 \u0000p\u0000r\u0000\u0000x\u0000i\u0000m\u0000a\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000m\u0000[\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000]\u0000 \u0000=\u0000 \u0000r\u0000e\u0000a\u0000d\u0000_\u0000x\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000!\u0000F\u0000i\u0000l\u0000e\u0000I\u0000s\u0000E\u0000n\u0000d\u0000i\u0000n\u0000g\u0000(\u0000h\u0000)\u0000)\u0000 \u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000+\u0000+\u0000;\u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000 \u0000=\u0000 \u0000(\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000+\u0000 \u00001\u0000)\u0000/\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000(\u0000(\u0000m\u0000_\u0000s\u0000i\u0000z\u0000e\u0000 \u0000+\u00001\u0000)\u0000%\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000)\u0000 \u0000!\u0000=\u0000 \u00000\u0000 \u0000)\u0000 \u0000 \u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000t\u0000h\u0000e\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000d\u0000a\u0000t\u0000a\u0000 \u0000i\u0000s\u0000 \u0000i\u0000n\u0000c\u0000o\u0000m\u0000p\u0000l\u0000e\u0000t\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000e\u0000l\u0000s\u0000e\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000r\u0000e\u0000p\u0000a\u0000r\u0000a\u0000r\u0000 \u0000a\u0000 \u0000M\u0000a\u0000t\u0000r\u0000i\u0000z\u0000 \u0000A\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000A\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000,\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000n\u0000u\u0000m\u0000_\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000A\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000T\u0000o\u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000(\u0000m\u0000[\u0000i\u0000 \u0000*\u0000 \u0000n\u0000u\u0000m\u0000_\u0000c\u0000o\u0000l\u0000u\u0000m\u0000n\u0000s\u0000 \u0000+\u0000 \u0000j\u0000]\u0000)\u0000;\u0000}\u0000}\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000=\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000A\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000v\u0000o\u0000i\u0000d\u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000W\u0000r\u0000i\u0000t\u0000e\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000M\u0000,\u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000t\u0000r\u0000a\u0000n\u0000s\u0000f\u0000o\u0000r\u0000m\u0000a\u0000 \u0000a\u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000 \u0000n\u0000u\u0000m\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000d\u0000e\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000S\u0000r\u0000o\u0000w\u0000s\u0000 \u0000,\u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000S\u0000r\u0000o\u0000w\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000 \u0000=\u0000 \u0000M\u0000_\u0000n\u0000a\u0000m\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000 \u0000V\u0000[\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000A\u0000r\u0000r\u0000a\u0000y\u0000R\u0000e\u0000s\u0000i\u0000z\u0000e\u0000(\u0000V\u0000,\u0000S\u0000r\u0000o\u0000w\u0000s\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000Z\u0000e\u0000r\u0000a\u0000 \u0000o\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000d\u0000e\u0000 \u0000s\u0000t\u0000r\u0000i\u0000n\u0000g\u0000s\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000A\u0000r\u0000r\u0000a\u0000y\u0000S\u0000i\u0000z\u0000e\u0000(\u0000V\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000N\u0000U\u0000L\u0000L\u0000;\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000P\u0000r\u0000e\u0000p\u0000a\u0000r\u0000a\u0000 \u0000o\u0000 \u0000v\u0000e\u0000t\u0000o\u0000r\u0000 \u0000c\u0000o\u0000m\u0000 \u0000a\u0000s\u0000 \u0000c\u0000l\u0000a\u0000s\u0000s\u0000e\u0000s\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000S\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000S\u0000C\u0000o\u0000l\u0000s\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000j\u0000 \u0000=\u0000=\u0000 \u0000S\u0000C\u0000o\u0000l\u0000s\u0000-\u00001\u0000)\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000+\u0000 \u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000T\u0000o\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000e\u0000l\u0000s\u0000e\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000=\u0000 \u0000V\u0000[\u0000i\u0000]\u0000 \u0000+\u0000 \u0000D\u0000o\u0000u\u0000b\u0000l\u0000e\u0000T\u0000o\u0000S\u0000t\u0000r\u0000i\u0000n\u0000g\u0000(\u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000)\u0000 \u0000+\u0000 \u0000\"\u0000,\u0000\"\u0000;\u0000}\u0000}\u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000A\u0000b\u0000r\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000p\u0000a\u0000r\u0000a\u0000 \u0000s\u0000e\u0000r\u0000 \u0000e\u0000s\u0000c\u0000r\u0000i\u0000t\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000n\u0000t\u0000 \u0000h\u0000=\u0000F\u0000i\u0000l\u0000e\u0000O\u0000p\u0000e\u0000n\u0000(\u0000c\u0000s\u0000v\u0000_\u0000n\u0000a\u0000m\u0000e\u0000,\u0000F\u0000I\u0000L\u0000E\u0000_\u0000W\u0000R\u0000I\u0000T\u0000E\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000A\u0000N\u0000S\u0000I\u0000|\u0000F\u0000I\u0000L\u0000E\u0000_\u0000C\u0000S\u0000V\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000S\u0000e\u0000 \u0000o\u0000 \u0000a\u0000r\u0000q\u0000u\u0000i\u0000v\u0000o\u0000 \u0000n\u0000\u0000o\u0000 \u0000\u0000 \u0000a\u0000b\u0000e\u0000r\u0000t\u0000o\u0000 \u0000d\u0000e\u0000v\u0000i\u0000d\u0000a\u0000m\u0000e\u0000n\u0000t\u0000e\u0000 \u0000o\u0000 \u0000h\u0000a\u0000n\u0000d\u0000l\u0000e\u0000 \u0000\u0000 \u0000i\u0000n\u0000v\u0000\u0000l\u0000i\u0000d\u0000o\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000h\u0000=\u0000=\u0000I\u0000N\u0000V\u0000A\u0000L\u0000I\u0000D\u0000_\u0000H\u0000A\u0000N\u0000D\u0000L\u0000E\u0000)\u0000 \u0000A\u0000l\u0000e\u0000r\u0000t\u0000(\u0000\"\u0000E\u0000r\u0000r\u0000o\u0000r\u0000 \u0000o\u0000p\u0000e\u0000n\u0000i\u0000n\u0000g\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\"\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000S\u0000r\u0000o\u0000w\u0000s\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000W\u0000r\u0000i\u0000t\u0000e\u0000(\u0000h\u0000,\u0000V\u0000[\u0000i\u0000]\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000F\u0000i\u0000l\u0000e\u0000C\u0000l\u0000o\u0000s\u0000e\u0000(\u0000h\u0000)\u0000;\u0000\n\u0000\n\u0000}\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000e\u0000s\u0000t\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000 \u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000*\u0000(\u00001\u0000-\u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000,\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000/\u0000/\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000-\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000/\u0000/\u0000i\u0000f\u0000(\u0000i\u0000 \u0000<\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000i\u0000f\u0000(\u0000i\u0000 \u0000>\u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000}\u0000 \u0000\n\u0000\n\u0000\n\u0000\n\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000 \u0000T\u0000i\u0000m\u0000e\u0000S\u0000e\u0000r\u0000i\u0000e\u0000s\u0000:\u0000:\u0000D\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000T\u0000r\u0000a\u0000i\u0000n\u0000(\u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000&\u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000,\u0000 \u0000d\u0000o\u0000u\u0000b\u0000l\u0000e\u0000 \u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000)\u0000\n\u0000\n\u0000{\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000 \u0000=\u0000 \u0000d\u0000a\u0000t\u0000a\u0000s\u0000e\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000;\u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000=\u0000 \u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000u\u0000l\u0000o\u0000n\u0000g\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000 \u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000*\u0000p\u0000e\u0000r\u0000c\u0000e\u0000n\u0000t\u0000a\u0000g\u0000e\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000m\u0000a\u0000t\u0000r\u0000i\u0000x\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000,\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000/\u0000/\u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000.\u0000I\u0000n\u0000i\u0000t\u0000(\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000 \u0000-\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000,\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000)\u0000;\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000i\u0000=\u00000\u0000;\u0000i\u0000<\u0000M\u0000.\u0000R\u0000o\u0000w\u0000s\u0000(\u0000)\u0000;\u0000i\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000f\u0000o\u0000r\u0000(\u0000i\u0000n\u0000t\u0000 \u0000j\u0000=\u00000\u0000;\u0000j\u0000<\u0000M\u0000.\u0000C\u0000o\u0000l\u0000s\u0000(\u0000)\u0000;\u0000j\u0000+\u0000+\u0000)\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000{\u0000i\u0000f\u0000(\u0000i\u0000 \u0000<\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000 \u0000/\u0000/\u0000i\u0000f\u0000(\u0000i\u0000 \u0000>\u0000=\u0000 \u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000)\u0000 \u0000M\u0000_\u0000t\u0000e\u0000s\u0000t\u0000[\u0000i\u0000-\u0000N\u0000_\u0000s\u0000a\u0000m\u0000p\u0000l\u0000e\u0000s\u0000_\u0000t\u0000r\u0000]\u0000[\u0000j\u0000]\u0000 \u0000=\u0000 \u0000M\u0000[\u0000i\u0000]\u0000[\u0000j\u0000]\u0000;\u0000}\u0000}\u0000\n\u0000\n\u0000r\u0000e\u0000t\u0000u\u0000r\u0000n\u0000 \u0000M\u0000_\u0000t\u0000r\u0000a\u0000i\u0000n\u0000;\u0000\n\u0000\n\u0000}\u0000"}, {"filename": "Example.mq5", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Example.mq5", "content": "#include <TimeSeriesData.mqh>\nTimeSeries time_series;\n#include <DeepLearning.mqh>\nDeepLearning *Layer[];\n\n//Number of layers of our neural net\n//The first thing to do is set the number of layers \n//the network will have \nint   N_layers = 5;\n\n//Loss object\nLoss loss;\n//Metrics object\nMetrics metrics;\n\n//=============================================================\n//In this Example we are trying to predict de Weather in Delhi\n//This dataset was chosen because it is a time series and \n//therefore its similarity with financial time series\n//=============================================================\n\n\nvoid OnInit()\n  {\n//+------------------------------------------------------------------+\n//| Hiper Parameters                                                 |\n//+------------------------------------------------------------------+\n   //Load Dataset\n   matrix M;\n   M = time_series.ReadDataset(\"Delhi.csv\");\n   \n   //----------------------------------------------------------------+\n   //After we have the number of layers setted, it's time to load\n   //the dataset and set other parameters of the dataset\n\n   //AI Name\n   string IAname;\n   IAname = \"DelhiIA\";\n   //number of epochs\n   ulong epoch = 1000;\n   //Learning rate\n   double N = 0.001;\n   //Optimization Method\n   Optim OP = ADAM;\n   //number of samples\n   ulong N_samples = M.Rows();\n   //Dropout rate\n   double drp = 0.9;\n   //Percentage of samples for training\n   double train_ratio = 0.8;\n   //Stride of Max Pooling layers\n   int stride = 2;\n   \n   //Number of inputs\n   int N_entries = M.Cols();\n   //Number of time steps \n   int N_steps = 60;\n   //Column to be predicted\n   int feature = 0;\n \n   \n   //ADAM parameters\n   double Beta1 = 0.8;\n   double Beta2 = 0.999;\n   double Alpha = N; \n        \n   //+------------------------------------------------------------------+\n   //|    Neural Network creation                                     |\n   //+------------------------------------------------------------------+\n   \n   ArrayResize(Layer,N_layers);\n   \n   //Architecture creation\n   biLSTMLayer            *biLSTM1 = new biLSTMLayer();\n   ActivationLayer      *ACT2  = new ActivationLayer();\n   FlattenLayer         *FLAT3 = new FlattenLayer();\n   DenseLayer           *ANN4  = new DenseLayer();\n   ActivationLayer      *ACT5  = new ActivationLayer();\n   \n   //The InitLayer method is used to initialize the weights of each layer\n   //The layer's parameters used in initialization are explained \n   //in the in its respective libraries in Layers directory\n\n\n   //Layers Initialization\n   biLSTM1.InitLayer(N_steps,N_entries,4,1,N,OP);\n   ACT2.InitLayer(TANH);  \n   ANN4.InitLayer(N_steps*1,1,N,OP);\n   ACT5.InitLayer(TANH);\n   \n   \n   //Neural Network \n   Layer[0] = biLSTM1;\n   Layer[1] = ACT2;\n   Layer[2] = FLAT3;\n   Layer[3] = ANN4;\n   Layer[4] = ACT5;\n   \n   //+------------------------------------------------------------------+\n   //|  Otimizers parameters                                 |\n   //+------------------------------------------------------------------+\n   \n   //ADAM\n   Adam(Beta1,Beta2,Alpha); \n\n   \n   //+------------------------------------------------------------------+\n   //|    Dataset pre-processing                                        |\n   //+------------------------------------------------------------------+\n   \n   //The pre-process methods are explained in TimeSeriesData.mqh library\n\n   //Shuffle  Dataset\n   //M = dataset.Shuffle(M);\n   \n   //Normalize dataset\n   M = time_series.NormalizeDataset(M);\n   \n   //training Dataset \n   matrix M_train;\n   M_train = time_series.DatasetTrain(M,train_ratio);\n   \n   // testing Dataset \n   matrix M_test;\n   M_test = time_series.DatasetTest(M,1-train_ratio);\n   \n   //+------------------------------------------------------------------+\n   //|    Weights                                                        |\n   //+------------------------------------------------------------------+\n   \n   //Load Neural Network weights\n   //Load(IAname);\n   \n   // Training:\n   Train(epoch,feature,N_steps,N,M_train);\n     \n   //Save the weigths\n   Save(IAname);\n    \n    \n   //+------------------------------------------------------------------+\n   //|   Evaluation                                                     |\n   //+------------------------------------------------------------------+\n   \n   \n   //Output\n   matrix Out;\n   Out = Test(M_test, N_steps);\n\n \n   //Compare\n   matrix Y_true = time_series.OutputTest(feature,N_steps,M_test);\n   \n   //Plotar outputs\n   time_series.PlotTest(Y_true,Out); \n   //time_series.PlotDataset(M,0);\n   \n   \n   //Accuracy\n   double mape;\n   mape = metrics.MAPE(Y_true,Out);\n   //int percent_accuracy;\n   //accuracy = metrics.Accuracy(R,Out);\n   //percent_accuracy = 100*accuracy;\n   \n   Print(\"The Mean Absolute Percentage Error of the model is \",mape);\n   \n   \n  }\n//+------------------------------------------------------------------+\n//|   Functions and methods                                             |\n//+------------------------------------------------------------------+\n\nvoid Train(ulong epoch,int feature, ulong N_steps,double N,matrix &M)\n{\n   ulong N_samples;\n   N_samples = M.Rows();\n   \n   //estimate time\n   datetime date1, date2; \n   int interval, min, sec; \n   \n   //Estimate training progress\n   double count1,count2;\n   int count;\n   \n   double Error; \n   //Start of training\n   for(int e=0;e<epoch;e++)\n     {\n      Error = 0;\n      for(int s=0;s<N_samples-N_steps;s++)\n        {\n         \n         //Input and output preparation\n         matrix Y_pred;\n         matrix Grad;\n         matrix Y_true;\n         \n         Y_true = time_series.RealOutput(s,feature,N_steps,M);\n         Y_pred = time_series.Features(s,N_steps,M);\n         \n         //Forward Propagation\n         for(int i=0;i<ArraySize(Layer);i++)\n           { Y_pred = Layer[i].Output(Y_pred); }\n           \n         //Error\n         Error += loss.MeanSquaredError(Y_true,Y_pred);\n         Grad = loss.Grad_MSE(Y_true,Y_pred);\n         \n         //Backpropagation\n         for(int i=ArraySize(Layer)-1;i>-1;i--)\n           { Grad = Layer[i].GradDescent(Grad); }\n           \n         //Update Weights\n         for(int i=0;i<ArraySize(Layer);i++)\n           {Layer[i].Update();}  \n         }\n    \n     //Progress bar\n     count = epoch*0.01;\n     if((e % (count)) == 0)\n       {\n         count1 = epoch;\n         count2 = e;\n         count2 = count2/count1;\n         count = 100*count2;\n         Print(\"training progress in \",count,\"%\");\n         Print(\"Current Error = \",Error);\n         date1 = TimeLocal(); \n         if(count > 0)\n           {\n            //Calculate time passed \n            //entre x% e x+1%\n            interval = date1 - date2;\n            //Estimate seconds left\n            interval = interval *(100 - count);\n            //Calculate minutes\n            min = interval / 60;\n            //Calculate seconds\n            sec = interval % 60;\n            Print(\"Remaining Time: \",min,\"min \",sec,\"sec\");\n            \n           }\n         date2 = TimeLocal();\n       }\n//+++++++++++++\n     }\n}\n\nmatrix Test(matrix &M_test,int N_steps)\n{\n   ulong N_samples;\n   N_samples = M_test.Rows();\n   \n   matrix Y_pred;\n   \n   matrix Out;\n   Out.Init(N_samples-N_steps,1);\n   \n   for(int s=0;s<N_samples-N_steps;s++)\n     {   \n         \n         Y_pred = time_series.Features(s,N_steps,M_test);\n         for(int i=0;i<ArraySize(Layer);i++)\n           {//Linha respons\u00e1vel por anular o dropset\n            Layer[i].SetDrop(1.0);\n            //Sa\u00edda efetivamente\n            Y_pred = Layer[i].Output(Y_pred); }\n         \n         Out[s][0] = Y_pred[0][0];\n         //   \n      }\nreturn Out;\n}\n\nvoid Load(string IA_name)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].LoadWeights(i,IA_name);}\n}\nvoid Save(string IA_name)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].SaveWeights(i,IA_name);}\n}\n\nvoid Adam(double beta1, double beta2, double alpha)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].SetAdam(beta1,beta2,alpha);}\n}", "search_content": "#include <TimeSeriesData.mqh>\nTimeSeries time_series;\n#include <DeepLearning.mqh>\nDeepLearning *Layer[];\n\n//Number of layers of our neural net\n//The first thing to do is set the number of layers \n//the network will have \nint   N_layers = 5;\n\n//Loss object\nLoss loss;\n//Metrics object\nMetrics metrics;\n\n//=============================================================\n//In this Example we are trying to predict de Weather in Delhi\n//This dataset was chosen because it is a time series and \n//therefore its similarity with financial time series\n//=============================================================\n\n\nvoid OnInit()\n  {\n//+------------------------------------------------------------------+\n//| Hiper Parameters                                                 |\n//+------------------------------------------------------------------+\n   //Load Dataset\n   matrix M;\n   M = time_series.ReadDataset(\"Delhi.csv\");\n   \n   //----------------------------------------------------------------+\n   //After we have the number of layers setted, it's time to load\n   //the dataset and set other parameters of the dataset\n\n   //AI Name\n   string IAname;\n   IAname = \"DelhiIA\";\n   //number of epochs\n   ulong epoch = 1000;\n   //Learning rate\n   double N = 0.001;\n   //Optimization Method\n   Optim OP = ADAM;\n   //number of samples\n   ulong N_samples = M.Rows();\n   //Dropout rate\n   double drp = 0.9;\n   //Percentage of samples for training\n   double train_ratio = 0.8;\n   //Stride of Max Pooling layers\n   int stride = 2;\n   \n   //Number of inputs\n   int N_entries = M.Cols();\n   //Number of time steps \n   int N_steps = 60;\n   //Column to be predicted\n   int feature = 0;\n \n   \n   //ADAM parameters\n   double Beta1 = 0.8;\n   double Beta2 = 0.999;\n   double Alpha = N; \n        \n   //+------------------------------------------------------------------+\n   //|    Neural Network creation                                     |\n   //+------------------------------------------------------------------+\n   \n   ArrayResize(Layer,N_layers);\n   \n   //Architecture creation\n   biLSTMLayer            *biLSTM1 = new biLSTMLayer();\n   ActivationLayer      *ACT2  = new ActivationLayer();\n   FlattenLayer         *FLAT3 = new FlattenLayer();\n   DenseLayer           *ANN4  = new DenseLayer();\n   ActivationLayer      *ACT5  = new ActivationLayer();\n   \n   //The InitLayer method is used to initialize the weights of each layer\n   //The layer's parameters used in initialization are explained \n   //in the in its respective libraries in Layers directory\n\n\n   //Layers Initialization\n   biLSTM1.InitLayer(N_steps,N_entries,4,1,N,OP);\n   ACT2.InitLayer(TANH);  \n   ANN4.InitLayer(N_steps*1,1,N,OP);\n   ACT5.InitLayer(TANH);\n   \n   \n   //Neural Network \n   Layer[0] = biLSTM1;\n   Layer[1] = ACT2;\n   Layer[2] = FLAT3;\n   Layer[3] = ANN4;\n   Layer[4] = ACT5;\n   \n   //+------------------------------------------------------------------+\n   //|  Otimizers parameters                                 |\n   //+------------------------------------------------------------------+\n   \n   //ADAM\n   Adam(Beta1,Beta2,Alpha); \n\n   \n   //+------------------------------------------------------------------+\n   //|    Dataset pre-processing                                        |\n   //+------------------------------------------------------------------+\n   \n   //The pre-process methods are explained in TimeSeriesData.mqh library\n\n   //Shuffle  Dataset\n   //M = dataset.Shuffle(M);\n   \n   //Normalize dataset\n   M = time_series.NormalizeDataset(M);\n   \n   //training Dataset \n   matrix M_train;\n   M_train = time_series.DatasetTrain(M,train_ratio);\n   \n   // testing Dataset \n   matrix M_test;\n   M_test = time_series.DatasetTest(M,1-train_ratio);\n   \n   //+------------------------------------------------------------------+\n   //|    Weights                                                        |\n   //+------------------------------------------------------------------+\n   \n   //Load Neural Network weights\n   //Load(IAname);\n   \n   // Training:\n   Train(epoch,feature,N_steps,N,M_train);\n     \n   //Save the weigths\n   Save(IAname);\n    \n    \n   //+------------------------------------------------------------------+\n   //|   Evaluation                                                     |\n   //+------------------------------------------------------------------+\n   \n   \n   //Output\n   matrix Out;\n   Out = Test(M_test, N_steps);\n\n \n   //Compare\n   matrix Y_true = time_series.OutputTest(feature,N_steps,M_test);\n   \n   //Plotar outputs\n   time_series.PlotTest(Y_true,Out); \n   //time_series.PlotDataset(M,0);\n   \n   \n   //Accuracy\n   double mape;\n   mape = metrics.MAPE(Y_true,Out);\n   //int percent_accuracy;\n   //accuracy = metrics.Accuracy(R,Out);\n   //percent_accuracy = 100*accuracy;\n   \n   Print(\"The Mean Absolute Percentage Error of the model is \",mape);\n   \n   \n  }\n//+------------------------------------------------------------------+\n//|   Functions and methods                                             |\n//+------------------------------------------------------------------+\n\nvoid Train(ulong epoch,int feature, ulong N_steps,double N,matrix &M)\n{\n   ulong N_samples;\n   N_samples = M.Rows();\n   \n   //estimate time\n   datetime date1, date2; \n   int interval, min, sec; \n   \n   //Estimate training progress\n   double count1,count2;\n   int count;\n   \n   double Error; \n   //Start of training\n   for(int e=0;e<epoch;e++)\n     {\n      Error = 0;\n      for(int s=0;s<N_samples-N_steps;s++)\n        {\n         \n         //Input and output preparation\n         matrix Y_pred;\n         matrix Grad;\n         matrix Y_true;\n         \n         Y_true = time_series.RealOutput(s,feature,N_steps,M);\n         Y_pred = time_series.Features(s,N_steps,M);\n         \n         //Forward Propagation\n         for(int i=0;i<ArraySize(Layer);i++)\n           { Y_pred = Layer[i].Output(Y_pred); }\n           \n         //Error\n         Error += loss.MeanSquaredError(Y_true,Y_pred);\n         Grad = loss.Grad_MSE(Y_true,Y_pred);\n         \n         //Backpropagation\n         for(int i=ArraySize(Layer)-1;i>-1;i--)\n           { Grad = Layer[i].GradDescent(Grad); }\n           \n         //Update Weights\n         for(int i=0;i<ArraySize(Layer);i++)\n           {Layer[i].Update();}  \n         }\n    \n     //Progress bar\n     count = epoch*0.01;\n     if((e % (count)) == 0)\n       {\n         count1 = epoch;\n         count2 = e;\n         count2 = count2/count1;\n         count = 100*count2;\n         Print(\"training progress in \",count,\"%\");\n         Print(\"Current Error = \",Error);\n         date1 = TimeLocal(); \n         if(count > 0)\n           {\n            //Calculate time passed \n            //entre x% e x+1%\n            interval = date1 - date2;\n            //Estimate seconds left\n            interval = interval *(100 - count);\n            //Calculate minutes\n            min = interval / 60;\n            //Calculate seconds\n            sec = interval % 60;\n            Print(\"Remaining Time: \",min,\"min \",sec,\"sec\");\n            \n           }\n         date2 = TimeLocal();\n       }\n//+++++++++++++\n     }\n}\n\nmatrix Test(matrix &M_test,int N_steps)\n{\n   ulong N_samples;\n   N_samples = M_test.Rows();\n   \n   matrix Y_pred;\n   \n   matrix Out;\n   Out.Init(N_samples-N_steps,1);\n   \n   for(int s=0;s<N_samples-N_steps;s++)\n     {   \n         \n         Y_pred = time_series.Features(s,N_steps,M_test);\n         for(int i=0;i<ArraySize(Layer);i++)\n           {//Linha respons\u00e1vel por anular o dropset\n            Layer[i].SetDrop(1.0);\n            //Sa\u00edda efetivamente\n            Y_pred = Layer[i].Output(Y_pred); }\n         \n         Out[s][0] = Y_pred[0][0];\n         //   \n      }\nreturn Out;\n}\n\nvoid Load(string IA_name)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].LoadWeights(i,IA_name);}\n}\nvoid Save(string IA_name)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].SaveWeights(i,IA_name);}\n}\n\nvoid Adam(double beta1, double beta2, double alpha)\n{\n   for(int i=0;i<N_layers;i++)\n     {Layer[i].SetAdam(beta1,beta2,alpha);}\n}"}, {"filename": "Loss.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/Loss.mqh", "content": " //+------------------------------------------------------------------+\n //|  Loss                                                            |\n //+------------------------------------------------------------------+\n  \nclass Loss : public DeepLearning\n{\npublic: \n   //Defines Cross Entropy for calculating error in classification problems\n   double CrossEntropy(matrix &R, matrix &Y);\n   //Defines the mean squared error for classification problems; \n   double MeanSquaredError(matrix &R, matrix &Y);\n   \n   //Defines the derivative of the cross entropy function. (Works with softmax previous activation layer)\n   matrix Grad_CE(matrix &R, matrix &Y);\n   //Two-class case (Only works with a sigmoid anterior activation layer)\n   matrix Grad_BinaryCE(matrix &R, matrix &Y);\n   //Defines the derivative of the Quadratic error function.\n   matrix Grad_MSE(matrix &R, matrix &Y);\n   \n   //notas: \n   //R is the expected output\n   //Y is the output calculated by the neural network\n};\n\n//+------------------------------------------------------------------+\n//|   Loss                                                           |\n//+------------------------------------------------------------------+\ndouble Loss::CrossEntropy(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\n\nL = R * MathLog(Y);\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}};\nreturn -l;\n}\ndouble Loss::MeanSquaredError(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\ndouble c;\nL = MathPow(R-Y,2);\nc = R.Rows();\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}}\n\nl = l/c;\nreturn l; \n}     \nmatrix Loss::Grad_CE(matrix &R, matrix &Y)\n{\nmatrix a;\na = (-1)*(R/Y);\nreturn a;\n}\nmatrix Loss::Grad_BinaryCE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c;\nc = R.Rows();\na = ((1 - R) / (1 - Y) - R / Y) / c;\nreturn a;\n}\nmatrix Loss::Grad_MSE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c; \nc = R.Rows();\na = 2*(Y - R)/c;\nreturn a;\n}", "search_content": " //+------------------------------------------------------------------+\n //|  Loss                                                            |\n //+------------------------------------------------------------------+\n  \nclass Loss : public DeepLearning\n{\npublic: \n   //Defines Cross Entropy for calculating error in classification problems\n   double CrossEntropy(matrix &R, matrix &Y);\n   //Defines the mean squared error for classification problems; \n   double MeanSquaredError(matrix &R, matrix &Y);\n   \n   //Defines the derivative of the cross entropy function. (Works with softmax previous activation layer)\n   matrix Grad_CE(matrix &R, matrix &Y);\n   //Two-class case (Only works with a sigmoid anterior activation layer)\n   matrix Grad_BinaryCE(matrix &R, matrix &Y);\n   //Defines the derivative of the Quadratic error function.\n   matrix Grad_MSE(matrix &R, matrix &Y);\n   \n   //notas: \n   //R is the expected output\n   //Y is the output calculated by the neural network\n};\n\n//+------------------------------------------------------------------+\n//|   Loss                                                           |\n//+------------------------------------------------------------------+\ndouble Loss::CrossEntropy(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\n\nL = R * MathLog(Y);\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}};\nreturn -l;\n}\ndouble Loss::MeanSquaredError(matrix &R, matrix &Y)\n{\ndouble l; \nmatrix L;\ndouble c;\nL = MathPow(R-Y,2);\nc = R.Rows();\nl = 0;\nfor(int i=0;i<L.Rows();i++)\n  {for(int j=0;j<L.Cols();j++)\n     {   l = l + L[i][j];}}\n\nl = l/c;\nreturn l; \n}     \nmatrix Loss::Grad_CE(matrix &R, matrix &Y)\n{\nmatrix a;\na = (-1)*(R/Y);\nreturn a;\n}\nmatrix Loss::Grad_BinaryCE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c;\nc = R.Rows();\na = ((1 - R) / (1 - Y) - R / Y) / c;\nreturn a;\n}\nmatrix Loss::Grad_MSE(matrix &R,matrix &Y)\n{\nmatrix a;\ndouble c; \nc = R.Rows();\na = 2*(Y - R)/c;\nreturn a;\n}"}, {"filename": "ConvolutionalLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/ConvolutionalLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Convolutional Layer                                                               |\n//+------------------------------------------------------------------+\nclass ConvolutionalLayer : public DeepLearning\n  {\npublic:\n   //Initialize kernels and layer biases\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagate the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load Weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \n   \n   \nprivate:\n   //Kernel layer\n   matrix K;\n   //Kernel Gradient\n   matrix dK;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input layer\n   matrix Xe;\n   //Learning rate\n   double N;\n   //Optimization method\n   Optim OP;\n   //Convolution direction\n   CONV_DIR DIR;\n   \n   \n   //ADAM \n   //===============\n   //iteration counter\n   ulong it; \n   //m\n   matrix mK, mB;\n   //v\n   matrix vK, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Convolutional Layer                                            |\n//+------------------------------------------------------------------+\n\nvoid ConvolutionalLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD)\n{\n   DIR = direction;\n   \n   if(DIR == VERT)\n   { K.Init(N_steps-N_outputs+1,N_entries);\n   B.Init(N_steps-K.Rows()+1,N_entries);}\n   \n   if(DIR == HORZ)\n   { K.Init(N_entries,N_steps-N_outputs + 1);\n   B.Init(N_entries,N_steps - K.Cols() +1);}\n   \n   N = LR;\n   OP = Op;\n\n   K = InitWeights(K);\n   B = InitWeights(B);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mK.Init(K.Rows(),K.Cols());\n      vK.Init(K.Rows(),K.Cols());  \n      mK = ZeroMatrix(mK);\n      vK = ZeroMatrix(vK);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix ConvolutionalLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nif(DIR == VERT)Y = VertConvV(X,K) + B;\nif(DIR == HORZ)Y = HorConvV(X,K) + B;\nreturn Y;\n}\nmatrix ConvolutionalLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex,Ki,Xi;\n   if(DIR == VERT)\n   {\n   Ki = VertInv(K);\n   Ex = VertConvF(Ki,Ey);\n   \n   Xi = VertInv(Xe);\n   dK = VertConvV(Xi,Ey);\n   dB = Ey;}\n   \n   if(DIR == HORZ)\n   {\n   Ki = HorInv(K);\n   Ex = HorConvF(Ki,Ey);\n   \n   Xi = HorInv(Xe);\n   dK = HorConvV(Xi,Ey);\n   dB = Ey;}\n   return Ex;\n}\nvoid ConvolutionalLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      K = K - dK*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mK = AdamM(mK,dK,beta1);\n      vK = AdamV(vK,dK,beta2);\n      K = K - Adam(it,mK,vK,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B - Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid ConvolutionalLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k);\n   SaveMatrix(K,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid ConvolutionalLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname+ \"\\KLayer\" + IntegerToString(k);\n   K = LoadMatrix(csv_name);\n   csv_name = IAname+ \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid ConvolutionalLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}\n", "search_content": "//+------------------------------------------------------------------+\n//|   Convolutional Layer                                                               |\n//+------------------------------------------------------------------+\nclass ConvolutionalLayer : public DeepLearning\n  {\npublic:\n   //Initialize kernels and layer biases\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagate the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load Weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \n   \n   \nprivate:\n   //Kernel layer\n   matrix K;\n   //Kernel Gradient\n   matrix dK;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input layer\n   matrix Xe;\n   //Learning rate\n   double N;\n   //Optimization method\n   Optim OP;\n   //Convolution direction\n   CONV_DIR DIR;\n   \n   \n   //ADAM \n   //===============\n   //iteration counter\n   ulong it; \n   //m\n   matrix mK, mB;\n   //v\n   matrix vK, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Convolutional Layer                                            |\n//+------------------------------------------------------------------+\n\nvoid ConvolutionalLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR, CONV_DIR direction = HORZ, Optim Op = STD)\n{\n   DIR = direction;\n   \n   if(DIR == VERT)\n   { K.Init(N_steps-N_outputs+1,N_entries);\n   B.Init(N_steps-K.Rows()+1,N_entries);}\n   \n   if(DIR == HORZ)\n   { K.Init(N_entries,N_steps-N_outputs + 1);\n   B.Init(N_entries,N_steps - K.Cols() +1);}\n   \n   N = LR;\n   OP = Op;\n\n   K = InitWeights(K);\n   B = InitWeights(B);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mK.Init(K.Rows(),K.Cols());\n      vK.Init(K.Rows(),K.Cols());  \n      mK = ZeroMatrix(mK);\n      vK = ZeroMatrix(vK);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix ConvolutionalLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nif(DIR == VERT)Y = VertConvV(X,K) + B;\nif(DIR == HORZ)Y = HorConvV(X,K) + B;\nreturn Y;\n}\nmatrix ConvolutionalLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex,Ki,Xi;\n   if(DIR == VERT)\n   {\n   Ki = VertInv(K);\n   Ex = VertConvF(Ki,Ey);\n   \n   Xi = VertInv(Xe);\n   dK = VertConvV(Xi,Ey);\n   dB = Ey;}\n   \n   if(DIR == HORZ)\n   {\n   Ki = HorInv(K);\n   Ex = HorConvF(Ki,Ey);\n   \n   Xi = HorInv(Xe);\n   dK = HorConvV(Xi,Ey);\n   dB = Ey;}\n   return Ex;\n}\nvoid ConvolutionalLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      K = K - dK*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mK = AdamM(mK,dK,beta1);\n      vK = AdamV(vK,dK,beta2);\n      K = K - Adam(it,mK,vK,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B - Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid ConvolutionalLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k);\n   SaveMatrix(K,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid ConvolutionalLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname+ \"\\KLayer\" + IntegerToString(k);\n   K = LoadMatrix(csv_name);\n   csv_name = IAname+ \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid ConvolutionalLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}\n"}, {"filename": "MaxPoolingLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/MaxPoolingLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Max Pooling                                                    |\n//+------------------------------------------------------------------+\n\nclass MaxPoolingLayer : public DeepLearning\n  {\npublic:\n   //Initializes parameters\n   void   InitLayer( int stride, CONV_DIR direction);\n   //Calculates the output of the litter from an input\n   //The output dimension is  Ceil(N_entries / stride)\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n\nprivate:\n   //Stride\n   int S;\n   //Direction\n   CONV_DIR DIR; \n   //Matrix with the index of the maximum values\n   matrix Max;\n   //Number of steps \n   int Steps; \n   \n   //\n  };\n\n//+------------------------------------------------------------------+\n//|    Max Pooling                                                              |\n//+------------------------------------------------------------------+\nvoid   MaxPoolingLayer::InitLayer( int stride, CONV_DIR direction)\n{\nS = stride;\nDIR = direction;\n\n}\nmatrix MaxPoolingLayer::Output(matrix &X)\n{\nmatrix M,MP,Mx;\n\nif(DIR == VERT)\n  {\n   M.Init(S,X.Cols());\n   \n   int N_slides,N_steps,count;\n   Steps = X.Rows();\n   \n   double N_out; \n   N_out = X.Rows();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   MP.Init(N_slides,X.Cols());\n   Mx.Init(N_slides,X.Cols());\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+i < Steps)  M[i][j] = X[k*S+i][j];\n            if(k*S+i >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(0);\n      for(int i=0;i<MP.Cols();i++)\n        {count = v[i];\n         MP[k][i] = M[count][i];\n         Mx[k][i] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nif(DIR == HORZ)\n  {\n   M.Init(X.Rows(),S);\n   \n   int N_slides,N_steps,count;\n   Steps = X.Cols();\n   \n   double N_out; \n   N_out = X.Cols();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   \n   MP.Init(X.Rows(),N_slides);\n   Mx.Init(X.Rows(),N_slides);\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+j < Steps)  M[i][j] = X[i][k*S+j];\n            if(k*S+j >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(1);\n      for(int i=0;i<MP.Rows();i++)\n        {count = v[i];\n         MP[i][k] = M[i][count];\n         Mx[i][k] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nreturn MP;\n}\n\nmatrix MaxPoolingLayer::GradDescent(matrix &Ey)\n{\n\n   matrix Ex;\nif(DIR == VERT)\n{\n   Ex.Init(Steps,Ey.Cols());\n   \n   for(int k=0;k<Steps;k++)\n      {for(int j=0;j<Ey.Cols();j++)\n        {for(int i=0;i<S;i++)\n           {if(k*S+i < Steps)\n              {if(i == Max[k][j])\n              { Ex[k*S+i][j] = Ey[k][j];}\n               if(i != Max[k][j]) \n               {Ex[k*S+i][j] = 0;}\n               \n       }}}}\n}\nif(DIR == HORZ)\n{\n   Ex.Init(Ey.Rows(),Steps);\n   \n   for(int k=0;k<Steps;k++)\n      {for(int i=0;i<Ey.Rows();i++)\n        {for(int j=0;j<S;j++)\n           {if(k*S+j < Steps)\n              {if(j == Max[i][k])\n              { Ex[i][k*S+j] = Ey[i][k];}\n               if(j != Max[i][k]) \n               {Ex[i][k*S+j] = 0;}\n               \n       }}}}\n}        \nreturn Ex;\n}\n", "search_content": "//+------------------------------------------------------------------+\n//|   Max Pooling                                                    |\n//+------------------------------------------------------------------+\n\nclass MaxPoolingLayer : public DeepLearning\n  {\npublic:\n   //Initializes parameters\n   void   InitLayer( int stride, CONV_DIR direction);\n   //Calculates the output of the litter from an input\n   //The output dimension is  Ceil(N_entries / stride)\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n\nprivate:\n   //Stride\n   int S;\n   //Direction\n   CONV_DIR DIR; \n   //Matrix with the index of the maximum values\n   matrix Max;\n   //Number of steps \n   int Steps; \n   \n   //\n  };\n\n//+------------------------------------------------------------------+\n//|    Max Pooling                                                              |\n//+------------------------------------------------------------------+\nvoid   MaxPoolingLayer::InitLayer( int stride, CONV_DIR direction)\n{\nS = stride;\nDIR = direction;\n\n}\nmatrix MaxPoolingLayer::Output(matrix &X)\n{\nmatrix M,MP,Mx;\n\nif(DIR == VERT)\n  {\n   M.Init(S,X.Cols());\n   \n   int N_slides,N_steps,count;\n   Steps = X.Rows();\n   \n   double N_out; \n   N_out = X.Rows();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   MP.Init(N_slides,X.Cols());\n   Mx.Init(N_slides,X.Cols());\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+i < Steps)  M[i][j] = X[k*S+i][j];\n            if(k*S+i >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(0);\n      for(int i=0;i<MP.Cols();i++)\n        {count = v[i];\n         MP[k][i] = M[count][i];\n         Mx[k][i] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nif(DIR == HORZ)\n  {\n   M.Init(X.Rows(),S);\n   \n   int N_slides,N_steps,count;\n   Steps = X.Cols();\n   \n   double N_out; \n   N_out = X.Cols();\n   N_out = N_out/S;\n   N_out = MathCeil(N_out);\n   \n   N_slides = N_out;\n   \n   MP.Init(X.Rows(),N_slides);\n   Mx.Init(X.Rows(),N_slides);\n   \n   //A ideia \u00e9 selecionar a matriz correspondente ao stride\n   //E tomar o elemento m\u00e1ximo de cada coluna dessa matriz\n   vector v; \n   for(int k=0;k<N_slides;k++)\n      {for(int i=0;i<M.Rows();i++)\n        {for(int j=0;j<M.Cols();j++)\n           {if(k*S+j < Steps)  M[i][j] = X[i][k*S+j];\n            if(k*S+j >= Steps) M[i][j] = -1e12;}}\n   \n      v = M.ArgMax(1);\n      for(int i=0;i<MP.Rows();i++)\n        {count = v[i];\n         MP[i][k] = M[i][count];\n         Mx[i][k] = v[i];\n        }\n      }\n         \n   Max = Mx;\n   }\nreturn MP;\n}\n\nmatrix MaxPoolingLayer::GradDescent(matrix &Ey)\n{\n\n   matrix Ex;\nif(DIR == VERT)\n{\n   Ex.Init(Steps,Ey.Cols());\n   \n   for(int k=0;k<Steps;k++)\n      {for(int j=0;j<Ey.Cols();j++)\n        {for(int i=0;i<S;i++)\n           {if(k*S+i < Steps)\n              {if(i == Max[k][j])\n              { Ex[k*S+i][j] = Ey[k][j];}\n               if(i != Max[k][j]) \n               {Ex[k*S+i][j] = 0;}\n               \n       }}}}\n}\nif(DIR == HORZ)\n{\n   Ex.Init(Ey.Rows(),Steps);\n   \n   for(int k=0;k<Steps;k++)\n      {for(int i=0;i<Ey.Rows();i++)\n        {for(int j=0;j<S;j++)\n           {if(k*S+j < Steps)\n              {if(j == Max[i][k])\n              { Ex[i][k*S+j] = Ey[i][k];}\n               if(j != Max[i][k]) \n               {Ex[i][k*S+j] = 0;}\n               \n       }}}}\n}        \nreturn Ex;\n}\n"}, {"filename": "SumConvLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/SumConvLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+\n\nclass SumConvLayer : public DeepLearning\n  {\npublic :\n   //Inicializa os kernels e o bias da camada\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD);\n   //Calcula a sa\u00edda da camada a partir de uma entrada\n   virtual matrix Output(matrix &X);\n   //Propaga o Erro \n   virtual matrix GradDescent(matrix &Ey);\n   //Atualiza os pesos\n   virtual void   Update(void);\n   //Salvar os pesos, k \u00e9 o indice da camada;\n   virtual void   SaveWeights(int k,string IAname);\n   //Carregar os pesos\n   virtual void   LoadWeights(int k,string IAname);\n\nprivate:\n   //Number of convolutions\n   int N_C;\n   //Kernel da Camada\n   matrix K[];\n   //Gradiente do Kernel\n   matrix dK[];\n   //Bias da camada\n   matrix B[];\n   //Gradiente do Bias\n   matrix dB[];\n   //Entrada da Camada de ativa\u00e7\u00e3o\n   matrix Xact[];\n   //Peso auxiliar\n   matrix C[];\n   //gradiente do peso auxiliar \n   matrix dC[];\n   //Entrada da Camada convolucional\n   matrix Xc;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimiza\u00e7\u00e3o\n   Optim OP;\n   //Dire\u00e7\u00e3o da convolu\u00e7\u00e3o\n   CONV_DIR DIR;\n   //Fun\u00e7\u00e3o de Ativa\u00e7\u00e3o\n   ActFunction AF;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mK[], mB[], mC[];\n   //v\n   matrix vK[], vB[], vC[];\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+ \nvoid SumConvLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR,int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD)\n{\n   N_C = N_Conv;\n   AF = af;\n   \n   double factor; \n   factor = N_Conv;\n   factor = 1 / factor; \n   \n   ArrayResize(K,N_C);\n   ArrayResize(dK,N_C);\n   \n   ArrayResize(B,N_C);\n   ArrayResize(dB,N_C);\n   \n   ArrayResize(Xact,N_C);\n   ArrayResize(C,N_C);\n   ArrayResize(dC,N_C);\n   \nfor(int i=0;i<N_C;i++)\n  {\n      if(direction == VERT)\n      {  K[i].Init(N_steps-N_outputs+1,N_entries);\n         B[i].Init(N_steps-K[i].Rows()+1,N_entries);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   \n      if(direction == HORZ)\n      {  K[i].Init(N_entries,N_steps-N_outputs + 1);\n         B[i].Init(N_entries,N_steps - K[i].Rows() +1);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   }\n   N = LR;\n   OP = Op;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      ArrayResize(mK,N_C);\n      ArrayResize(vK,N_C);\n      \n      ArrayResize(mB,N_C);\n      ArrayResize(vB,N_C);\n      \n      ArrayResize(mC,N_C);\n      ArrayResize(vC,N_C);\n      \n      for(int i=0;i<N_C;i++)\n      {\n         mK[i].Init(K[i].Rows(),K[i].Cols());\n         vK[i].Init(K[i].Rows(),K[i].Cols());  \n         mK[i] = ZeroMatrix(mK[i]);\n         vK[i] = ZeroMatrix(vK[i]);\n         \n         mB[i].Init(B[i].Rows(),B[i].Cols());\n         vB[i].Init(B[i].Rows(),B[i].Cols());\n         mB[i] = ZeroMatrix(mB[i]);\n         vB[i] = ZeroMatrix(vB[i]);\n         \n         mC[i].Init(C[i].Rows(),C[i].Cols());\n         vC[i].Init(C[i].Rows(),C[i].Cols());\n         mC[i] = ZeroMatrix(mC[i]);\n         vC[i] = ZeroMatrix(vC[i]);\n      }\n     }\n}\nmatrix SumConvLayer::Output(matrix &X)\n{\nmatrix Out, Y[];\nXc = X;\nArrayResize(Y,N_C);\nfor(int i=0;i<N_C;i++)\n  {\n   if(DIR == VERT) Y[i] = VertConvV(X,K[i]) + B[i];\n   if(DIR == HORZ) Y[i] = HorConvV(X,K[i]) + B[i];\n   }\nOut.Init(B[0].Rows(),B[0].Cols());\n\n//Gravar a entrada\nfor(int i=0;i<N_C;i++)\n  {Xact[i] = Y[i];}\n\n//Zerar a sa\u00edda \nfor(int i=0;i<Out.Rows();i++)\n  {for(int j=0;j<Out.Cols();j++)\n     {Out[i][j] = 0;}}\n\n//Aplicar a fun\u00e7\u00e3o de ativa\u00e7\u00e3o; \nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) Y[i] = Sig(Y[i]);\n   if(AF == TANH)    Y[i] = Tanh(Y[i]);\n   if(AF == RELU)    Y[i] = ReLU(Y[i]);}\n\n//Soma tudo\nfor(int i=0;i<N_C;i++)\n  {Out +=Y[i] * C[i];}\n  \nreturn Out;\n}\n\nmatrix SumConvLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex,dphi[]; \nArrayResize(dphi,N_C);\nEx.Init(Xc.Rows(),Xc.Cols());\n\n//Peso auxiliar\nfor(int i=0;i<N_C;i++)\n   {if(AF == SIGMOID) dC[i] = Sig(Xact[i]) * Ey;\n   if(AF == TANH) dC[i] = Tanh(Xact[i]) * Ey;\n   if(AF == RELU) dC[i] = ReLU(Xact[i]) * Ey;}\n\n//Calcular a derivada da fun\u00e7\u00e3o de ativa\u00e7\u00e3o\nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) dphi[i] = dSig(Xact[i]) * Ey *C[i];\n   if(AF == TANH) dphi[i] = dTanh(Xact[i]) * Ey *C[i];\n   if(AF == RELU) dphi[i] = dReLU(Xact[i]) * Ey *C[i];}\n\n//Zerar o gradiente da entrada\nfor(int i=0;i<Ex.Rows();i++)\n  {for(int j=0;j<Ex.Cols();j++)\n     {Ex[i][j] = 0;}}\n\nmatrix Inv;\n//Calcular as varia\u00e7\u00f5es dos pesos\nfor(int i=0;i<N_C;i++)\n  {if(DIR == VERT)\n     {Inv = VertInv(K[i]);\n      Ex += VertConvF(Inv,dphi[i]);\n      Inv = VertInv(Xc);\n      dK[i] = VertConvV(Inv,dphi[i]);\n      dB[i] = dphi[i];}\n      \n   \n   if(DIR == HORZ)\n     {Inv = HorInv(K[i]);\n      Ex += HorConvF(Inv,dphi[i]);\n      Inv = HorInv(Xc);\n      dK[i] = HorConvV(Inv,dphi[i]);\n      dB[i] = dphi[i];} \n  } \n\nreturn Ex;   \n}\n\n\nvoid   SumConvLayer::Update(void)\n{\nif(OP == STD)\n   {for(int i=0;i<N_C;i++)\n     {K[i] = K[i] - dK[i]*N;\n      B[i] = B[i] - dB[i]*N;\n      C[i] = C[i] - dC[i]*N;\n     }\n   }\nif(OP == ADAM)\n  {\n   it +=1;\n   for(int i=0;i<N_C;i++)\n     {\n      mK[i] = AdamM(mK[i],dK[i],beta1);\n      vK[i] = AdamV(vK[i],dK[i],beta2);\n      K[i] = K[i] - Adam(it,mK[i],vK[i],beta1,beta2,alpha);\n      \n      mB[i] = AdamM(mB[i],dB[i],beta1);\n      vB[i] = AdamV(vB[i],dB[i],beta2);\n      B[i] = B[i] - Adam(it,mB[i],vB[i],beta1,beta2,alpha);\n      \n      mC[i] = AdamM(mC[i],dC[i],beta1);\n      vC[i] = AdamV(vC[i],dC[i],beta2);\n      C[i] = C[i] - Adam(it,mC[i],vC[i],beta1,beta2,alpha);\n     }\n  }\n}\n\nvoid   SumConvLayer::SaveWeights(int k,string IAname)\n{\nfor(int i=0;i<N_C;i++)\n  {\n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(K[i],csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(B[i],csv_name);\n   csv_name = IAname + \"\\CLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(C[i],csv_name);\n  }\n}\n\nvoid   SumConvLayer::LoadWeights(int k,string IAname)\n{\nfor(int i=0;i<N_C;i++)\n   {  \n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k) + IntegerToString(i);\n   K[i] = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k) + IntegerToString(i);\n   B[i] = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k) + IntegerToString(i);\n   C[i] = LoadMatrix(csv_name);\n   }\n}", "search_content": "//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+\n\nclass SumConvLayer : public DeepLearning\n  {\npublic :\n   //Inicializa os kernels e o bias da camada\n   //1<= N_outputs <= N_entries; N_entries-N_outputs+1 =KernelSize.  \n   void InitLayer(int N_steps, int N_entries, int N_outputs, double LR, int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD);\n   //Calcula a sa\u00edda da camada a partir de uma entrada\n   virtual matrix Output(matrix &X);\n   //Propaga o Erro \n   virtual matrix GradDescent(matrix &Ey);\n   //Atualiza os pesos\n   virtual void   Update(void);\n   //Salvar os pesos, k \u00e9 o indice da camada;\n   virtual void   SaveWeights(int k,string IAname);\n   //Carregar os pesos\n   virtual void   LoadWeights(int k,string IAname);\n\nprivate:\n   //Number of convolutions\n   int N_C;\n   //Kernel da Camada\n   matrix K[];\n   //Gradiente do Kernel\n   matrix dK[];\n   //Bias da camada\n   matrix B[];\n   //Gradiente do Bias\n   matrix dB[];\n   //Entrada da Camada de ativa\u00e7\u00e3o\n   matrix Xact[];\n   //Peso auxiliar\n   matrix C[];\n   //gradiente do peso auxiliar \n   matrix dC[];\n   //Entrada da Camada convolucional\n   matrix Xc;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimiza\u00e7\u00e3o\n   Optim OP;\n   //Dire\u00e7\u00e3o da convolu\u00e7\u00e3o\n   CONV_DIR DIR;\n   //Fun\u00e7\u00e3o de Ativa\u00e7\u00e3o\n   ActFunction AF;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mK[], mB[], mC[];\n   //v\n   matrix vK[], vB[], vC[];\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   Sum Convolutional                                              |\n//+------------------------------------------------------------------+ \nvoid SumConvLayer::InitLayer(int N_steps, int N_entries, int N_outputs, double LR,int N_Conv, CONV_DIR direction = HORZ, ActFunction af = TANH, Optim Op = STD)\n{\n   N_C = N_Conv;\n   AF = af;\n   \n   double factor; \n   factor = N_Conv;\n   factor = 1 / factor; \n   \n   ArrayResize(K,N_C);\n   ArrayResize(dK,N_C);\n   \n   ArrayResize(B,N_C);\n   ArrayResize(dB,N_C);\n   \n   ArrayResize(Xact,N_C);\n   ArrayResize(C,N_C);\n   ArrayResize(dC,N_C);\n   \nfor(int i=0;i<N_C;i++)\n  {\n      if(direction == VERT)\n      {  K[i].Init(N_steps-N_outputs+1,N_entries);\n         B[i].Init(N_steps-K[i].Rows()+1,N_entries);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   \n      if(direction == HORZ)\n      {  K[i].Init(N_entries,N_steps-N_outputs + 1);\n         B[i].Init(N_entries,N_steps - K[i].Rows() +1);\n         C[i].Init(B[i].Rows(),B[i].Cols());\n         K[i] = InitWeights(K[i]);\n         B[i] = InitWeights(B[i]);\n         C[i] = InitWeights(C[i]) * factor;}\n   }\n   N = LR;\n   OP = Op;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      ArrayResize(mK,N_C);\n      ArrayResize(vK,N_C);\n      \n      ArrayResize(mB,N_C);\n      ArrayResize(vB,N_C);\n      \n      ArrayResize(mC,N_C);\n      ArrayResize(vC,N_C);\n      \n      for(int i=0;i<N_C;i++)\n      {\n         mK[i].Init(K[i].Rows(),K[i].Cols());\n         vK[i].Init(K[i].Rows(),K[i].Cols());  \n         mK[i] = ZeroMatrix(mK[i]);\n         vK[i] = ZeroMatrix(vK[i]);\n         \n         mB[i].Init(B[i].Rows(),B[i].Cols());\n         vB[i].Init(B[i].Rows(),B[i].Cols());\n         mB[i] = ZeroMatrix(mB[i]);\n         vB[i] = ZeroMatrix(vB[i]);\n         \n         mC[i].Init(C[i].Rows(),C[i].Cols());\n         vC[i].Init(C[i].Rows(),C[i].Cols());\n         mC[i] = ZeroMatrix(mC[i]);\n         vC[i] = ZeroMatrix(vC[i]);\n      }\n     }\n}\nmatrix SumConvLayer::Output(matrix &X)\n{\nmatrix Out, Y[];\nXc = X;\nArrayResize(Y,N_C);\nfor(int i=0;i<N_C;i++)\n  {\n   if(DIR == VERT) Y[i] = VertConvV(X,K[i]) + B[i];\n   if(DIR == HORZ) Y[i] = HorConvV(X,K[i]) + B[i];\n   }\nOut.Init(B[0].Rows(),B[0].Cols());\n\n//Gravar a entrada\nfor(int i=0;i<N_C;i++)\n  {Xact[i] = Y[i];}\n\n//Zerar a sa\u00edda \nfor(int i=0;i<Out.Rows();i++)\n  {for(int j=0;j<Out.Cols();j++)\n     {Out[i][j] = 0;}}\n\n//Aplicar a fun\u00e7\u00e3o de ativa\u00e7\u00e3o; \nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) Y[i] = Sig(Y[i]);\n   if(AF == TANH)    Y[i] = Tanh(Y[i]);\n   if(AF == RELU)    Y[i] = ReLU(Y[i]);}\n\n//Soma tudo\nfor(int i=0;i<N_C;i++)\n  {Out +=Y[i] * C[i];}\n  \nreturn Out;\n}\n\nmatrix SumConvLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex,dphi[]; \nArrayResize(dphi,N_C);\nEx.Init(Xc.Rows(),Xc.Cols());\n\n//Peso auxiliar\nfor(int i=0;i<N_C;i++)\n   {if(AF == SIGMOID) dC[i] = Sig(Xact[i]) * Ey;\n   if(AF == TANH) dC[i] = Tanh(Xact[i]) * Ey;\n   if(AF == RELU) dC[i] = ReLU(Xact[i]) * Ey;}\n\n//Calcular a derivada da fun\u00e7\u00e3o de ativa\u00e7\u00e3o\nfor(int i=0;i<N_C;i++)\n  {if(AF == SIGMOID) dphi[i] = dSig(Xact[i]) * Ey *C[i];\n   if(AF == TANH) dphi[i] = dTanh(Xact[i]) * Ey *C[i];\n   if(AF == RELU) dphi[i] = dReLU(Xact[i]) * Ey *C[i];}\n\n//Zerar o gradiente da entrada\nfor(int i=0;i<Ex.Rows();i++)\n  {for(int j=0;j<Ex.Cols();j++)\n     {Ex[i][j] = 0;}}\n\nmatrix Inv;\n//Calcular as varia\u00e7\u00f5es dos pesos\nfor(int i=0;i<N_C;i++)\n  {if(DIR == VERT)\n     {Inv = VertInv(K[i]);\n      Ex += VertConvF(Inv,dphi[i]);\n      Inv = VertInv(Xc);\n      dK[i] = VertConvV(Inv,dphi[i]);\n      dB[i] = dphi[i];}\n      \n   \n   if(DIR == HORZ)\n     {Inv = HorInv(K[i]);\n      Ex += HorConvF(Inv,dphi[i]);\n      Inv = HorInv(Xc);\n      dK[i] = HorConvV(Inv,dphi[i]);\n      dB[i] = dphi[i];} \n  } \n\nreturn Ex;   \n}\n\n\nvoid   SumConvLayer::Update(void)\n{\nif(OP == STD)\n   {for(int i=0;i<N_C;i++)\n     {K[i] = K[i] - dK[i]*N;\n      B[i] = B[i] - dB[i]*N;\n      C[i] = C[i] - dC[i]*N;\n     }\n   }\nif(OP == ADAM)\n  {\n   it +=1;\n   for(int i=0;i<N_C;i++)\n     {\n      mK[i] = AdamM(mK[i],dK[i],beta1);\n      vK[i] = AdamV(vK[i],dK[i],beta2);\n      K[i] = K[i] - Adam(it,mK[i],vK[i],beta1,beta2,alpha);\n      \n      mB[i] = AdamM(mB[i],dB[i],beta1);\n      vB[i] = AdamV(vB[i],dB[i],beta2);\n      B[i] = B[i] - Adam(it,mB[i],vB[i],beta1,beta2,alpha);\n      \n      mC[i] = AdamM(mC[i],dC[i],beta1);\n      vC[i] = AdamV(vC[i],dC[i],beta2);\n      C[i] = C[i] - Adam(it,mC[i],vC[i],beta1,beta2,alpha);\n     }\n  }\n}\n\nvoid   SumConvLayer::SaveWeights(int k,string IAname)\n{\nfor(int i=0;i<N_C;i++)\n  {\n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(K[i],csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(B[i],csv_name);\n   csv_name = IAname + \"\\CLayer\" + IntegerToString(k)+ IntegerToString(i);\n   SaveMatrix(C[i],csv_name);\n  }\n}\n\nvoid   SumConvLayer::LoadWeights(int k,string IAname)\n{\nfor(int i=0;i<N_C;i++)\n   {  \n   string csv_name;\n   csv_name = IAname + \"\\KLayer\" + IntegerToString(k) + IntegerToString(i);\n   K[i] = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k) + IntegerToString(i);\n   B[i] = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k) + IntegerToString(i);\n   C[i] = LoadMatrix(csv_name);\n   }\n}"}, {"filename": "LSTMLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/LSTMLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\nclass LSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Changing ADAM parameters\n   virtual void   SetAdam(double B1, double B2, double Alph); \n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //Forget gate\n   matrix Wf,Bf,Zf[],\n          dWf,dBf;\n   //Input gate\n   matrix Wi,Bi,Zi[],\n          dWi,dBi;\n   //Output gate\n   matrix Wo,Bo,Zo[],\n          dWo,dBo;\n   //Candidate gate\n   matrix Wg,Bg,Zg[],\n          dWg,dBg;\n   //output\n   matrix Wy,By,Zy[],\n          dWy,dBy;\n   //Hidden state\n   matrix H[];\n   //Long term memory\n   matrix C[];\n   //Input\n   matrix x[],x_h[];\n  \n   //ADAM \n   //===============\n   //Iteration counter\n   ulong it; \n   //m\n   matrix mWy, mWf, mWo, mWi, mWg;\n   matrix mBy, mBf, mBo, mBi, mBg;\n   //v\n   matrix vWy, vWf, vWo, vWi, vWg;\n   matrix vBy, vBf, vBo, vBi, vBg;\n   \n   //hiperparameters \n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\n\nvoid LSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//forget gate\nWf.Init(N_H,N_H + N_ins);\ndWf.Init(N_H,N_H + N_ins);\nWf = InitWeights(Wf)*xavier_;\n\nBf.Init(N_H,1);\ndBf.Init(N_H,1);\nBf = InitWeights(Bf)*xavier_;\n\nArrayResize(Zf,N_ts);\n     \n//input gate\nWi.Init(N_H,N_H + N_ins);\ndWi.Init(N_H,N_H + N_ins);\nWi = InitWeights(Wi)*xavier_;\n\nBi.Init(N_H,1);\ndBi.Init(N_H,1);\nBi = InitWeights(Bi)*xavier_;\n\nArrayResize(Zi,N_ts);\n//output gate\nWo.Init(N_H,N_H + N_ins);\ndWo.Init(N_H,N_H + N_ins);\nWo = InitWeights(Wo)*xavier_;\n\nBo.Init(N_H,1);\ndBo.Init(N_H,1);\nBo = InitWeights(Bo)*xavier_;\n\nArrayResize(Zo,N_ts);     \n// candidate gate\nWg.Init(N_H,N_H + N_ins);\ndWg.Init(N_H,N_H + N_ins);\nWg = InitWeights(Wg)*xavier_;\n\nBg.Init(N_H,1);\ndBg.Init(N_H,1);\nBg = InitWeights(Bg)*xavier_;\n\nArrayResize(Zg,N_ts);\n//Output\nWy.Init(N_outs,N_H);\ndWy.Init(N_outs,N_H);\nWy = InitWeights(Wy)*xavier_;\n\n\nBy.Init(N_outs,1);\ndBy.Init(N_outs,1);\nBy = InitWeights(By)*xavier_;\n\nArrayResize(Zy,N_ts);\n\n//Estado Oculto\nArrayResize(H,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(C,N_ts+1);\n\n//Entrada \nArrayResize(x,N_ts);\nArrayResize(x_h,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWy.Init(Wy.Rows(),Wy.Cols());\n      vWy.Init(Wy.Rows(),Wy.Cols());  \n      mWy = ZeroMatrix(mWy);\n      vWy = ZeroMatrix(vWy);\n      \n      mBy.Init(By.Rows(),By.Cols());\n      vBy.Init(By.Rows(),By.Cols());\n      mBy= ZeroMatrix(mBy);\n      vBy = ZeroMatrix(vBy);\n      \n      //Forget gate\n      mWf.Init(Wf.Rows(),Wf.Cols());\n      vWf.Init(Wf.Rows(),Wf.Cols());  \n      mWf = ZeroMatrix(mWf);\n      vWf = ZeroMatrix(vWf);\n      \n      mBf.Init(Bf.Rows(),Bf.Cols());\n      vBf.Init(Bf.Rows(),Bf.Cols());\n      mBf = ZeroMatrix(mBf);\n      vBf = ZeroMatrix(vBf);\n      \n      //Output Gate\n      mWo.Init(Wo.Rows(),Wo.Cols());\n      vWo.Init(Wo.Rows(),Wo.Cols());  \n      mWo = ZeroMatrix(mWo);\n      vWo = ZeroMatrix(vWo);\n      \n      mBo.Init(Bo.Rows(),Bo.Cols());\n      vBo.Init(Bo.Rows(),Bo.Cols());\n      mBo = ZeroMatrix(mBo);\n      vBo = ZeroMatrix(vBo);\n      \n      //Input Gate\n      mWi.Init(Wi.Rows(),Wi.Cols());\n      vWi.Init(Wi.Rows(),Wi.Cols());  \n      mWi = ZeroMatrix(mWi);\n      vWi = ZeroMatrix(vWi);\n      \n      mBi.Init(Bi.Rows(),Bi.Cols());\n      vBi.Init(Bi.Rows(),Bi.Cols());\n      mBi = ZeroMatrix(mBi);\n      vBi = ZeroMatrix(vBi);\n      \n      //Candidate Gate\n      mWg.Init(Wg.Rows(),Wg.Cols());\n      vWg.Init(Wg.Rows(),Wg.Cols());  \n      mWg = ZeroMatrix(mWg);\n      vWg = ZeroMatrix(vWg);\n      \n      mBg.Init(Bg.Rows(),Bg.Cols());\n      vBg.Init(Bg.Rows(),Bg.Cols());\n      mBg = ZeroMatrix(mBg);\n      vBg = ZeroMatrix(vBg);\n     } \n}\nmatrix LSTMLayer::Output(matrix &X)\n{\n//Zera o estado oculto anterior\n\nH[0].Init(N_H,1);\nH[0] = ZeroMatrix(H[0]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nC[0].Init(N_H,1);\nC[0] = ZeroMatrix(C[0]);\n\n     \n//Define a matrix de sa\u00edda \nmatrix Y; \nY.Init(N_outs,N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix y;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {x[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix F,I,O,G; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {x[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_h[t] = Concatenate(H[t],x[t]); \n\n\n   //Forget gate\n   Zf[t] = Wf.MatMul(x_h[t])  + Bf;\n   F = Sig(Zf[t]);\n   //Imput gate\n   Zi[t] = Wi.MatMul(x_h[t])  + Bi;\n   I = Sig(Zi[t]);\n   //Output gate\n   Zo[t] = Wo.MatMul(x_h[t])  + Bo;\n   O = Sig(Zo[t]);\n   //Candidate gate\n   Zg[t] = Wg.MatMul(x_h[t])  + Bg;\n   G = Tanh(Zg[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   C[t+1] = F * C[t] + I * G;\n   //C\u00e1lculo do novo estado oculto\n   H[t+1] = Tanh(C[t+1]);\n   H[t+1]= H[t+1] * O;\n   \n   //Sa\u00edda\n   y = Wy.MatMul(H[t+1]) + By;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<y.Rows();i++)\n     {Y[i][t] = y[i][0];}\n    \n  }\nreturn Y;\n}\nmatrix LSTMLayer::GradDescent(matrix &Ey)\n{\n//Gradient \nmatrix Ex;\nEx.Init(N_ins,N_ts);\n \n//Forget Gate\ndWf = ZeroMatrix(dWf);\ndBf = ZeroMatrix(dBf);\n\n//Input Gate\ndWi = ZeroMatrix(dWi);\ndBi = ZeroMatrix(dBi);\n\n//Output Gate\ndWo = ZeroMatrix(dWo);\ndBo = ZeroMatrix(dBo);\n\n//Candidate Gate\ndWg = ZeroMatrix(dWg);\ndBg = ZeroMatrix(dBg);\n\n//Y gate\ndWy = ZeroMatrix(dWy);\ndBy = ZeroMatrix(dBy);\n//Erro por passo de tempo \nmatrix ey;\ney.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_h, d_c, d_f, d_i, d_o, d_g,d_x_h;\n\n//Estado oculto para t+1\nmatrix dh_next;\ndh_next.Init(N_H,1);\ndh_next = ZeroMatrix(dh_next);\n\nmatrix dc_next;\ndc_next.Init(N_H,1);\ndc_next = ZeroMatrix(dc_next);\n\nmatrix ex;\nex.Init(N_ins,1);\n\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {ey[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWy += ey.MatMul(H[t+1].Transpose());\n   dBy += ey;\n   \n   //Hidden State Error\n   d_h = Wy.Transpose();\n   d_h = d_h.MatMul(ey) + dh_next;\n   \n   //Output gate\n   d_o = d_h * Tanh(C[t+1]) * dSig(Zo[t]);\n   dWo += d_o.MatMul(x_h[t].Transpose());\n   dBo += d_o;\n   \n   //Cell state error\n   d_c = d_h * dTanh(C[t+1]) * Sig(Zo[t]) + dc_next;\n   \n   //Forget gate\n   d_f = d_c * C[t] * dSig(Zf[t]);\n   dWf += d_f.MatMul(x_h[t].Transpose());\n   dBf += d_f;\n   \n   //Input gate\n   d_i = d_c * Tanh(Zg[t]) * dSig(Zi[t]);\n   dWi += d_i.MatMul(x_h[t].Transpose());\n   dBi += d_i;\n   \n   //Candidate gate\n   d_g = d_c * Sig(Zi[t]) * dTanh(Zg[t]);\n   dWg += d_g.MatMul(x_h[t].Transpose());\n   dBg += d_g;\n   \n   //Concatenated Input gradient\n   d_x_h = Wf.Transpose().MatMul(d_f) + Wi.Transpose().MatMul(d_i) + Wo.Transpose().MatMul(d_o) + Wg.Transpose().MatMul(d_g);\n   \n   //Error of Cell state of next time step\n   dc_next = Sig(Zf[t]) * d_c; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_h.Rows();i++)\n     {if(i < N_H) dh_next[i][0] = d_x_h[i][0];\n      if(i >= N_H) ex[i-N_H][0] = d_x_h[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex.Rows();i++)\n     {Ex[i][t] = ex[i][0];}   \n  \n  }\nreturn Ex;\n}\nvoid   LSTMLayer::Update(void)\n{\nif(OP == STD)\n  {\n   Wf = Wf - dWf*N;\n   Wi = Wi - dWi*N;\n   Wo = Wo - dWo*N;\n   Wg = Wg - dWg*N;\n   Wy = Wy - dWy*N;\n   \n   Bf = Bf - dBf*N;\n   Bi = Bi - dBi*N;\n   Bo = Bo - dBo*N;\n   Bg = Bg - dBg*N;\n   By = By - dBy*N;\n  }\n\nif(OP == ADAM)\n  {\n      it +=1;\n      //sa\u00edda\n      mWy = AdamM(mWy,dWy,beta1);\n      vWy = AdamV(vWy,dWy,beta2);\n      Wy = Wy - Adam(it,mWy,vWy,beta1,beta2,alpha);\n      \n      mBy = AdamM(mBy,dBy,beta1);\n      vBy = AdamV(vBy,dBy,beta2);\n      By = By -Adam(it,mBy,vBy,beta1,beta2,alpha);\n      \n      //Forget\n      mWf = AdamM(mWf,dWf,beta1);\n      vWf = AdamV(vWf,dWf,beta2);\n      Wf = Wf - Adam(it,mWf,vWf,beta1,beta2,alpha);\n      \n      mBf = AdamM(mBf,dBf,beta1);\n      vBf = AdamV(vBf,dBf,beta2);\n      Bf = Bf -Adam(it,mBf,vBf,beta1,beta2,alpha);\n      \n      //Output\n      mWo = AdamM(mWo,dWo,beta1);\n      vWo = AdamV(vWo,dWo,beta2);\n      Wo = Wo - Adam(it,mWo,vWo,beta1,beta2,alpha);\n      \n      mBo = AdamM(mBo,dBo,beta1);\n      vBo = AdamV(vBo,dBo,beta2);\n      Bo = Bo -Adam(it,mBo,vBo,beta1,beta2,alpha);\n      \n      //Input\n      mWi = AdamM(mWi,dWi,beta1);\n      vWi = AdamV(vWi,dWi,beta2);\n      Wi = Wi- Adam(it,mWi,vWi,beta1,beta2,alpha);\n      \n      mBi = AdamM(mBi,dBi,beta1);\n      vBi = AdamV(vBi,dBi,beta2);\n      Bi = Bi -Adam(it,mBi,vBi,beta1,beta2,alpha);\n      \n      //Candidate\n      mWg = AdamM(mWg,dWg,beta1);\n      vWg = AdamV(vWg,dWg,beta2);\n      Wg = Wg - Adam(it,mWg,vWg,beta1,beta2,alpha);\n      \n      mBg = AdamM(mBg,dBg,beta1);\n      vBg = AdamV(vBg,dBg,beta2);\n      Bg = Bg -Adam(it,mBg,vBg,beta1,beta2,alpha);\n  }\n\n}\nvoid   LSTMLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfLayer\" + IntegerToString(k);\n   SaveMatrix(Wf,csv_name);\n   csv_name = IAname + \"\\WiLayer\" + IntegerToString(k);\n   SaveMatrix(Wi,csv_name);\n   csv_name = IAname + \"\\WoLayer\" + IntegerToString(k);\n   SaveMatrix(Wo,csv_name);\n   csv_name = IAname + \"\\WgLayer\" + IntegerToString(k);\n   SaveMatrix(Wg,csv_name);\n   csv_name = IAname + \"\\WyLayer\" + IntegerToString(k);\n   SaveMatrix(Wy,csv_name);\n   \n   csv_name = IAname + \"\\BfLayer\" + IntegerToString(k);\n   SaveMatrix(Bf,csv_name);\n   csv_name = IAname + \"\\BiLayer\" + IntegerToString(k);\n   SaveMatrix(Bi,csv_name);\n   csv_name = IAname + \"\\BoLayer\" + IntegerToString(k);\n   SaveMatrix(Bo,csv_name);\n   csv_name = IAname + \"\\BgLayer\" + IntegerToString(k);\n   SaveMatrix(Bg,csv_name);\n   csv_name = IAname + \"\\ByLayer\" + IntegerToString(k);\n   SaveMatrix(By,csv_name);\n}\nvoid   LSTMLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfLayer\" + IntegerToString(k);\n   Wf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WiLayer\" + IntegerToString(k);\n   Wi = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WoLayer\" + IntegerToString(k);\n   Wo = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgLayer\" + IntegerToString(k);\n   Wg = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WyLayer\" + IntegerToString(k);\n   Wy = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BfLayer\" + IntegerToString(k);\n   Bf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BiLayer\" + IntegerToString(k);\n   Bi = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BoLayer\" + IntegerToString(k);\n   Bo = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgLayer\" + IntegerToString(k);\n   Bg = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\ByLayer\" + IntegerToString(k);\n   By = LoadMatrix(csv_name);\n\n}\nvoid   LSTMLayer::SetAdam(double B1, double B2, double Alph)\n{\n\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}", "search_content": "//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\nclass LSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Update the weights\n   virtual void   Update(void);\n   //Save the weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Changing ADAM parameters\n   virtual void   SetAdam(double B1, double B2, double Alph); \n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //Forget gate\n   matrix Wf,Bf,Zf[],\n          dWf,dBf;\n   //Input gate\n   matrix Wi,Bi,Zi[],\n          dWi,dBi;\n   //Output gate\n   matrix Wo,Bo,Zo[],\n          dWo,dBo;\n   //Candidate gate\n   matrix Wg,Bg,Zg[],\n          dWg,dBg;\n   //output\n   matrix Wy,By,Zy[],\n          dWy,dBy;\n   //Hidden state\n   matrix H[];\n   //Long term memory\n   matrix C[];\n   //Input\n   matrix x[],x_h[];\n  \n   //ADAM \n   //===============\n   //Iteration counter\n   ulong it; \n   //m\n   matrix mWy, mWf, mWo, mWi, mWg;\n   matrix mBy, mBf, mBo, mBi, mBg;\n   //v\n   matrix vWy, vWf, vWo, vWi, vWg;\n   matrix vBy, vBf, vBo, vBi, vBg;\n   \n   //hiperparameters \n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   LSTM                                                           |\n//+------------------------------------------------------------------+\n\nvoid LSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//forget gate\nWf.Init(N_H,N_H + N_ins);\ndWf.Init(N_H,N_H + N_ins);\nWf = InitWeights(Wf)*xavier_;\n\nBf.Init(N_H,1);\ndBf.Init(N_H,1);\nBf = InitWeights(Bf)*xavier_;\n\nArrayResize(Zf,N_ts);\n     \n//input gate\nWi.Init(N_H,N_H + N_ins);\ndWi.Init(N_H,N_H + N_ins);\nWi = InitWeights(Wi)*xavier_;\n\nBi.Init(N_H,1);\ndBi.Init(N_H,1);\nBi = InitWeights(Bi)*xavier_;\n\nArrayResize(Zi,N_ts);\n//output gate\nWo.Init(N_H,N_H + N_ins);\ndWo.Init(N_H,N_H + N_ins);\nWo = InitWeights(Wo)*xavier_;\n\nBo.Init(N_H,1);\ndBo.Init(N_H,1);\nBo = InitWeights(Bo)*xavier_;\n\nArrayResize(Zo,N_ts);     \n// candidate gate\nWg.Init(N_H,N_H + N_ins);\ndWg.Init(N_H,N_H + N_ins);\nWg = InitWeights(Wg)*xavier_;\n\nBg.Init(N_H,1);\ndBg.Init(N_H,1);\nBg = InitWeights(Bg)*xavier_;\n\nArrayResize(Zg,N_ts);\n//Output\nWy.Init(N_outs,N_H);\ndWy.Init(N_outs,N_H);\nWy = InitWeights(Wy)*xavier_;\n\n\nBy.Init(N_outs,1);\ndBy.Init(N_outs,1);\nBy = InitWeights(By)*xavier_;\n\nArrayResize(Zy,N_ts);\n\n//Estado Oculto\nArrayResize(H,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(C,N_ts+1);\n\n//Entrada \nArrayResize(x,N_ts);\nArrayResize(x_h,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWy.Init(Wy.Rows(),Wy.Cols());\n      vWy.Init(Wy.Rows(),Wy.Cols());  \n      mWy = ZeroMatrix(mWy);\n      vWy = ZeroMatrix(vWy);\n      \n      mBy.Init(By.Rows(),By.Cols());\n      vBy.Init(By.Rows(),By.Cols());\n      mBy= ZeroMatrix(mBy);\n      vBy = ZeroMatrix(vBy);\n      \n      //Forget gate\n      mWf.Init(Wf.Rows(),Wf.Cols());\n      vWf.Init(Wf.Rows(),Wf.Cols());  \n      mWf = ZeroMatrix(mWf);\n      vWf = ZeroMatrix(vWf);\n      \n      mBf.Init(Bf.Rows(),Bf.Cols());\n      vBf.Init(Bf.Rows(),Bf.Cols());\n      mBf = ZeroMatrix(mBf);\n      vBf = ZeroMatrix(vBf);\n      \n      //Output Gate\n      mWo.Init(Wo.Rows(),Wo.Cols());\n      vWo.Init(Wo.Rows(),Wo.Cols());  \n      mWo = ZeroMatrix(mWo);\n      vWo = ZeroMatrix(vWo);\n      \n      mBo.Init(Bo.Rows(),Bo.Cols());\n      vBo.Init(Bo.Rows(),Bo.Cols());\n      mBo = ZeroMatrix(mBo);\n      vBo = ZeroMatrix(vBo);\n      \n      //Input Gate\n      mWi.Init(Wi.Rows(),Wi.Cols());\n      vWi.Init(Wi.Rows(),Wi.Cols());  \n      mWi = ZeroMatrix(mWi);\n      vWi = ZeroMatrix(vWi);\n      \n      mBi.Init(Bi.Rows(),Bi.Cols());\n      vBi.Init(Bi.Rows(),Bi.Cols());\n      mBi = ZeroMatrix(mBi);\n      vBi = ZeroMatrix(vBi);\n      \n      //Candidate Gate\n      mWg.Init(Wg.Rows(),Wg.Cols());\n      vWg.Init(Wg.Rows(),Wg.Cols());  \n      mWg = ZeroMatrix(mWg);\n      vWg = ZeroMatrix(vWg);\n      \n      mBg.Init(Bg.Rows(),Bg.Cols());\n      vBg.Init(Bg.Rows(),Bg.Cols());\n      mBg = ZeroMatrix(mBg);\n      vBg = ZeroMatrix(vBg);\n     } \n}\nmatrix LSTMLayer::Output(matrix &X)\n{\n//Zera o estado oculto anterior\n\nH[0].Init(N_H,1);\nH[0] = ZeroMatrix(H[0]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nC[0].Init(N_H,1);\nC[0] = ZeroMatrix(C[0]);\n\n     \n//Define a matrix de sa\u00edda \nmatrix Y; \nY.Init(N_outs,N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix y;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {x[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix F,I,O,G; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {x[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_h[t] = Concatenate(H[t],x[t]); \n\n\n   //Forget gate\n   Zf[t] = Wf.MatMul(x_h[t])  + Bf;\n   F = Sig(Zf[t]);\n   //Imput gate\n   Zi[t] = Wi.MatMul(x_h[t])  + Bi;\n   I = Sig(Zi[t]);\n   //Output gate\n   Zo[t] = Wo.MatMul(x_h[t])  + Bo;\n   O = Sig(Zo[t]);\n   //Candidate gate\n   Zg[t] = Wg.MatMul(x_h[t])  + Bg;\n   G = Tanh(Zg[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   C[t+1] = F * C[t] + I * G;\n   //C\u00e1lculo do novo estado oculto\n   H[t+1] = Tanh(C[t+1]);\n   H[t+1]= H[t+1] * O;\n   \n   //Sa\u00edda\n   y = Wy.MatMul(H[t+1]) + By;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<y.Rows();i++)\n     {Y[i][t] = y[i][0];}\n    \n  }\nreturn Y;\n}\nmatrix LSTMLayer::GradDescent(matrix &Ey)\n{\n//Gradient \nmatrix Ex;\nEx.Init(N_ins,N_ts);\n \n//Forget Gate\ndWf = ZeroMatrix(dWf);\ndBf = ZeroMatrix(dBf);\n\n//Input Gate\ndWi = ZeroMatrix(dWi);\ndBi = ZeroMatrix(dBi);\n\n//Output Gate\ndWo = ZeroMatrix(dWo);\ndBo = ZeroMatrix(dBo);\n\n//Candidate Gate\ndWg = ZeroMatrix(dWg);\ndBg = ZeroMatrix(dBg);\n\n//Y gate\ndWy = ZeroMatrix(dWy);\ndBy = ZeroMatrix(dBy);\n//Erro por passo de tempo \nmatrix ey;\ney.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_h, d_c, d_f, d_i, d_o, d_g,d_x_h;\n\n//Estado oculto para t+1\nmatrix dh_next;\ndh_next.Init(N_H,1);\ndh_next = ZeroMatrix(dh_next);\n\nmatrix dc_next;\ndc_next.Init(N_H,1);\ndc_next = ZeroMatrix(dc_next);\n\nmatrix ex;\nex.Init(N_ins,1);\n\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {ey[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWy += ey.MatMul(H[t+1].Transpose());\n   dBy += ey;\n   \n   //Hidden State Error\n   d_h = Wy.Transpose();\n   d_h = d_h.MatMul(ey) + dh_next;\n   \n   //Output gate\n   d_o = d_h * Tanh(C[t+1]) * dSig(Zo[t]);\n   dWo += d_o.MatMul(x_h[t].Transpose());\n   dBo += d_o;\n   \n   //Cell state error\n   d_c = d_h * dTanh(C[t+1]) * Sig(Zo[t]) + dc_next;\n   \n   //Forget gate\n   d_f = d_c * C[t] * dSig(Zf[t]);\n   dWf += d_f.MatMul(x_h[t].Transpose());\n   dBf += d_f;\n   \n   //Input gate\n   d_i = d_c * Tanh(Zg[t]) * dSig(Zi[t]);\n   dWi += d_i.MatMul(x_h[t].Transpose());\n   dBi += d_i;\n   \n   //Candidate gate\n   d_g = d_c * Sig(Zi[t]) * dTanh(Zg[t]);\n   dWg += d_g.MatMul(x_h[t].Transpose());\n   dBg += d_g;\n   \n   //Concatenated Input gradient\n   d_x_h = Wf.Transpose().MatMul(d_f) + Wi.Transpose().MatMul(d_i) + Wo.Transpose().MatMul(d_o) + Wg.Transpose().MatMul(d_g);\n   \n   //Error of Cell state of next time step\n   dc_next = Sig(Zf[t]) * d_c; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_h.Rows();i++)\n     {if(i < N_H) dh_next[i][0] = d_x_h[i][0];\n      if(i >= N_H) ex[i-N_H][0] = d_x_h[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex.Rows();i++)\n     {Ex[i][t] = ex[i][0];}   \n  \n  }\nreturn Ex;\n}\nvoid   LSTMLayer::Update(void)\n{\nif(OP == STD)\n  {\n   Wf = Wf - dWf*N;\n   Wi = Wi - dWi*N;\n   Wo = Wo - dWo*N;\n   Wg = Wg - dWg*N;\n   Wy = Wy - dWy*N;\n   \n   Bf = Bf - dBf*N;\n   Bi = Bi - dBi*N;\n   Bo = Bo - dBo*N;\n   Bg = Bg - dBg*N;\n   By = By - dBy*N;\n  }\n\nif(OP == ADAM)\n  {\n      it +=1;\n      //sa\u00edda\n      mWy = AdamM(mWy,dWy,beta1);\n      vWy = AdamV(vWy,dWy,beta2);\n      Wy = Wy - Adam(it,mWy,vWy,beta1,beta2,alpha);\n      \n      mBy = AdamM(mBy,dBy,beta1);\n      vBy = AdamV(vBy,dBy,beta2);\n      By = By -Adam(it,mBy,vBy,beta1,beta2,alpha);\n      \n      //Forget\n      mWf = AdamM(mWf,dWf,beta1);\n      vWf = AdamV(vWf,dWf,beta2);\n      Wf = Wf - Adam(it,mWf,vWf,beta1,beta2,alpha);\n      \n      mBf = AdamM(mBf,dBf,beta1);\n      vBf = AdamV(vBf,dBf,beta2);\n      Bf = Bf -Adam(it,mBf,vBf,beta1,beta2,alpha);\n      \n      //Output\n      mWo = AdamM(mWo,dWo,beta1);\n      vWo = AdamV(vWo,dWo,beta2);\n      Wo = Wo - Adam(it,mWo,vWo,beta1,beta2,alpha);\n      \n      mBo = AdamM(mBo,dBo,beta1);\n      vBo = AdamV(vBo,dBo,beta2);\n      Bo = Bo -Adam(it,mBo,vBo,beta1,beta2,alpha);\n      \n      //Input\n      mWi = AdamM(mWi,dWi,beta1);\n      vWi = AdamV(vWi,dWi,beta2);\n      Wi = Wi- Adam(it,mWi,vWi,beta1,beta2,alpha);\n      \n      mBi = AdamM(mBi,dBi,beta1);\n      vBi = AdamV(vBi,dBi,beta2);\n      Bi = Bi -Adam(it,mBi,vBi,beta1,beta2,alpha);\n      \n      //Candidate\n      mWg = AdamM(mWg,dWg,beta1);\n      vWg = AdamV(vWg,dWg,beta2);\n      Wg = Wg - Adam(it,mWg,vWg,beta1,beta2,alpha);\n      \n      mBg = AdamM(mBg,dBg,beta1);\n      vBg = AdamV(vBg,dBg,beta2);\n      Bg = Bg -Adam(it,mBg,vBg,beta1,beta2,alpha);\n  }\n\n}\nvoid   LSTMLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfLayer\" + IntegerToString(k);\n   SaveMatrix(Wf,csv_name);\n   csv_name = IAname + \"\\WiLayer\" + IntegerToString(k);\n   SaveMatrix(Wi,csv_name);\n   csv_name = IAname + \"\\WoLayer\" + IntegerToString(k);\n   SaveMatrix(Wo,csv_name);\n   csv_name = IAname + \"\\WgLayer\" + IntegerToString(k);\n   SaveMatrix(Wg,csv_name);\n   csv_name = IAname + \"\\WyLayer\" + IntegerToString(k);\n   SaveMatrix(Wy,csv_name);\n   \n   csv_name = IAname + \"\\BfLayer\" + IntegerToString(k);\n   SaveMatrix(Bf,csv_name);\n   csv_name = IAname + \"\\BiLayer\" + IntegerToString(k);\n   SaveMatrix(Bi,csv_name);\n   csv_name = IAname + \"\\BoLayer\" + IntegerToString(k);\n   SaveMatrix(Bo,csv_name);\n   csv_name = IAname + \"\\BgLayer\" + IntegerToString(k);\n   SaveMatrix(Bg,csv_name);\n   csv_name = IAname + \"\\ByLayer\" + IntegerToString(k);\n   SaveMatrix(By,csv_name);\n}\nvoid   LSTMLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfLayer\" + IntegerToString(k);\n   Wf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WiLayer\" + IntegerToString(k);\n   Wi = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WoLayer\" + IntegerToString(k);\n   Wo = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgLayer\" + IntegerToString(k);\n   Wg = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WyLayer\" + IntegerToString(k);\n   Wy = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BfLayer\" + IntegerToString(k);\n   Bf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BiLayer\" + IntegerToString(k);\n   Bi = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BoLayer\" + IntegerToString(k);\n   Bo = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgLayer\" + IntegerToString(k);\n   Bg = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\ByLayer\" + IntegerToString(k);\n   By = LoadMatrix(csv_name);\n\n}\nvoid   LSTMLayer::SetAdam(double B1, double B2, double Alph)\n{\n\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}"}, {"filename": "DropoutLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/DropoutLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Dropout Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass DropoutLayer : public DeepLearning\n  {\npublic:\n\n   //Initializes the layer weights and bias from the number of neurons\n   void InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index of the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   //Set a different value for the DropOut rate\n   virtual void   SetDrop(double Drop);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \nprivate:\n   //weight sof the layer\n   matrix W;\n   //Gradients of the weights \n   matrix dW;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input vector\n   matrix Xe;\n   //Learning rate\n   double N;\n   //dropout rate\n   double drop;\n   //Dropout matrix\n   matrix D;\n   //Optimization method\n   Optim OP;\n   \n      //ADAM \n   //===============\n   //Iterations counter\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   DropoutLayer                                                               |\n//+------------------------------------------------------------------+\nvoid DropoutLayer::InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n\n   drop = Drop;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n}\nmatrix DropoutLayer::Output(matrix &X)\n{\n\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\n\n//Constru\u00e7\u00e3o da matriz de Dropout\nmatrix Dp;\nDp.Init(Y.Rows(),Y.Cols());\nfor(int i=0;i<Dp.Rows();i++)\n  {for(int j=0;j<Dp.Cols();j++)\n     {if(rand()/32780.0 < drop)  Dp[i][j] = 1;\n      else Dp[i][j] = 0; }}\nD = Dp;\n\nY = Y * Dp;\nreturn Y;\n}\nmatrix DropoutLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex;\n   Ey = Ey * D;\n   Ex = W.Transpose().MatMul(Ey);\n\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   \n   return Ex;\n}\nvoid DropoutLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   \n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid DropoutLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid DropoutLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n}\nvoid DropoutLayer::SetDrop(double Drop)\n{\ndrop = Drop;\n}\nvoid DropoutLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}", "search_content": "//+------------------------------------------------------------------+\n//|   Dropout Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass DropoutLayer : public DeepLearning\n  {\npublic:\n\n   //Initializes the layer weights and bias from the number of neurons\n   void InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD);\n   //Calculates the output of the litter from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index of the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights \n   virtual void   LoadWeights(int k,string IAname);\n   //Set a different value for the DropOut rate\n   virtual void   SetDrop(double Drop);\n   \n   //ADAM\n   virtual void   SetAdam(double B1,double B2,double Alph);\n   \nprivate:\n   //weight sof the layer\n   matrix W;\n   //Gradients of the weights \n   matrix dW;\n   //Bias of the layer\n   matrix B;\n   //Bias gradient\n   matrix dB;\n   //Input vector\n   matrix Xe;\n   //Learning rate\n   double N;\n   //dropout rate\n   double drop;\n   //Dropout matrix\n   matrix D;\n   //Optimization method\n   Optim OP;\n   \n      //ADAM \n   //===============\n   //Iterations counter\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiperparameters \n   double beta1, beta2, alpha; \n  };\n\n//+------------------------------------------------------------------+\n//|   DropoutLayer                                                               |\n//+------------------------------------------------------------------+\nvoid DropoutLayer::InitLayer(int N_entries, int N_outputs, double LR, double Drop,Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n\n   drop = Drop;\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n}\nmatrix DropoutLayer::Output(matrix &X)\n{\n\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\n\n//Constru\u00e7\u00e3o da matriz de Dropout\nmatrix Dp;\nDp.Init(Y.Rows(),Y.Cols());\nfor(int i=0;i<Dp.Rows();i++)\n  {for(int j=0;j<Dp.Cols();j++)\n     {if(rand()/32780.0 < drop)  Dp[i][j] = 1;\n      else Dp[i][j] = 0; }}\nD = Dp;\n\nY = Y * Dp;\nreturn Y;\n}\nmatrix DropoutLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex;\n   Ey = Ey * D;\n   Ex = W.Transpose().MatMul(Ey);\n\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   \n   return Ex;\n}\nvoid DropoutLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   \n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }\n}\nvoid DropoutLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n   \n} \n\nvoid DropoutLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n}\nvoid DropoutLayer::SetDrop(double Drop)\n{\ndrop = Drop;\n}\nvoid DropoutLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}"}, {"filename": "BiLSTMLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/BiLSTMLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   BiLSTM Layer                                                   |\n//+------------------------------------------------------------------+\n\nclass BiLSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the error\n   virtual void   Update(void);\n   //Save weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   \n   //ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //From Past to Future:\n   //Forget gate\n   matrix Wfp,Bfp,Zfp[],\n          dWfp,dBfp;\n   //Input gate\n   matrix Wip,Bip,Zip[],\n          dWip,dBip;\n   //Output gate\n   matrix Wop,Bop,Zop[],\n          dWop,dBop;\n   //Candidate gate\n   matrix Wgp,Bgp,Zgp[],\n          dWgp,dBgp;\n   //sa\u00edda\n   matrix Wyp,Byp,Zyp[],\n          dWyp,dByp;\n   //Estado Oculto\n   matrix Hp[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cp[];\n   //Entrada\n   matrix xp[],x_hp[];\n  \n  \n   //From Future to Past\n   //Forget gate\n   matrix Wff,Bff,Zff[],\n          dWff,dBff;\n   //Input gate\n   matrix Wif,Bif,Zif[],\n          dWif,dBif;\n   //Output gate\n   matrix Wof,Bof,Zof[],\n          dWof,dBof;\n   //Candidate gate\n   matrix Wgf,Bgf,Zgf[],\n          dWgf,dBgf;\n   //sa\u00edda\n   matrix Wyf,Byf,Zyf[],\n          dWyf,dByf;\n   //Estado Oculto\n   matrix Hf[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cf[];\n   //Entrada\n   matrix xf[],x_hf[];\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mWyp, mWfp, mWop, mWip, mWgp;\n   matrix mByp, mBfp, mBop, mBip, mBgp;\n   //v\n   matrix vWyp, vWfp, vWop, vWip, vWgp;\n   matrix vByp, vBfp, vBop, vBip, vBgp;\n   \n   matrix mWyf, mWff, mWof, mWif, mWgf;\n   matrix mByf, mBff, mBof, mBif, mBgf;\n   //v\n   matrix vWyf, vWff, vWof, vWif, vWgf;\n   matrix vByf, vBff, vBof, vBif, vBgf;\n   \n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   BiLSTM                                                         |\n//+------------------------------------------------------------------+\nvoid BiLSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//From Past to Future\n//=============================\n\n//forget gate\nWfp.Init(N_H,N_H + N_ins);\ndWfp.Init(N_H,N_H + N_ins);\nWfp = InitWeights(Wfp)*xavier_;\n\nBfp.Init(N_H,1);\ndBfp.Init(N_H,1);\nBfp = InitWeights(Bfp)*xavier_;\n\nArrayResize(Zfp,N_ts);\n     \n//input gate\nWip.Init(N_H,N_H + N_ins);\ndWip.Init(N_H,N_H + N_ins);\nWip = InitWeights(Wip)*xavier_;\n\nBip.Init(N_H,1);\ndBip.Init(N_H,1);\nBip = InitWeights(Bip)*xavier_;\n\nArrayResize(Zip,N_ts);\n\n//output gate\nWop.Init(N_H,N_H + N_ins);\ndWop.Init(N_H,N_H + N_ins);\nWop = InitWeights(Wop)*xavier_;\n\nBop.Init(N_H,1);\ndBop.Init(N_H,1);\nBop = InitWeights(Bop)*xavier_;\n\nArrayResize(Zop,N_ts);\n     \n// candidate gate\nWgp.Init(N_H,N_H + N_ins);\ndWgp.Init(N_H,N_H + N_ins);\nWgp = InitWeights(Wgp)*xavier_;\n\nBgp.Init(N_H,1);\ndBgp.Init(N_H,1);\nBgp = InitWeights(Bgp)*xavier_;\n\nArrayResize(Zgp,N_ts);\n\n//Output\nWyp.Init(N_outs,N_H);\ndWyp.Init(N_outs,N_H);\nWyp = InitWeights(Wyp)*xavier_;\n\n\nByp.Init(N_outs,1);\ndByp.Init(N_outs,1);\nByp = InitWeights(Byp)*xavier_;\n\nArrayResize(Zyp,N_ts);\n\n//Estado Oculto\nArrayResize(Hp,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(Cp,N_ts+1);\n\n//Entrada \nArrayResize(xp,N_ts);\nArrayResize(x_hp,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWyp.Init(Wyp.Rows(),Wyp.Cols());\n      vWyp.Init(Wyp.Rows(),Wyp.Cols());  \n      mWyp = ZeroMatrix(mWyp);\n      vWyp = ZeroMatrix(vWyp);\n      \n      mByp.Init(Byp.Rows(),Byp.Cols());\n      vByp.Init(Byp.Rows(),Byp.Cols());\n      mByp= ZeroMatrix(mByp);\n      vByp = ZeroMatrix(vByp);\n      \n      //Forget gate\n      mWfp.Init(Wfp.Rows(),Wfp.Cols());\n      vWfp.Init(Wfp.Rows(),Wfp.Cols());  \n      mWfp = ZeroMatrix(mWfp);\n      vWfp = ZeroMatrix(vWfp);\n      \n      mBfp.Init(Bfp.Rows(),Bfp.Cols());\n      vBfp.Init(Bfp.Rows(),Bfp.Cols());\n      mBfp = ZeroMatrix(mBfp);\n      vBfp = ZeroMatrix(vBfp);\n      \n      //Output Gate\n      mWop.Init(Wop.Rows(),Wop.Cols());\n      vWop.Init(Wop.Rows(),Wop.Cols());  \n      mWop = ZeroMatrix(mWop);\n      vWop = ZeroMatrix(vWop);\n      \n      mBop.Init(Bop.Rows(),Bop.Cols());\n      vBop.Init(Bop.Rows(),Bop.Cols());\n      mBop = ZeroMatrix(mBop);\n      vBop = ZeroMatrix(vBop);\n      \n      //Input Gate\n      mWip.Init(Wip.Rows(),Wip.Cols());\n      vWip.Init(Wip.Rows(),Wip.Cols());  \n      mWip = ZeroMatrix(mWip);\n      vWip = ZeroMatrix(vWip);\n      \n      mBip.Init(Bip.Rows(),Bip.Cols());\n      vBip.Init(Bip.Rows(),Bip.Cols());\n      mBip = ZeroMatrix(mBip);\n      vBip = ZeroMatrix(vBip);\n      \n      //Candidate Gate\n      mWgp.Init(Wgp.Rows(),Wgp.Cols());\n      vWgp.Init(Wgp.Rows(),Wgp.Cols());  \n      mWgp = ZeroMatrix(mWgp);\n      vWgp = ZeroMatrix(vWgp);\n      \n      mBgp.Init(Bgp.Rows(),Bgp.Cols());\n      vBgp.Init(Bgp.Rows(),Bgp.Cols());\n      mBgp = ZeroMatrix(mBgp);\n      vBgp = ZeroMatrix(vBgp);\n     } \n//From future to past\n//forget gate\nWff.Init(N_H,N_H + N_ins);\ndWff.Init(N_H,N_H + N_ins);\nWff = InitWeights(Wff)*xavier_;\n\nBff.Init(N_H,1);\ndBff.Init(N_H,1);\nBff = InitWeights(Bff)*xavier_;\n\nArrayResize(Zff,N_ts);\n     \n//input gate\nWif.Init(N_H,N_H + N_ins);\ndWif.Init(N_H,N_H + N_ins);\nWif = InitWeights(Wif)*xavier_;\n\nBif.Init(N_H,1);\ndBif.Init(N_H,1);\nBif = InitWeights(Bif)*xavier_;\n\nArrayResize(Zif,N_ts);\n//output gate\nWof.Init(N_H,N_H + N_ins);\ndWof.Init(N_H,N_H + N_ins);\nWof = InitWeights(Wof)*xavier_;\n\nBof.Init(N_H,1);\ndBof.Init(N_H,1);\nBof = InitWeights(Bof)*xavier_;\n\nArrayResize(Zof,N_ts);     \n// candidate gate\nWgf.Init(N_H,N_H + N_ins);\ndWgf.Init(N_H,N_H + N_ins);\nWgf = InitWeights(Wgf)*xavier_;\n\nBgf.Init(N_H,1);\ndBgf.Init(N_H,1);\nBgf = InitWeights(Bgf)*xavier_;\n\nArrayResize(Zgf,N_ts);\n//Output\nWyf.Init(N_outs,N_H);\ndWyf.Init(N_outs,N_H);\nWyf = InitWeights(Wyf)*xavier_;\n\n\nByf.Init(N_outs,1);\ndByf.Init(N_outs,1);\nByf = InitWeights(Byf)*xavier_;\n\nArrayResize(Zyf,N_ts);\n\n//Estado Oculto\nArrayResize(Hf,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(Cf,N_ts+1);\n\n//Entrada \nArrayResize(xf,N_ts);\nArrayResize(x_hf,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWyf.Init(Wyf.Rows(),Wyf.Cols());\n      vWyf.Init(Wyf.Rows(),Wyf.Cols());  \n      mWyf = ZeroMatrix(mWyf);\n      vWyf = ZeroMatrix(vWyf);\n      \n      mByf.Init(Byf.Rows(),Byf.Cols());\n      vByf.Init(Byf.Rows(),Byf.Cols());\n      mByf= ZeroMatrix(mByf);\n      vByf = ZeroMatrix(vByf);\n      \n      //Forget gate\n      mWff.Init(Wff.Rows(),Wff.Cols());\n      vWff.Init(Wff.Rows(),Wff.Cols());  \n      mWff = ZeroMatrix(mWff);\n      vWff = ZeroMatrix(vWff);\n      \n      mBff.Init(Bff.Rows(),Bff.Cols());\n      vBff.Init(Bff.Rows(),Bff.Cols());\n      mBff = ZeroMatrix(mBff);\n      vBff = ZeroMatrix(vBff);\n      \n      //Output Gate\n      mWof.Init(Wof.Rows(),Wof.Cols());\n      vWof.Init(Wof.Rows(),Wof.Cols());  \n      mWof = ZeroMatrix(mWof);\n      vWof = ZeroMatrix(vWof);\n      \n      mBof.Init(Bof.Rows(),Bof.Cols());\n      vBof.Init(Bof.Rows(),Bof.Cols());\n      mBof = ZeroMatrix(mBof);\n      vBof = ZeroMatrix(vBof);\n      \n      //Input Gate\n      mWif.Init(Wif.Rows(),Wif.Cols());\n      vWif.Init(Wif.Rows(),Wif.Cols());  \n      mWif = ZeroMatrix(mWif);\n      vWif = ZeroMatrix(vWif);\n      \n      mBif.Init(Bif.Rows(),Bif.Cols());\n      vBif.Init(Bif.Rows(),Bif.Cols());\n      mBif = ZeroMatrix(mBif);\n      vBif = ZeroMatrix(vBif);\n      \n      //Candidate Gate\n      mWgf.Init(Wgf.Rows(),Wgf.Cols());\n      vWgf.Init(Wgf.Rows(),Wgf.Cols());  \n      mWgf = ZeroMatrix(mWgf);\n      vWgf = ZeroMatrix(vWgf);\n      \n      mBgf.Init(Bgf.Rows(),Bgf.Cols());\n      vBgf.Init(Bgf.Rows(),Bgf.Cols());\n      mBgf = ZeroMatrix(mBgf);\n      vBgf = ZeroMatrix(vBgf);\n     } \n}\n\n\nmatrix BiLSTMLayer::Output(matrix &X)\n{\n//Zera o estado oculto anterior\n\nHp[0].Init(N_H,1);\nHp[0] = ZeroMatrix(Hp[0]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nCp[0].Init(N_H,1);\nCp[0] = ZeroMatrix(Cp[0]);\n\n     \n//Define a matrix de sa\u00edda \nmatrix Yp; \nYp.Init(N_outs,N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix yp;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {xp[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix Fp,Ip,Op,Gp; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {xp[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_hp[t] = Concatenate(Hp[t],xp[t]); \n\n\n   //Forget gate\n   Zfp[t] = Wfp.MatMul(x_hp[t])  + Bfp;\n   Fp = Sig(Zfp[t]);\n   //Imput gate\n   Zip[t] = Wip.MatMul(x_hp[t])  + Bip;\n   Ip = Sig(Zip[t]);\n   //Output gate\n   Zop[t] = Wop.MatMul(x_hp[t])  + Bop;\n   Op = Sig(Zop[t]);\n   //Candidate gate\n   Zgp[t] = Wgp.MatMul(x_hp[t])  + Bgp;\n   Gp = Tanh(Zgp[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   Cp[t+1] = Fp * Cp[t] + Ip * Gp;\n   //C\u00e1lculo do novo estado oculto\n   Hp[t+1] = Tanh(Cp[t+1]);\n   Hp[t+1]= Hp[t+1] * Op;\n   \n   //Sa\u00edda\n   yp = Wyp.MatMul(Hp[t+1]) + Byp;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<yp.Rows();i++)\n     {Yp[i][t] = yp[i][0];}\n    \n  }\n\n//Zera o estado oculto posterior\n\nHf[N_ts].Init(N_H,1);\nHf[N_ts] = ZeroMatrix(Hf[N_ts]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nCf[N_ts].Init(N_H,1);\nCf[N_ts] = ZeroMatrix(Cf[N_ts]);\n  \n//Define a matrix de sa\u00edda \nmatrix Yf; \nYf.Init(N_outs, N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix yf;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {xf[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix Ff,If,Of,Gf; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {xf[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_hf[t] = Concatenate(Hf[t+1],xf[t]); \n\n\n   //Forget gate\n   Zff[t] = Wff.MatMul(x_hf[t])  + Bff;\n   Ff = Sig(Zff[t]);\n   //Imput gate\n   Zif[t] = Wif.MatMul(x_hf[t])  + Bif;\n   If = Sig(Zif[t]);\n   //Output gate\n   Zof[t] = Wof.MatMul(x_hf[t])  + Bof;\n   Of = Sig(Zof[t]);\n   //Candidate gate\n   Zgf[t] = Wgf.MatMul(x_hf[t])  + Bgf;\n   Gf = Tanh(Zgf[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   Cf[t] = Ff * Cf[t+1] + If * Gf;\n   //C\u00e1lculo do novo estado oculto\n   Hf[t] = Tanh(Cf[t]);\n   Hf[t] = Hf[t] * Of;\n   \n   //Sa\u00edda\n   yf = Wyf.MatMul(Hf[t]) + Byf;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<yf.Rows();i++)\n     {Yf[i][t] = yf[i][0];}\n    \n  }\nmatrix Y;\nY = Yp + Yf;\n\nreturn Y;\n}\n\nmatrix BiLSTMLayer::GradDescent(matrix &Ey)\n{\n//Gradient \nmatrix Exp;\nExp.Init(N_ins,N_ts);\n \n//Forget Gate\ndWfp = ZeroMatrix(dWfp);\ndBfp = ZeroMatrix(dBfp);\n\n//Input Gate\ndWip = ZeroMatrix(dWip);\ndBip = ZeroMatrix(dBip);\n\n//Output Gate\ndWop = ZeroMatrix(dWop);\ndBop = ZeroMatrix(dBop);\n\n//Candidate Gate\ndWgp = ZeroMatrix(dWgp);\ndBgp = ZeroMatrix(dBgp);\n\n//Y gate\ndWyp = ZeroMatrix(dWyp);\ndByp = ZeroMatrix(dByp);\n//Erro por passo de tempo \nmatrix eyp;\neyp.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_hp, d_cp, d_fp, d_ip, d_op, d_gp, d_x_hp;\n\n//Estado oculto para t+1\nmatrix dh_nextp;\ndh_nextp.Init(N_H,1);\ndh_nextp = ZeroMatrix(dh_nextp);\n\nmatrix dc_nextp;\ndc_nextp.Init(N_H,1);\ndc_nextp = ZeroMatrix(dc_nextp);\n\nmatrix ex_p;\nex_p.Init(N_ins,1);\n\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {eyp[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWyp += eyp.MatMul(Hp[t+1].Transpose());\n   dByp += eyp;\n   \n   //Hidden State Error\n   d_hp = Wyp.Transpose();\n   d_hp = d_hp.MatMul(eyp) + dh_nextp;\n   \n   //Output gate\n   d_op = d_hp * Tanh(Cp[t+1]) * dSig(Zop[t]);\n   dWop += d_op.MatMul(x_hp[t].Transpose());\n   dBop += d_op;\n   \n   //Cell state error\n   d_cp = d_hp * dTanh(Cp[t+1]) * Sig(Zop[t]) + dc_nextp;\n   \n   //Forget gate\n   d_fp = d_cp * Cp[t] * dSig(Zfp[t]);\n   dWfp += d_fp.MatMul(x_hp[t].Transpose());\n   dBfp += d_fp;\n   \n   //Input gate\n   d_ip = d_cp * Tanh(Zgp[t]) * dSig(Zip[t]);\n   dWip += d_ip.MatMul(x_hp[t].Transpose());\n   dBip += d_ip;\n   \n   //Candidate gate\n   d_gp = d_cp * Sig(Zip[t]) * dTanh(Zgp[t]);\n   dWgp += d_gp.MatMul(x_hp[t].Transpose());\n   dBgp += d_gp;\n   \n   //Concatenated Input gradient\n   d_x_hp = Wfp.Transpose().MatMul(d_fp) + Wip.Transpose().MatMul(d_ip) + Wop.Transpose().MatMul(d_op) + Wgp.Transpose().MatMul(d_gp);\n   \n   //Error of Cell state of next time step\n   dc_nextp = Sig(Zfp[t]) * d_cp; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_hp.Rows();i++)\n     {if(i < N_H) dh_nextp[i][0] = d_x_hp[i][0];\n      if(i >= N_H) ex_p[i-N_H][0] = d_x_hp[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex_p.Rows();i++)\n     {Exp[i][t] = ex_p[i][0];}   \n  \n  }\n\n//Gradient \nmatrix Exf;\nExf.Init(N_ins,N_ts);\n \n//Forget Gate\ndWff = ZeroMatrix(dWff);\ndBff = ZeroMatrix(dBff);\n\n//Input Gate\ndWif = ZeroMatrix(dWif);\ndBif = ZeroMatrix(dBif);\n\n//Output Gate\ndWof = ZeroMatrix(dWof);\ndBof = ZeroMatrix(dBof);\n\n//Candidate Gate\ndWgf = ZeroMatrix(dWgf);\ndBgf = ZeroMatrix(dBgf);\n\n//Y gate\ndWyf = ZeroMatrix(dWyf);\ndByf = ZeroMatrix(dByf);\n//Erro por passo de tempo \nmatrix eyf;\neyf.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_hf, d_cf, d_ff, d_if, d_of, d_gf,d_x_hf;\n\n//Estado oculto para t+1\nmatrix dh_nextf;\ndh_nextf.Init(N_H,1);\ndh_nextf = ZeroMatrix(dh_nextf);\n\nmatrix dc_nextf;\ndc_nextf.Init(N_H,1);\ndc_nextf = ZeroMatrix(dc_nextf);\n\nmatrix ex_f;\nex_f.Init(N_ins,1);\n\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {eyf[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWyf += eyf.MatMul(Hf[t].Transpose());\n   dByf += eyf;\n   \n   //Hidden State Error\n   d_hf = Wyf.Transpose();\n   d_hf = d_hf.MatMul(eyf) + dh_nextf;\n   \n   //Output gate\n   d_of = d_hf * Tanh(Cf[t]) * dSig(Zof[t]);\n   dWof += d_of.MatMul(x_hf[t].Transpose());\n   dBof += d_of;\n   \n   //Cell state error\n   d_cf = d_hf * dTanh(Cf[t]) * Sig(Zof[t]) + dc_nextf;\n   \n   //Forget gate\n   d_ff = d_cf * Cf[t+1] * dSig(Zff[t]);\n   dWff += d_ff.MatMul(x_hf[t].Transpose());\n   dBff += d_ff;\n   \n   //Input gate\n   d_if = d_cf * Tanh(Zgf[t]) * dSig(Zif[t]);\n   dWif += d_if.MatMul(x_hf[t].Transpose());\n   dBif += d_if;\n   \n   //Candidate gate\n   d_gf = d_cf * Sig(Zif[t]) * dTanh(Zgf[t]);\n   dWgf += d_gf.MatMul(x_hf[t].Transpose());\n   dBgf += d_gf;\n   \n   //Concatenated Input gradient\n   d_x_hf = Wff.Transpose().MatMul(d_ff) + Wif.Transpose().MatMul(d_if) + Wof.Transpose().MatMul(d_of) + Wgf.Transpose().MatMul(d_gf);\n   \n   //Error of Cell state of next time step\n   dc_nextf = Sig(Zff[t]) * d_cf; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_hf.Rows();i++)\n     {if(i < N_H) dh_nextf[i][0] = d_x_hf[i][0];\n      if(i >= N_H) ex_f[i-N_H][0] = d_x_hf[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex_f.Rows();i++)\n     {Exf[i][t] = ex_f[i][0];}   \n  \n  }\nmatrix Ex;\n\nEx = Exp + Exf; \nreturn Ex;\n}\n\nvoid   BiLSTMLayer::Update(void)\n{\nif(OP == STD)\n  {\n   //Past \n   Wfp = Wfp - dWfp*N;\n   Wip = Wip - dWip*N;\n   Wop = Wop - dWop*N;\n   Wgp = Wgp - dWgp*N;\n   Wyp = Wyp - dWyp*N;\n   \n   Bfp = Bfp - dBfp*N;\n   Bip = Bip - dBip*N;\n   Bop = Bop - dBop*N;\n   Bgp = Bgp - dBgp*N;\n   Byp = Byp - dByp*N;\n   \n   //Future\n   Wff = Wff - dWff*N;\n   Wif = Wif - dWif*N;\n   Wof = Wof - dWof*N;\n   Wgf = Wgf - dWgf*N;\n   Wyf = Wyf - dWyf*N;\n   \n   Bff = Bff - dBff*N;\n   Bif = Bif - dBif*N;\n   Bof = Bof - dBof*N;\n   Bgf = Bgf - dBgf*N;\n   Byf = Byf - dByf*N;\n  }\nif(OP == ADAM)\n  {\n      it +=1;\n      //sa\u00edda\n      mWyp = AdamM(mWyp,dWyp,beta1);\n      vWyp = AdamV(vWyp,dWyp,beta2);\n      Wyp = Wyp - Adam(it,mWyp,vWyp,beta1,beta2,alpha);\n      \n      mByp = AdamM(mByp,dByp,beta1);\n      vByp = AdamV(vByp,dByp,beta2);\n      Byp = Byp -Adam(it,mByp,vByp,beta1,beta2,alpha);\n      \n      //Forget\n      mWfp = AdamM(mWfp,dWfp,beta1);\n      vWfp = AdamV(vWfp,dWfp,beta2);\n      Wfp = Wfp - Adam(it,mWfp,vWfp,beta1,beta2,alpha);\n      \n      mBfp = AdamM(mBfp,dBfp,beta1);\n      vBfp = AdamV(vBfp,dBfp,beta2);\n      Bfp = Bfp -Adam(it,mBfp,vBfp,beta1,beta2,alpha);\n      \n      //Output\n      mWop = AdamM(mWop,dWop,beta1);\n      vWop = AdamV(vWop,dWop,beta2);\n      Wop = Wop - Adam(it,mWop,vWop,beta1,beta2,alpha);\n      \n      mBop = AdamM(mBop,dBop,beta1);\n      vBop = AdamV(vBop,dBop,beta2);\n      Bop = Bop -Adam(it,mBop,vBop,beta1,beta2,alpha);\n      \n      //Input\n      mWip = AdamM(mWip,dWip,beta1);\n      vWip = AdamV(vWip,dWip,beta2);\n      Wip = Wip- Adam(it,mWip,vWip,beta1,beta2,alpha);\n      \n      mBip = AdamM(mBip,dBip,beta1);\n      vBip = AdamV(vBip,dBip,beta2);\n      Bip = Bip -Adam(it,mBip,vBip,beta1,beta2,alpha);\n      \n      //Candidate\n      mWgp = AdamM(mWgp,dWgp,beta1);\n      vWgp = AdamV(vWgp,dWgp,beta2);\n      Wgp = Wgp - Adam(it,mWgp,vWgp,beta1,beta2,alpha);\n      \n      mBgp = AdamM(mBgp,dBgp,beta1);\n      vBgp = AdamV(vBgp,dBgp,beta2);\n      Bgp = Bgp -Adam(it,mBgp,vBgp,beta1,beta2,alpha);\n\n      //sa\u00edda\n      mWyf = AdamM(mWyf,dWyf,beta1);\n      vWyf = AdamV(vWyf,dWyf,beta2);\n      Wyf = Wyf - Adam(it,mWyf,vWyf,beta1,beta2,alpha);\n      \n      mByf = AdamM(mByf,dByf,beta1);\n      vByf = AdamV(vByf,dByf,beta2);\n      Byf = Byf -Adam(it,mByf,vByf,beta1,beta2,alpha);\n      \n      //Forget\n      mWff = AdamM(mWff,dWff,beta1);\n      vWff = AdamV(vWff,dWff,beta2);\n      Wff = Wff - Adam(it,mWff,vWff,beta1,beta2,alpha);\n      \n      mBff = AdamM(mBff,dBff,beta1);\n      vBff = AdamV(vBff,dBff,beta2);\n      Bff = Bff -Adam(it,mBff,vBff,beta1,beta2,alpha);\n      \n      //Output\n      mWof = AdamM(mWof,dWof,beta1);\n      vWof = AdamV(vWof,dWof,beta2);\n      Wof = Wof - Adam(it,mWof,vWof,beta1,beta2,alpha);\n      \n      mBof = AdamM(mBof,dBof,beta1);\n      vBof = AdamV(vBof,dBof,beta2);\n      Bof = Bof -Adam(it,mBof,vBof,beta1,beta2,alpha);\n      \n      //Input\n      mWif = AdamM(mWif,dWif,beta1);\n      vWif = AdamV(vWif,dWif,beta2);\n      Wif = Wif- Adam(it,mWif,vWif,beta1,beta2,alpha);\n      \n      mBif = AdamM(mBif,dBif,beta1);\n      vBif = AdamV(vBif,dBif,beta2);\n      Bif = Bif -Adam(it,mBif,vBif,beta1,beta2,alpha);\n      \n      //Candidate\n      mWgf = AdamM(mWgf,dWgf,beta1);\n      vWgf = AdamV(vWgf,dWgf,beta2);\n      Wgf = Wgf - Adam(it,mWgf,vWgf,beta1,beta2,alpha);\n      \n      mBgf = AdamM(mBgf,dBgf,beta1);\n      vBgf = AdamV(vBgf,dBgf,beta2);\n      Bgf = Bgf -Adam(it,mBgf,vBgf,beta1,beta2,alpha);\n  }\n}\n\nvoid   BiLSTMLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfpLayer\" + IntegerToString(k);\n   SaveMatrix(Wfp,csv_name);\n   csv_name = IAname + \"\\WipLayer\" + IntegerToString(k);\n   SaveMatrix(Wip,csv_name);\n   csv_name = IAname + \"\\WopLayer\" + IntegerToString(k);\n   SaveMatrix(Wop,csv_name);\n   csv_name = IAname + \"\\WgpLayer\" + IntegerToString(k);\n   SaveMatrix(Wgp,csv_name);\n   csv_name = IAname + \"\\WypLayer\" + IntegerToString(k);\n   SaveMatrix(Wyp,csv_name);\n   \n   csv_name = IAname + \"\\BfpLayer\" + IntegerToString(k);\n   SaveMatrix(Bfp,csv_name);\n   csv_name = IAname + \"\\BipLayer\" + IntegerToString(k);\n   SaveMatrix(Bip,csv_name);\n   csv_name = IAname + \"\\BopLayer\" + IntegerToString(k);\n   SaveMatrix(Bop,csv_name);\n   csv_name = IAname + \"\\BgpLayer\" + IntegerToString(k);\n   SaveMatrix(Bgp,csv_name);\n   csv_name = IAname + \"\\BypLayer\" + IntegerToString(k);\n   SaveMatrix(Byp,csv_name);\n   \n   csv_name = IAname + \"\\WffLayer\" + IntegerToString(k);\n   SaveMatrix(Wff,csv_name);\n   csv_name = IAname + \"\\WifLayer\" + IntegerToString(k);\n   SaveMatrix(Wif,csv_name);\n   csv_name = IAname + \"\\WofLayer\" + IntegerToString(k);\n   SaveMatrix(Wof,csv_name);\n   csv_name = IAname + \"\\WgfLayer\" + IntegerToString(k);\n   SaveMatrix(Wgf,csv_name);\n   csv_name = IAname + \"\\WyfLayer\" + IntegerToString(k);\n   SaveMatrix(Wyf,csv_name);\n   \n   csv_name = IAname + \"\\BffLayer\" + IntegerToString(k);\n   SaveMatrix(Bff,csv_name);\n   csv_name = IAname + \"\\BifLayer\" + IntegerToString(k);\n   SaveMatrix(Bif,csv_name);\n   csv_name = IAname + \"\\BofLayer\" + IntegerToString(k);\n   SaveMatrix(Bof,csv_name);\n   csv_name = IAname + \"\\BgfLayer\" + IntegerToString(k);\n   SaveMatrix(Bgf,csv_name);\n   csv_name = IAname + \"\\ByfLayer\" + IntegerToString(k);\n   SaveMatrix(Byf,csv_name);\n}\nvoid   BiLSTMLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfpLayer\" + IntegerToString(k);\n   Wfp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WipLayer\" + IntegerToString(k);\n   Wip = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WopLayer\" + IntegerToString(k);\n   Wop = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgpLayer\" + IntegerToString(k);\n   Wgp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WypLayer\" + IntegerToString(k);\n   Wyp = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BfpLayer\" + IntegerToString(k);\n   Bfp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BipLayer\" + IntegerToString(k);\n   Bip = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BopLayer\" + IntegerToString(k);\n   Bop = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgpLayer\" + IntegerToString(k);\n   Bgp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BypLayer\" + IntegerToString(k);\n   Byp = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\WffLayer\" + IntegerToString(k);\n   Wff = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WifLayer\" + IntegerToString(k);\n   Wif = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WofLayer\" + IntegerToString(k);\n   Wof = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgfLayer\" + IntegerToString(k);\n   Wgf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WyfLayer\" + IntegerToString(k);\n   Wyf = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BffLayer\" + IntegerToString(k);\n   Bff = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BifLayer\" + IntegerToString(k);\n   Bif = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BofLayer\" + IntegerToString(k);\n   Bof = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgfLayer\" + IntegerToString(k);\n   Bgf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\ByfLayer\" + IntegerToString(k);\n   Byf = LoadMatrix(csv_name);\n\n}\nvoid   BiLSTMLayer::SetAdam(double B1, double B2, double Alph)\n{\n\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}\n", "search_content": "//+------------------------------------------------------------------+\n//|   BiLSTM Layer                                                   |\n//+------------------------------------------------------------------+\n\nclass BiLSTMLayer : public DeepLearning\n  {\npublic:\n   //Initializes layer weights and bias\n   void InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the error\n   virtual void   Update(void);\n   //Save weights, k is the layer index;\n   virtual void   SaveWeights(int k,string IAname);\n   //load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   \n   //ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\n   \n   \nprivate:\n   //Learning Rate\n   double N;\n   //Optimizatiom\n   Optim OP;\n   //Number of time steps\n   ulong N_ts;\n   //Dimension of Hidden State\n   ulong N_H;\n   //Number of entries\n   ulong N_ins;\n   //Number of outputs\n   ulong N_outs;\n   \n   //From Past to Future:\n   //Forget gate\n   matrix Wfp,Bfp,Zfp[],\n          dWfp,dBfp;\n   //Input gate\n   matrix Wip,Bip,Zip[],\n          dWip,dBip;\n   //Output gate\n   matrix Wop,Bop,Zop[],\n          dWop,dBop;\n   //Candidate gate\n   matrix Wgp,Bgp,Zgp[],\n          dWgp,dBgp;\n   //sa\u00edda\n   matrix Wyp,Byp,Zyp[],\n          dWyp,dByp;\n   //Estado Oculto\n   matrix Hp[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cp[];\n   //Entrada\n   matrix xp[],x_hp[];\n  \n  \n   //From Future to Past\n   //Forget gate\n   matrix Wff,Bff,Zff[],\n          dWff,dBff;\n   //Input gate\n   matrix Wif,Bif,Zif[],\n          dWif,dBif;\n   //Output gate\n   matrix Wof,Bof,Zof[],\n          dWof,dBof;\n   //Candidate gate\n   matrix Wgf,Bgf,Zgf[],\n          dWgf,dBgf;\n   //sa\u00edda\n   matrix Wyf,Byf,Zyf[],\n          dWyf,dByf;\n   //Estado Oculto\n   matrix Hf[];\n   //Mem\u00f3ria de Longo Prazo\n   matrix Cf[];\n   //Entrada\n   matrix xf[],x_hf[];\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mWyp, mWfp, mWop, mWip, mWgp;\n   matrix mByp, mBfp, mBop, mBip, mBgp;\n   //v\n   matrix vWyp, vWfp, vWop, vWip, vWgp;\n   matrix vByp, vBfp, vBop, vBip, vBgp;\n   \n   matrix mWyf, mWff, mWof, mWif, mWgf;\n   matrix mByf, mBff, mBof, mBif, mBgf;\n   //v\n   matrix vWyf, vWff, vWof, vWif, vWgf;\n   matrix vByf, vBff, vBof, vBif, vBgf;\n   \n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n  \n  \n  };\n\n//+------------------------------------------------------------------+\n//|   BiLSTM                                                         |\n//+------------------------------------------------------------------+\nvoid BiLSTMLayer::InitLayer(int N_steps, int N_entries,int N_hidden, int N_outputs, double LR, Optim Op = STD)\n{\n//Hiperparameters \nN = LR;\nOP = Op;\nN_ts = N_steps;\nN_ins = N_entries;\nN_outs = N_outputs;\nN_H = N_hidden;\n\n//par\u00e2metro de Xavier para inicializa\u00e7\u00e3o. \ndouble xavier_;\nxavier_ = N_ins + N_outs;\nxavier_ = MathSqrt(6/xavier_);\n\n//From Past to Future\n//=============================\n\n//forget gate\nWfp.Init(N_H,N_H + N_ins);\ndWfp.Init(N_H,N_H + N_ins);\nWfp = InitWeights(Wfp)*xavier_;\n\nBfp.Init(N_H,1);\ndBfp.Init(N_H,1);\nBfp = InitWeights(Bfp)*xavier_;\n\nArrayResize(Zfp,N_ts);\n     \n//input gate\nWip.Init(N_H,N_H + N_ins);\ndWip.Init(N_H,N_H + N_ins);\nWip = InitWeights(Wip)*xavier_;\n\nBip.Init(N_H,1);\ndBip.Init(N_H,1);\nBip = InitWeights(Bip)*xavier_;\n\nArrayResize(Zip,N_ts);\n\n//output gate\nWop.Init(N_H,N_H + N_ins);\ndWop.Init(N_H,N_H + N_ins);\nWop = InitWeights(Wop)*xavier_;\n\nBop.Init(N_H,1);\ndBop.Init(N_H,1);\nBop = InitWeights(Bop)*xavier_;\n\nArrayResize(Zop,N_ts);\n     \n// candidate gate\nWgp.Init(N_H,N_H + N_ins);\ndWgp.Init(N_H,N_H + N_ins);\nWgp = InitWeights(Wgp)*xavier_;\n\nBgp.Init(N_H,1);\ndBgp.Init(N_H,1);\nBgp = InitWeights(Bgp)*xavier_;\n\nArrayResize(Zgp,N_ts);\n\n//Output\nWyp.Init(N_outs,N_H);\ndWyp.Init(N_outs,N_H);\nWyp = InitWeights(Wyp)*xavier_;\n\n\nByp.Init(N_outs,1);\ndByp.Init(N_outs,1);\nByp = InitWeights(Byp)*xavier_;\n\nArrayResize(Zyp,N_ts);\n\n//Estado Oculto\nArrayResize(Hp,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(Cp,N_ts+1);\n\n//Entrada \nArrayResize(xp,N_ts);\nArrayResize(x_hp,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWyp.Init(Wyp.Rows(),Wyp.Cols());\n      vWyp.Init(Wyp.Rows(),Wyp.Cols());  \n      mWyp = ZeroMatrix(mWyp);\n      vWyp = ZeroMatrix(vWyp);\n      \n      mByp.Init(Byp.Rows(),Byp.Cols());\n      vByp.Init(Byp.Rows(),Byp.Cols());\n      mByp= ZeroMatrix(mByp);\n      vByp = ZeroMatrix(vByp);\n      \n      //Forget gate\n      mWfp.Init(Wfp.Rows(),Wfp.Cols());\n      vWfp.Init(Wfp.Rows(),Wfp.Cols());  \n      mWfp = ZeroMatrix(mWfp);\n      vWfp = ZeroMatrix(vWfp);\n      \n      mBfp.Init(Bfp.Rows(),Bfp.Cols());\n      vBfp.Init(Bfp.Rows(),Bfp.Cols());\n      mBfp = ZeroMatrix(mBfp);\n      vBfp = ZeroMatrix(vBfp);\n      \n      //Output Gate\n      mWop.Init(Wop.Rows(),Wop.Cols());\n      vWop.Init(Wop.Rows(),Wop.Cols());  \n      mWop = ZeroMatrix(mWop);\n      vWop = ZeroMatrix(vWop);\n      \n      mBop.Init(Bop.Rows(),Bop.Cols());\n      vBop.Init(Bop.Rows(),Bop.Cols());\n      mBop = ZeroMatrix(mBop);\n      vBop = ZeroMatrix(vBop);\n      \n      //Input Gate\n      mWip.Init(Wip.Rows(),Wip.Cols());\n      vWip.Init(Wip.Rows(),Wip.Cols());  \n      mWip = ZeroMatrix(mWip);\n      vWip = ZeroMatrix(vWip);\n      \n      mBip.Init(Bip.Rows(),Bip.Cols());\n      vBip.Init(Bip.Rows(),Bip.Cols());\n      mBip = ZeroMatrix(mBip);\n      vBip = ZeroMatrix(vBip);\n      \n      //Candidate Gate\n      mWgp.Init(Wgp.Rows(),Wgp.Cols());\n      vWgp.Init(Wgp.Rows(),Wgp.Cols());  \n      mWgp = ZeroMatrix(mWgp);\n      vWgp = ZeroMatrix(vWgp);\n      \n      mBgp.Init(Bgp.Rows(),Bgp.Cols());\n      vBgp.Init(Bgp.Rows(),Bgp.Cols());\n      mBgp = ZeroMatrix(mBgp);\n      vBgp = ZeroMatrix(vBgp);\n     } \n//From future to past\n//forget gate\nWff.Init(N_H,N_H + N_ins);\ndWff.Init(N_H,N_H + N_ins);\nWff = InitWeights(Wff)*xavier_;\n\nBff.Init(N_H,1);\ndBff.Init(N_H,1);\nBff = InitWeights(Bff)*xavier_;\n\nArrayResize(Zff,N_ts);\n     \n//input gate\nWif.Init(N_H,N_H + N_ins);\ndWif.Init(N_H,N_H + N_ins);\nWif = InitWeights(Wif)*xavier_;\n\nBif.Init(N_H,1);\ndBif.Init(N_H,1);\nBif = InitWeights(Bif)*xavier_;\n\nArrayResize(Zif,N_ts);\n//output gate\nWof.Init(N_H,N_H + N_ins);\ndWof.Init(N_H,N_H + N_ins);\nWof = InitWeights(Wof)*xavier_;\n\nBof.Init(N_H,1);\ndBof.Init(N_H,1);\nBof = InitWeights(Bof)*xavier_;\n\nArrayResize(Zof,N_ts);     \n// candidate gate\nWgf.Init(N_H,N_H + N_ins);\ndWgf.Init(N_H,N_H + N_ins);\nWgf = InitWeights(Wgf)*xavier_;\n\nBgf.Init(N_H,1);\ndBgf.Init(N_H,1);\nBgf = InitWeights(Bgf)*xavier_;\n\nArrayResize(Zgf,N_ts);\n//Output\nWyf.Init(N_outs,N_H);\ndWyf.Init(N_outs,N_H);\nWyf = InitWeights(Wyf)*xavier_;\n\n\nByf.Init(N_outs,1);\ndByf.Init(N_outs,1);\nByf = InitWeights(Byf)*xavier_;\n\nArrayResize(Zyf,N_ts);\n\n//Estado Oculto\nArrayResize(Hf,N_ts+1);\n\n//Mem\u00f3ria de longo prazo\nArrayResize(Cf,N_ts+1);\n\n//Entrada \nArrayResize(xf,N_ts);\nArrayResize(x_hf,N_ts);\n\n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      //Sa\u00edda\n      mWyf.Init(Wyf.Rows(),Wyf.Cols());\n      vWyf.Init(Wyf.Rows(),Wyf.Cols());  \n      mWyf = ZeroMatrix(mWyf);\n      vWyf = ZeroMatrix(vWyf);\n      \n      mByf.Init(Byf.Rows(),Byf.Cols());\n      vByf.Init(Byf.Rows(),Byf.Cols());\n      mByf= ZeroMatrix(mByf);\n      vByf = ZeroMatrix(vByf);\n      \n      //Forget gate\n      mWff.Init(Wff.Rows(),Wff.Cols());\n      vWff.Init(Wff.Rows(),Wff.Cols());  \n      mWff = ZeroMatrix(mWff);\n      vWff = ZeroMatrix(vWff);\n      \n      mBff.Init(Bff.Rows(),Bff.Cols());\n      vBff.Init(Bff.Rows(),Bff.Cols());\n      mBff = ZeroMatrix(mBff);\n      vBff = ZeroMatrix(vBff);\n      \n      //Output Gate\n      mWof.Init(Wof.Rows(),Wof.Cols());\n      vWof.Init(Wof.Rows(),Wof.Cols());  \n      mWof = ZeroMatrix(mWof);\n      vWof = ZeroMatrix(vWof);\n      \n      mBof.Init(Bof.Rows(),Bof.Cols());\n      vBof.Init(Bof.Rows(),Bof.Cols());\n      mBof = ZeroMatrix(mBof);\n      vBof = ZeroMatrix(vBof);\n      \n      //Input Gate\n      mWif.Init(Wif.Rows(),Wif.Cols());\n      vWif.Init(Wif.Rows(),Wif.Cols());  \n      mWif = ZeroMatrix(mWif);\n      vWif = ZeroMatrix(vWif);\n      \n      mBif.Init(Bif.Rows(),Bif.Cols());\n      vBif.Init(Bif.Rows(),Bif.Cols());\n      mBif = ZeroMatrix(mBif);\n      vBif = ZeroMatrix(vBif);\n      \n      //Candidate Gate\n      mWgf.Init(Wgf.Rows(),Wgf.Cols());\n      vWgf.Init(Wgf.Rows(),Wgf.Cols());  \n      mWgf = ZeroMatrix(mWgf);\n      vWgf = ZeroMatrix(vWgf);\n      \n      mBgf.Init(Bgf.Rows(),Bgf.Cols());\n      vBgf.Init(Bgf.Rows(),Bgf.Cols());\n      mBgf = ZeroMatrix(mBgf);\n      vBgf = ZeroMatrix(vBgf);\n     } \n}\n\n\nmatrix BiLSTMLayer::Output(matrix &X)\n{\n//Zera o estado oculto anterior\n\nHp[0].Init(N_H,1);\nHp[0] = ZeroMatrix(Hp[0]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nCp[0].Init(N_H,1);\nCp[0] = ZeroMatrix(Cp[0]);\n\n     \n//Define a matrix de sa\u00edda \nmatrix Yp; \nYp.Init(N_outs,N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix yp;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {xp[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix Fp,Ip,Op,Gp; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {xp[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_hp[t] = Concatenate(Hp[t],xp[t]); \n\n\n   //Forget gate\n   Zfp[t] = Wfp.MatMul(x_hp[t])  + Bfp;\n   Fp = Sig(Zfp[t]);\n   //Imput gate\n   Zip[t] = Wip.MatMul(x_hp[t])  + Bip;\n   Ip = Sig(Zip[t]);\n   //Output gate\n   Zop[t] = Wop.MatMul(x_hp[t])  + Bop;\n   Op = Sig(Zop[t]);\n   //Candidate gate\n   Zgp[t] = Wgp.MatMul(x_hp[t])  + Bgp;\n   Gp = Tanh(Zgp[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   Cp[t+1] = Fp * Cp[t] + Ip * Gp;\n   //C\u00e1lculo do novo estado oculto\n   Hp[t+1] = Tanh(Cp[t+1]);\n   Hp[t+1]= Hp[t+1] * Op;\n   \n   //Sa\u00edda\n   yp = Wyp.MatMul(Hp[t+1]) + Byp;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<yp.Rows();i++)\n     {Yp[i][t] = yp[i][0];}\n    \n  }\n\n//Zera o estado oculto posterior\n\nHf[N_ts].Init(N_H,1);\nHf[N_ts] = ZeroMatrix(Hf[N_ts]);\n\n//Zera a mem\u00f3ria de longo prazo passada\n\nCf[N_ts].Init(N_H,1);\nCf[N_ts] = ZeroMatrix(Cf[N_ts]);\n  \n//Define a matrix de sa\u00edda \nmatrix Yf; \nYf.Init(N_outs, N_ts);\n\n//Define a sa\u00edda para cada passo de tempo\nmatrix yf;\n\n//Define a entrada para cada passo de tempo\nfor(int i=0;i<N_ts;i++)\n  {xf[i].Init(X.Rows(),1);}\n\n\n//define forget, imput, output, e canditade gate\nmatrix Ff,If,Of,Gf; \n//==============================\n//---Propaga\u00e7\u00e3o atrav\u00e9s do tempo\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<X.Rows();i++)\n     {xf[t][i][0] = X[i][t];}\n     \n   //Concatena\u00e7\u00e3o\n   x_hf[t] = Concatenate(Hf[t+1],xf[t]); \n\n\n   //Forget gate\n   Zff[t] = Wff.MatMul(x_hf[t])  + Bff;\n   Ff = Sig(Zff[t]);\n   //Imput gate\n   Zif[t] = Wif.MatMul(x_hf[t])  + Bif;\n   If = Sig(Zif[t]);\n   //Output gate\n   Zof[t] = Wof.MatMul(x_hf[t])  + Bof;\n   Of = Sig(Zof[t]);\n   //Candidate gate\n   Zgf[t] = Wgf.MatMul(x_hf[t])  + Bgf;\n   Gf = Tanh(Zgf[t]);\n   //C\u00e1lculo da nova mem\u00f3ria de longo prazo\n   Cf[t] = Ff * Cf[t+1] + If * Gf;\n   //C\u00e1lculo do novo estado oculto\n   Hf[t] = Tanh(Cf[t]);\n   Hf[t] = Hf[t] * Of;\n   \n   //Sa\u00edda\n   yf = Wyf.MatMul(Hf[t]) + Byf;\n   \n   //Prepara\u00e7\u00e3o da sa\u00edda\n   for(int i=0;i<yf.Rows();i++)\n     {Yf[i][t] = yf[i][0];}\n    \n  }\nmatrix Y;\nY = Yp + Yf;\n\nreturn Y;\n}\n\nmatrix BiLSTMLayer::GradDescent(matrix &Ey)\n{\n//Gradient \nmatrix Exp;\nExp.Init(N_ins,N_ts);\n \n//Forget Gate\ndWfp = ZeroMatrix(dWfp);\ndBfp = ZeroMatrix(dBfp);\n\n//Input Gate\ndWip = ZeroMatrix(dWip);\ndBip = ZeroMatrix(dBip);\n\n//Output Gate\ndWop = ZeroMatrix(dWop);\ndBop = ZeroMatrix(dBop);\n\n//Candidate Gate\ndWgp = ZeroMatrix(dWgp);\ndBgp = ZeroMatrix(dBgp);\n\n//Y gate\ndWyp = ZeroMatrix(dWyp);\ndByp = ZeroMatrix(dByp);\n//Erro por passo de tempo \nmatrix eyp;\neyp.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_hp, d_cp, d_fp, d_ip, d_op, d_gp, d_x_hp;\n\n//Estado oculto para t+1\nmatrix dh_nextp;\ndh_nextp.Init(N_H,1);\ndh_nextp = ZeroMatrix(dh_nextp);\n\nmatrix dc_nextp;\ndc_nextp.Init(N_H,1);\ndc_nextp = ZeroMatrix(dc_nextp);\n\nmatrix ex_p;\nex_p.Init(N_ins,1);\n\nfor(int t=(N_ts-1);t>=0;t--)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {eyp[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWyp += eyp.MatMul(Hp[t+1].Transpose());\n   dByp += eyp;\n   \n   //Hidden State Error\n   d_hp = Wyp.Transpose();\n   d_hp = d_hp.MatMul(eyp) + dh_nextp;\n   \n   //Output gate\n   d_op = d_hp * Tanh(Cp[t+1]) * dSig(Zop[t]);\n   dWop += d_op.MatMul(x_hp[t].Transpose());\n   dBop += d_op;\n   \n   //Cell state error\n   d_cp = d_hp * dTanh(Cp[t+1]) * Sig(Zop[t]) + dc_nextp;\n   \n   //Forget gate\n   d_fp = d_cp * Cp[t] * dSig(Zfp[t]);\n   dWfp += d_fp.MatMul(x_hp[t].Transpose());\n   dBfp += d_fp;\n   \n   //Input gate\n   d_ip = d_cp * Tanh(Zgp[t]) * dSig(Zip[t]);\n   dWip += d_ip.MatMul(x_hp[t].Transpose());\n   dBip += d_ip;\n   \n   //Candidate gate\n   d_gp = d_cp * Sig(Zip[t]) * dTanh(Zgp[t]);\n   dWgp += d_gp.MatMul(x_hp[t].Transpose());\n   dBgp += d_gp;\n   \n   //Concatenated Input gradient\n   d_x_hp = Wfp.Transpose().MatMul(d_fp) + Wip.Transpose().MatMul(d_ip) + Wop.Transpose().MatMul(d_op) + Wgp.Transpose().MatMul(d_gp);\n   \n   //Error of Cell state of next time step\n   dc_nextp = Sig(Zfp[t]) * d_cp; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_hp.Rows();i++)\n     {if(i < N_H) dh_nextp[i][0] = d_x_hp[i][0];\n      if(i >= N_H) ex_p[i-N_H][0] = d_x_hp[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex_p.Rows();i++)\n     {Exp[i][t] = ex_p[i][0];}   \n  \n  }\n\n//Gradient \nmatrix Exf;\nExf.Init(N_ins,N_ts);\n \n//Forget Gate\ndWff = ZeroMatrix(dWff);\ndBff = ZeroMatrix(dBff);\n\n//Input Gate\ndWif = ZeroMatrix(dWif);\ndBif = ZeroMatrix(dBif);\n\n//Output Gate\ndWof = ZeroMatrix(dWof);\ndBof = ZeroMatrix(dBof);\n\n//Candidate Gate\ndWgf = ZeroMatrix(dWgf);\ndBgf = ZeroMatrix(dBgf);\n\n//Y gate\ndWyf = ZeroMatrix(dWyf);\ndByf = ZeroMatrix(dByf);\n//Erro por passo de tempo \nmatrix eyf;\neyf.Init(Ey.Rows(),1);\n\n//Vari\u00e1veis auxiliares\nmatrix d_hf, d_cf, d_ff, d_if, d_of, d_gf,d_x_hf;\n\n//Estado oculto para t+1\nmatrix dh_nextf;\ndh_nextf.Init(N_H,1);\ndh_nextf = ZeroMatrix(dh_nextf);\n\nmatrix dc_nextf;\ndc_nextf.Init(N_H,1);\ndc_nextf = ZeroMatrix(dc_nextf);\n\nmatrix ex_f;\nex_f.Init(N_ins,1);\n\nfor(int t=0;t<N_ts;t++)\n  {\n   //Prepara\u00e7\u00e3o da entrada\n   for(int i=0;i<Ey.Rows();i++)\n     {eyf[i][0] = Ey[i][t];}\n   \n   //Sa\u00edda\n   dWyf += eyf.MatMul(Hf[t].Transpose());\n   dByf += eyf;\n   \n   //Hidden State Error\n   d_hf = Wyf.Transpose();\n   d_hf = d_hf.MatMul(eyf) + dh_nextf;\n   \n   //Output gate\n   d_of = d_hf * Tanh(Cf[t]) * dSig(Zof[t]);\n   dWof += d_of.MatMul(x_hf[t].Transpose());\n   dBof += d_of;\n   \n   //Cell state error\n   d_cf = d_hf * dTanh(Cf[t]) * Sig(Zof[t]) + dc_nextf;\n   \n   //Forget gate\n   d_ff = d_cf * Cf[t+1] * dSig(Zff[t]);\n   dWff += d_ff.MatMul(x_hf[t].Transpose());\n   dBff += d_ff;\n   \n   //Input gate\n   d_if = d_cf * Tanh(Zgf[t]) * dSig(Zif[t]);\n   dWif += d_if.MatMul(x_hf[t].Transpose());\n   dBif += d_if;\n   \n   //Candidate gate\n   d_gf = d_cf * Sig(Zif[t]) * dTanh(Zgf[t]);\n   dWgf += d_gf.MatMul(x_hf[t].Transpose());\n   dBgf += d_gf;\n   \n   //Concatenated Input gradient\n   d_x_hf = Wff.Transpose().MatMul(d_ff) + Wif.Transpose().MatMul(d_if) + Wof.Transpose().MatMul(d_of) + Wgf.Transpose().MatMul(d_gf);\n   \n   //Error of Cell state of next time step\n   dc_nextf = Sig(Zff[t]) * d_cf; \n   \n   //Error of Hidden State and Entry\n   for(int i=0;i<d_x_hf.Rows();i++)\n     {if(i < N_H) dh_nextf[i][0] = d_x_hf[i][0];\n      if(i >= N_H) ex_f[i-N_H][0] = d_x_hf[i][0];}\n   \n   //Escrever na matrix o erro da entrada\n   for(int i=0;i<ex_f.Rows();i++)\n     {Exf[i][t] = ex_f[i][0];}   \n  \n  }\nmatrix Ex;\n\nEx = Exp + Exf; \nreturn Ex;\n}\n\nvoid   BiLSTMLayer::Update(void)\n{\nif(OP == STD)\n  {\n   //Past \n   Wfp = Wfp - dWfp*N;\n   Wip = Wip - dWip*N;\n   Wop = Wop - dWop*N;\n   Wgp = Wgp - dWgp*N;\n   Wyp = Wyp - dWyp*N;\n   \n   Bfp = Bfp - dBfp*N;\n   Bip = Bip - dBip*N;\n   Bop = Bop - dBop*N;\n   Bgp = Bgp - dBgp*N;\n   Byp = Byp - dByp*N;\n   \n   //Future\n   Wff = Wff - dWff*N;\n   Wif = Wif - dWif*N;\n   Wof = Wof - dWof*N;\n   Wgf = Wgf - dWgf*N;\n   Wyf = Wyf - dWyf*N;\n   \n   Bff = Bff - dBff*N;\n   Bif = Bif - dBif*N;\n   Bof = Bof - dBof*N;\n   Bgf = Bgf - dBgf*N;\n   Byf = Byf - dByf*N;\n  }\nif(OP == ADAM)\n  {\n      it +=1;\n      //sa\u00edda\n      mWyp = AdamM(mWyp,dWyp,beta1);\n      vWyp = AdamV(vWyp,dWyp,beta2);\n      Wyp = Wyp - Adam(it,mWyp,vWyp,beta1,beta2,alpha);\n      \n      mByp = AdamM(mByp,dByp,beta1);\n      vByp = AdamV(vByp,dByp,beta2);\n      Byp = Byp -Adam(it,mByp,vByp,beta1,beta2,alpha);\n      \n      //Forget\n      mWfp = AdamM(mWfp,dWfp,beta1);\n      vWfp = AdamV(vWfp,dWfp,beta2);\n      Wfp = Wfp - Adam(it,mWfp,vWfp,beta1,beta2,alpha);\n      \n      mBfp = AdamM(mBfp,dBfp,beta1);\n      vBfp = AdamV(vBfp,dBfp,beta2);\n      Bfp = Bfp -Adam(it,mBfp,vBfp,beta1,beta2,alpha);\n      \n      //Output\n      mWop = AdamM(mWop,dWop,beta1);\n      vWop = AdamV(vWop,dWop,beta2);\n      Wop = Wop - Adam(it,mWop,vWop,beta1,beta2,alpha);\n      \n      mBop = AdamM(mBop,dBop,beta1);\n      vBop = AdamV(vBop,dBop,beta2);\n      Bop = Bop -Adam(it,mBop,vBop,beta1,beta2,alpha);\n      \n      //Input\n      mWip = AdamM(mWip,dWip,beta1);\n      vWip = AdamV(vWip,dWip,beta2);\n      Wip = Wip- Adam(it,mWip,vWip,beta1,beta2,alpha);\n      \n      mBip = AdamM(mBip,dBip,beta1);\n      vBip = AdamV(vBip,dBip,beta2);\n      Bip = Bip -Adam(it,mBip,vBip,beta1,beta2,alpha);\n      \n      //Candidate\n      mWgp = AdamM(mWgp,dWgp,beta1);\n      vWgp = AdamV(vWgp,dWgp,beta2);\n      Wgp = Wgp - Adam(it,mWgp,vWgp,beta1,beta2,alpha);\n      \n      mBgp = AdamM(mBgp,dBgp,beta1);\n      vBgp = AdamV(vBgp,dBgp,beta2);\n      Bgp = Bgp -Adam(it,mBgp,vBgp,beta1,beta2,alpha);\n\n      //sa\u00edda\n      mWyf = AdamM(mWyf,dWyf,beta1);\n      vWyf = AdamV(vWyf,dWyf,beta2);\n      Wyf = Wyf - Adam(it,mWyf,vWyf,beta1,beta2,alpha);\n      \n      mByf = AdamM(mByf,dByf,beta1);\n      vByf = AdamV(vByf,dByf,beta2);\n      Byf = Byf -Adam(it,mByf,vByf,beta1,beta2,alpha);\n      \n      //Forget\n      mWff = AdamM(mWff,dWff,beta1);\n      vWff = AdamV(vWff,dWff,beta2);\n      Wff = Wff - Adam(it,mWff,vWff,beta1,beta2,alpha);\n      \n      mBff = AdamM(mBff,dBff,beta1);\n      vBff = AdamV(vBff,dBff,beta2);\n      Bff = Bff -Adam(it,mBff,vBff,beta1,beta2,alpha);\n      \n      //Output\n      mWof = AdamM(mWof,dWof,beta1);\n      vWof = AdamV(vWof,dWof,beta2);\n      Wof = Wof - Adam(it,mWof,vWof,beta1,beta2,alpha);\n      \n      mBof = AdamM(mBof,dBof,beta1);\n      vBof = AdamV(vBof,dBof,beta2);\n      Bof = Bof -Adam(it,mBof,vBof,beta1,beta2,alpha);\n      \n      //Input\n      mWif = AdamM(mWif,dWif,beta1);\n      vWif = AdamV(vWif,dWif,beta2);\n      Wif = Wif- Adam(it,mWif,vWif,beta1,beta2,alpha);\n      \n      mBif = AdamM(mBif,dBif,beta1);\n      vBif = AdamV(vBif,dBif,beta2);\n      Bif = Bif -Adam(it,mBif,vBif,beta1,beta2,alpha);\n      \n      //Candidate\n      mWgf = AdamM(mWgf,dWgf,beta1);\n      vWgf = AdamV(vWgf,dWgf,beta2);\n      Wgf = Wgf - Adam(it,mWgf,vWgf,beta1,beta2,alpha);\n      \n      mBgf = AdamM(mBgf,dBgf,beta1);\n      vBgf = AdamV(vBgf,dBgf,beta2);\n      Bgf = Bgf -Adam(it,mBgf,vBgf,beta1,beta2,alpha);\n  }\n}\n\nvoid   BiLSTMLayer::SaveWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfpLayer\" + IntegerToString(k);\n   SaveMatrix(Wfp,csv_name);\n   csv_name = IAname + \"\\WipLayer\" + IntegerToString(k);\n   SaveMatrix(Wip,csv_name);\n   csv_name = IAname + \"\\WopLayer\" + IntegerToString(k);\n   SaveMatrix(Wop,csv_name);\n   csv_name = IAname + \"\\WgpLayer\" + IntegerToString(k);\n   SaveMatrix(Wgp,csv_name);\n   csv_name = IAname + \"\\WypLayer\" + IntegerToString(k);\n   SaveMatrix(Wyp,csv_name);\n   \n   csv_name = IAname + \"\\BfpLayer\" + IntegerToString(k);\n   SaveMatrix(Bfp,csv_name);\n   csv_name = IAname + \"\\BipLayer\" + IntegerToString(k);\n   SaveMatrix(Bip,csv_name);\n   csv_name = IAname + \"\\BopLayer\" + IntegerToString(k);\n   SaveMatrix(Bop,csv_name);\n   csv_name = IAname + \"\\BgpLayer\" + IntegerToString(k);\n   SaveMatrix(Bgp,csv_name);\n   csv_name = IAname + \"\\BypLayer\" + IntegerToString(k);\n   SaveMatrix(Byp,csv_name);\n   \n   csv_name = IAname + \"\\WffLayer\" + IntegerToString(k);\n   SaveMatrix(Wff,csv_name);\n   csv_name = IAname + \"\\WifLayer\" + IntegerToString(k);\n   SaveMatrix(Wif,csv_name);\n   csv_name = IAname + \"\\WofLayer\" + IntegerToString(k);\n   SaveMatrix(Wof,csv_name);\n   csv_name = IAname + \"\\WgfLayer\" + IntegerToString(k);\n   SaveMatrix(Wgf,csv_name);\n   csv_name = IAname + \"\\WyfLayer\" + IntegerToString(k);\n   SaveMatrix(Wyf,csv_name);\n   \n   csv_name = IAname + \"\\BffLayer\" + IntegerToString(k);\n   SaveMatrix(Bff,csv_name);\n   csv_name = IAname + \"\\BifLayer\" + IntegerToString(k);\n   SaveMatrix(Bif,csv_name);\n   csv_name = IAname + \"\\BofLayer\" + IntegerToString(k);\n   SaveMatrix(Bof,csv_name);\n   csv_name = IAname + \"\\BgfLayer\" + IntegerToString(k);\n   SaveMatrix(Bgf,csv_name);\n   csv_name = IAname + \"\\ByfLayer\" + IntegerToString(k);\n   SaveMatrix(Byf,csv_name);\n}\nvoid   BiLSTMLayer::LoadWeights(int k,string IAname)\n{\n   string csv_name;\n   csv_name = IAname + \"\\WfpLayer\" + IntegerToString(k);\n   Wfp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WipLayer\" + IntegerToString(k);\n   Wip = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WopLayer\" + IntegerToString(k);\n   Wop = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgpLayer\" + IntegerToString(k);\n   Wgp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WypLayer\" + IntegerToString(k);\n   Wyp = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BfpLayer\" + IntegerToString(k);\n   Bfp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BipLayer\" + IntegerToString(k);\n   Bip = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BopLayer\" + IntegerToString(k);\n   Bop = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgpLayer\" + IntegerToString(k);\n   Bgp = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BypLayer\" + IntegerToString(k);\n   Byp = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\WffLayer\" + IntegerToString(k);\n   Wff = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WifLayer\" + IntegerToString(k);\n   Wif = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WofLayer\" + IntegerToString(k);\n   Wof = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WgfLayer\" + IntegerToString(k);\n   Wgf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\WyfLayer\" + IntegerToString(k);\n   Wyf = LoadMatrix(csv_name);\n   \n   csv_name = IAname + \"\\BffLayer\" + IntegerToString(k);\n   Bff = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BifLayer\" + IntegerToString(k);\n   Bif = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BofLayer\" + IntegerToString(k);\n   Bof = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BgfLayer\" + IntegerToString(k);\n   Bgf = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\ByfLayer\" + IntegerToString(k);\n   Byf = LoadMatrix(csv_name);\n\n}\nvoid   BiLSTMLayer::SetAdam(double B1, double B2, double Alph)\n{\n\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}\n"}, {"filename": "Metrics.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/Metrics.mqh", "content": "//+------------------------------------------------------------------+\n//|   Metrics                                                        |\n//+------------------------------------------------------------------+\n\nclass Metrics : public DeepLearning\n  {\npublic:\n  //Used for multiclass problems, transforms the output matrix \n  //from the softmax layer into an output of zeros and ones where 1 \n  // is the most likely class\n   matrix ArgMax(matrix &X);\n   \n   //Accuracy = Total number of hits over the total number of samples\n   double Accuracy(matrix &R, matrix &Out);\n   \n   //Mean absolute percentage error \n   double MAPE(matrix &R, matrix &Y);\n  };\n\n//+------------------------------------------------------------------+\n//|    Metrics                                                       |\n//+------------------------------------------------------------------+\nmatrix Metrics::ArgMax(matrix &X)\n{\nvector V;\nV.Init(X.Cols());\n\nulong count;\nmatrix M;\nM.Init(X.Rows(),X.Cols());\nfor(int i=0;i<X.Rows();i++)\n   {for(int j=0;j<X.Cols();j++)\n      {V[j] = X[i][j];}\n   count = V.ArgMax();\n   \n   for(int j=0;j<X.Cols();j++)\n     {if(j == count) M[i][j] = 1;\n      if(j != count) M[i][j] = 0;}\n    }\nreturn M; \n}\n\ndouble Metrics::Accuracy(matrix &R, matrix &Out)\n{\nmatrix Y;\nvector v1, v2;\nv1.Init(R.Cols());\n\nY = ArgMax(Out);\nv2.Init(Y.Cols());\n\nulong count1, count2;\ndouble N_samples, N_hits, Accur;\nN_samples = R.Rows();\nN_hits = 0;\n\nfor(int i=0;i<R.Rows();i++)\n  {for(int j=0;j<R.Cols();j++)\n     {v1[j] = R[i][j];\n      v2[j] = Y[i][j];}\n   count1 = v1.ArgMax();\n   count2 = v2.ArgMax();\n   if(count1 == count2) N_hits = N_hits + 1.0;\n   \n  }\n  \nAccur = N_hits/N_samples;\nreturn Accur;\n}\n\ndouble Metrics::MAPE(matrix &R, matrix &Y)\n{\nmatrix Err;\nErr = R - Y; \nErr = Err / R; \nErr = MathAbs(Err);\n\ndouble error; \nerror = Err.Mean();\n\nreturn error; \n}", "search_content": "//+------------------------------------------------------------------+\n//|   Metrics                                                        |\n//+------------------------------------------------------------------+\n\nclass Metrics : public DeepLearning\n  {\npublic:\n  //Used for multiclass problems, transforms the output matrix \n  //from the softmax layer into an output of zeros and ones where 1 \n  // is the most likely class\n   matrix ArgMax(matrix &X);\n   \n   //Accuracy = Total number of hits over the total number of samples\n   double Accuracy(matrix &R, matrix &Out);\n   \n   //Mean absolute percentage error \n   double MAPE(matrix &R, matrix &Y);\n  };\n\n//+------------------------------------------------------------------+\n//|    Metrics                                                       |\n//+------------------------------------------------------------------+\nmatrix Metrics::ArgMax(matrix &X)\n{\nvector V;\nV.Init(X.Cols());\n\nulong count;\nmatrix M;\nM.Init(X.Rows(),X.Cols());\nfor(int i=0;i<X.Rows();i++)\n   {for(int j=0;j<X.Cols();j++)\n      {V[j] = X[i][j];}\n   count = V.ArgMax();\n   \n   for(int j=0;j<X.Cols();j++)\n     {if(j == count) M[i][j] = 1;\n      if(j != count) M[i][j] = 0;}\n    }\nreturn M; \n}\n\ndouble Metrics::Accuracy(matrix &R, matrix &Out)\n{\nmatrix Y;\nvector v1, v2;\nv1.Init(R.Cols());\n\nY = ArgMax(Out);\nv2.Init(Y.Cols());\n\nulong count1, count2;\ndouble N_samples, N_hits, Accur;\nN_samples = R.Rows();\nN_hits = 0;\n\nfor(int i=0;i<R.Rows();i++)\n  {for(int j=0;j<R.Cols();j++)\n     {v1[j] = R[i][j];\n      v2[j] = Y[i][j];}\n   count1 = v1.ArgMax();\n   count2 = v2.ArgMax();\n   if(count1 == count2) N_hits = N_hits + 1.0;\n   \n  }\n  \nAccur = N_hits/N_samples;\nreturn Accur;\n}\n\ndouble Metrics::MAPE(matrix &R, matrix &Y)\n{\nmatrix Err;\nErr = R - Y; \nErr = Err / R; \nErr = MathAbs(Err);\n\ndouble error; \nerror = Err.Mean();\n\nreturn error; \n}"}, {"filename": "DenseLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/DenseLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Dense Layer                                                    |\n//+------------------------------------------------------------------+\n\nclass DenseLayer : public DeepLearning\n  {\npublic:\n   //Initializes the layer weights and bias from the number of outputs\n   //LR is Learning rate and Op is the optimization method\n   void InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error  \n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Configurar par\u00e2metros do ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\nprivate:\n   //Pesos da camada\n   matrix W;\n   //Grad dos Pesos\n   matrix dW;\n   //Bias da camada\n   matrix B;\n   //Grad do Bias\n   matrix dB;\n   //Vetor de entrada \n   matrix Xe;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimza\u00e7\u00e3o\n   Optim OP;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n      \n  };\n\n//+------------------------------------------------------------------+\n//|   DenseLayer                                                     |\n//+------------------------------------------------------------------+\nvoid DenseLayer::InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n   \n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix DenseLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\nreturn Y;\n}\nmatrix DenseLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex; \n   Ex = W.Transpose().MatMul(Ey);\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   return Ex;\n}\nvoid DenseLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }   \n}\nvoid DenseLayer::SaveWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n\n} \n\nvoid DenseLayer::LoadWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid DenseLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}", "search_content": "//+------------------------------------------------------------------+\n//|   Dense Layer                                                    |\n//+------------------------------------------------------------------+\n\nclass DenseLayer : public DeepLearning\n  {\npublic:\n   //Initializes the layer weights and bias from the number of outputs\n   //LR is Learning rate and Op is the optimization method\n   void InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD);\n   //Calculates the output of the layer from an input\n   virtual matrix Output(matrix &X);\n   //Propagates the error  \n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights\n   virtual void   Update(void);\n   //Save the weights, k is the index the layer;\n   virtual void   SaveWeights(int k,string IAname);\n   //Load the weights\n   virtual void   LoadWeights(int k,string IAname);\n   \n   //Configurar par\u00e2metros do ADAM\n   virtual void   SetAdam(double B1, double B2, double Alph);\nprivate:\n   //Pesos da camada\n   matrix W;\n   //Grad dos Pesos\n   matrix dW;\n   //Bias da camada\n   matrix B;\n   //Grad do Bias\n   matrix dB;\n   //Vetor de entrada \n   matrix Xe;\n   //Taxa de aprendizagem\n   double N;\n   //M\u00e9todo de otimza\u00e7\u00e3o\n   Optim OP;\n   \n   //ADAM \n   //===============\n   //Contador de itera\u00e7\u00f5es\n   ulong it; \n   //m\n   matrix mW, mB;\n   //v\n   matrix vW, vB;\n   //hiper par\u00e2metros\n   double beta1, beta2, alpha; \n      \n  };\n\n//+------------------------------------------------------------------+\n//|   DenseLayer                                                     |\n//+------------------------------------------------------------------+\nvoid DenseLayer::InitLayer(int N_entries, int N_outputs, double LR, Optim Op = STD)\n{\n   W.Init(N_outputs,N_entries);\n   B.Init(N_outputs,1);\n   N = LR;\n   OP = Op;\n   W = InitWeights(W);\n   B = InitWeights(B);\n   \n   if(OP == ADAM)\n     {\n      it = 0;\n      beta1 = 0.9;\n      beta2 = 0.999;\n      alpha = N;\n      \n      mW.Init(W.Rows(),W.Cols());\n      vW.Init(W.Rows(),W.Cols());  \n      mW = ZeroMatrix(mW);\n      vW = ZeroMatrix(vW);\n      \n      mB.Init(B.Rows(),B.Cols());\n      vB.Init(B.Rows(),B.Cols());\n      mB = ZeroMatrix(mB);\n      vB = ZeroMatrix(vB);\n     }\n\n}\nmatrix DenseLayer::Output(matrix &X)\n{\nmatrix Y;\nXe = X;\nY = W.MatMul(X) + B;\nreturn Y;\n}\nmatrix DenseLayer::GradDescent(matrix &Ey)\n{\n   matrix Ex; \n   Ex = W.Transpose().MatMul(Ey);\n   \n   dW = Ey.MatMul(Xe.Transpose());\n   dB = Ey;\n   return Ex;\n}\nvoid DenseLayer::Update(void)\n{\n   if(OP == STD)\n     {\n      W = W - dW*N;\n      B = B - dB*N;}\n   if(OP == ADAM)\n     {\n\n      it +=1;\n      \n      mW = AdamM(mW,dW,beta1);\n      vW = AdamV(vW,dW,beta2);\n      W = W - Adam(it,mW,vW,beta1,beta2,alpha);\n      \n      mB = AdamM(mB,dB,beta1);\n      vB = AdamV(vB,dB,beta2);\n      B = B -Adam(it,mB,vB,beta1,beta2,alpha);\n      \n     }   \n}\nvoid DenseLayer::SaveWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   SaveMatrix(W,csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   SaveMatrix(B,csv_name);\n\n} \n\nvoid DenseLayer::LoadWeights(int k, string IAname)\n{\n\n   string csv_name;\n   csv_name = IAname + \"\\WLayer\" + IntegerToString(k);\n   W = LoadMatrix(csv_name);\n   csv_name = IAname + \"\\BLayer\" + IntegerToString(k);\n   B = LoadMatrix(csv_name);\n\n}\nvoid DenseLayer::SetAdam(double B1,double B2,double Alph)\n{\nbeta1 = B1;\nbeta2 = B2;\nalpha = Alph;\n}"}, {"filename": "ActivationLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/ActivationLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Activation Layer                                               |\n//+------------------------------------------------------------------+\n\nclass ActivationLayer : public DeepLearning\n  {\npublic:\n   \n   void   InitLayer(ActFunction af);\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\n   \nprivate :\n   \n   //Activation function\n   ActFunction AF;\n   //Input that needs to be saved for gradient descent\n   matrix Xs;  \n  };\n\n//+------------------------------------------------------------------+\n//|    Activation Layer                                              |\n//+------------------------------------------------------------------+\n\nvoid ActivationLayer::InitLayer(ActFunction af)\n{\nAF = af;\n}\nmatrix ActivationLayer::Output(matrix &X)\n{\nmatrix Y;\n\nXs = X;\nif(AF == SIGMOID) Y = Sig(X);\nif(AF == TANH)    Y = Tanh(X);\nif(AF == RELU)    Y = ReLU(X);\n\nreturn Y;\n}\nmatrix ActivationLayer::GradDescent(matrix &Ey)\n{\nmatrix dPhi;\n\nmatrix Ex;\nif(AF == SIGMOID) dPhi = dSig(Xs);\nif(AF == TANH)    dPhi = dTanh(Xs);\nif(AF == RELU)    dPhi = dReLU(Xs);\n\nEx = Ey * dPhi;\nreturn Ex;\n}\n", "search_content": "//+------------------------------------------------------------------+\n//|   Activation Layer                                               |\n//+------------------------------------------------------------------+\n\nclass ActivationLayer : public DeepLearning\n  {\npublic:\n   \n   void   InitLayer(ActFunction af);\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\n   \nprivate :\n   \n   //Activation function\n   ActFunction AF;\n   //Input that needs to be saved for gradient descent\n   matrix Xs;  \n  };\n\n//+------------------------------------------------------------------+\n//|    Activation Layer                                              |\n//+------------------------------------------------------------------+\n\nvoid ActivationLayer::InitLayer(ActFunction af)\n{\nAF = af;\n}\nmatrix ActivationLayer::Output(matrix &X)\n{\nmatrix Y;\n\nXs = X;\nif(AF == SIGMOID) Y = Sig(X);\nif(AF == TANH)    Y = Tanh(X);\nif(AF == RELU)    Y = ReLU(X);\n\nreturn Y;\n}\nmatrix ActivationLayer::GradDescent(matrix &Ey)\n{\nmatrix dPhi;\n\nmatrix Ex;\nif(AF == SIGMOID) dPhi = dSig(Xs);\nif(AF == TANH)    dPhi = dTanh(Xs);\nif(AF == RELU)    dPhi = dReLU(Xs);\n\nEx = Ey * dPhi;\nreturn Ex;\n}\n"}, {"filename": "FlattenLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/FlattenLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Flatten                                                        |\n//+------------------------------------------------------------------+\n\nclass FlattenLayer : public DeepLearning\n  {\npublic:\n   //Calculates the output of the litter from an input\n   //Transforms each row of matrix X into a column and then puts a column\n   //below column EX: {{1,2},{3,4}} => {{1},{2},{3},{4}}\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights \nprivate: \n   int N_steps;\n   int N_entries;\n  };\n\n//+------------------------------------------------------------------+\n//|    Flatten Layer                                                 |\n//+------------------------------------------------------------------+\n\nmatrix FlattenLayer::Output(matrix &X)\n{\nN_entries = X.Rows();\nN_steps = X.Cols();\nmatrix Y;\nY.Init(N_entries*N_steps,1);\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Y[i*N_entries+j][0] = X[i][j];}}\n\nreturn Y;\n}  \nmatrix FlattenLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex;\nEx.Init(N_entries,N_steps);\n\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Ex[i][j]= Ey[i*N_entries+j][0];}}\n\nreturn Ex;\n}\n\n", "search_content": "//+------------------------------------------------------------------+\n//|   Flatten                                                        |\n//+------------------------------------------------------------------+\n\nclass FlattenLayer : public DeepLearning\n  {\npublic:\n   //Calculates the output of the litter from an input\n   //Transforms each row of matrix X into a column and then puts a column\n   //below column EX: {{1,2},{3,4}} => {{1},{2},{3},{4}}\n   virtual matrix Output(matrix &X);\n   //Propagates the Error\n   virtual matrix GradDescent(matrix &Ey);\n   //Updates the weights \nprivate: \n   int N_steps;\n   int N_entries;\n  };\n\n//+------------------------------------------------------------------+\n//|    Flatten Layer                                                 |\n//+------------------------------------------------------------------+\n\nmatrix FlattenLayer::Output(matrix &X)\n{\nN_entries = X.Rows();\nN_steps = X.Cols();\nmatrix Y;\nY.Init(N_entries*N_steps,1);\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Y[i*N_entries+j][0] = X[i][j];}}\n\nreturn Y;\n}  \nmatrix FlattenLayer::GradDescent(matrix &Ey)\n{\nmatrix Ex;\nEx.Init(N_entries,N_steps);\n\nfor(int i=0;i<N_entries;i++)\n  {for(int j=0;j<N_steps;j++)\n     {Ex[i][j]= Ey[i*N_entries+j][0];}}\n\nreturn Ex;\n}\n\n"}, {"filename": "SoftmaxLayer.mqh", "path": "new_knowledge/Deep-Learning-for-MQL5-master/Layers/SoftmaxLayer.mqh", "content": "//+------------------------------------------------------------------+\n//|   Softmax Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass softmaxLayer : public DeepLearning\n  {\npublic:\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\nprivate:\n   matrix M; \n  };\n\n//+------------------------------------------------------------------+\n//|     Softmax                                                      |\n//+------------------------------------------------------------------+\nmatrix softmaxLayer::Output(matrix &X)\n{\nmatrix Y;\nY.Init(X.Rows(),X.Cols());\ndouble Sum;\nSum = 0;\n\nfor(int i=0;i<X.Rows();i++)\n  {Sum = Sum + MathExp(X[i][0]);}\nfor(int i=0;i<Y.Rows();i++)\n  {Y[i][0] = MathExp(X[i][0])/Sum;}\n\nM.Init(Y.Rows(),Y.Rows());\n\nfor(int j=0;j<M.Cols();j++)\n  {for(int i=0;i<M.Rows();i++)\n     {M[i][j] = Y[i][0];}}\n\nreturn Y; \n}\nmatrix softmaxLayer::GradDescent(matrix &Ey)\n{\nmatrix S;\nmatrix I;\nI.Init(M.Rows(),M.Cols());\nI.Identity();\nS = M * (I - M.Transpose());\nS = S.MatMul(Ey);\nreturn S;\n}\n", "search_content": "//+------------------------------------------------------------------+\n//|   Softmax Layer                                                  |\n//+------------------------------------------------------------------+\n\nclass softmaxLayer : public DeepLearning\n  {\npublic:\n   virtual matrix Output(matrix &X);\n   virtual matrix GradDescent(matrix &Ey);\nprivate:\n   matrix M; \n  };\n\n//+------------------------------------------------------------------+\n//|     Softmax                                                      |\n//+------------------------------------------------------------------+\nmatrix softmaxLayer::Output(matrix &X)\n{\nmatrix Y;\nY.Init(X.Rows(),X.Cols());\ndouble Sum;\nSum = 0;\n\nfor(int i=0;i<X.Rows();i++)\n  {Sum = Sum + MathExp(X[i][0]);}\nfor(int i=0;i<Y.Rows();i++)\n  {Y[i][0] = MathExp(X[i][0])/Sum;}\n\nM.Init(Y.Rows(),Y.Rows());\n\nfor(int j=0;j<M.Cols();j++)\n  {for(int i=0;i<M.Rows();i++)\n     {M[i][j] = Y[i][0];}}\n\nreturn Y; \n}\nmatrix softmaxLayer::GradDescent(matrix &Ey)\n{\nmatrix S;\nmatrix I;\nI.Init(M.Rows(),M.Cols());\nI.Identity();\nS = M * (I - M.Transpose());\nS = S.MatMul(Ey);\nreturn S;\n}\n"}, {"filename": "Account.test.mq5", "path": "new_knowledge/EA31337-classes-master/Account/tests/Account.test.mq5", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n *  This file is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @file\n * Test functionality of Account class.\n */\n\n// Includes.\n#include \"../../Test.mqh\"\n#include \"../Account.h\"\n\n/**\n * Implements OnInit().\n */\nint OnInit() {\n  bool _result = true;\n  Account<AccountBaseState, AccountBaseEntry> acc1;\n  // ...\n  return _result && GetLastError() == 0 ? INIT_SUCCEEDED : INIT_FAILED;\n}\n\n/**\n * Implements Tick event handler.\n */\nvoid OnTick() {}\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n *  This file is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @file\n * Test functionality of Account class.\n */\n\n// Includes.\n#include \"../../Test.mqh\"\n#include \"../Account.h\"\n\n/**\n * Implements OnInit().\n */\nint OnInit() {\n  bool _result = true;\n  Account<AccountBaseState, AccountBaseEntry> acc1;\n  // ...\n  return _result && GetLastError() == 0 ? INIT_SUCCEEDED : INIT_FAILED;\n}\n\n/**\n * Implements Tick event handler.\n */\nvoid OnTick() {}\n"}, {"filename": "Cube.h", "path": "new_knowledge/EA31337-classes-master/3D/Cube.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Cube mesh.\n */\n\n#include \"Face.h\"\n#include \"Mesh.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/cube_ps.hlsl\" as string ShaderCubeSourcePS;\n#resource \"Shaders/cube_vs.hlsl\" as string ShaderCubeSourceVS;\n#endif\n\n/**\n * Cube mesh.\n */\ntemplate <typename T>\nclass Cube : public Mesh<T> {\n public:\n  Cube(float size_x, float size_y, float size_z, float x = 0.0f, float y = 0.0f, float z = 0.0f)\n      : Mesh(MESH_TYPE_SEPARATE_POINTS) {\n    float half_x = size_x / 2;\n    float half_y = size_y / 2;\n    float half_z = size_z / 2;\n\n    Face<T> f1(x - half_x, y - half_y, z - half_z, x - half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z - half_z, x + half_x, y - half_y, z - half_z);\n\n    Face<T> f2(x + half_x, y - half_y, z + half_z, x + half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z + half_z, x - half_x, y - half_y, z + half_z);\n\n    Face<T> f3(x - half_x, y - half_y, z + half_z, x - half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z - half_z, x - half_x, y - half_y, z - half_z);\n\n    Face<T> f4(x + half_x, y - half_y, z - half_z, x + half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f5(x - half_x, y - half_y, z + half_z, x - half_x, y - half_y, z - half_z, x + half_x, y - half_y,\n               z - half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f6(x - half_x, y + half_y, z - half_z, x - half_x, y + half_y, z + half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y + half_y, z - half_z);\n\n    AddFace(f1);\n    AddFace(f2);\n    AddFace(f3);\n    AddFace(f4);\n    AddFace(f5);\n    AddFace(f6);\n  }\n\n#ifdef __MQL5__\n  /**\n   * Initializes graphics device-related things.\n   */\n  virtual void Initialize(Device* _device) {\n    SetShaderVS(_device.VertexShader(ShaderCubeSourceVS, T::Layout));\n    SetShaderPS(_device.PixelShader(ShaderCubeSourcePS));\n  }\n#endif\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Cube mesh.\n */\n\n#include \"Face.h\"\n#include \"Mesh.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/cube_ps.hlsl\" as string ShaderCubeSourcePS;\n#resource \"Shaders/cube_vs.hlsl\" as string ShaderCubeSourceVS;\n#endif\n\n/**\n * Cube mesh.\n */\ntemplate <typename T>\nclass Cube : public Mesh<T> {\n public:\n  Cube(float size_x, float size_y, float size_z, float x = 0.0f, float y = 0.0f, float z = 0.0f)\n      : Mesh(MESH_TYPE_SEPARATE_POINTS) {\n    float half_x = size_x / 2;\n    float half_y = size_y / 2;\n    float half_z = size_z / 2;\n\n    Face<T> f1(x - half_x, y - half_y, z - half_z, x - half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z - half_z, x + half_x, y - half_y, z - half_z);\n\n    Face<T> f2(x + half_x, y - half_y, z + half_z, x + half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z + half_z, x - half_x, y - half_y, z + half_z);\n\n    Face<T> f3(x - half_x, y - half_y, z + half_z, x - half_x, y + half_y, z + half_z, x - half_x, y + half_y,\n               z - half_z, x - half_x, y - half_y, z - half_z);\n\n    Face<T> f4(x + half_x, y - half_y, z - half_z, x + half_x, y + half_y, z - half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f5(x - half_x, y - half_y, z + half_z, x - half_x, y - half_y, z - half_z, x + half_x, y - half_y,\n               z - half_z, x + half_x, y - half_y, z + half_z);\n\n    Face<T> f6(x - half_x, y + half_y, z - half_z, x - half_x, y + half_y, z + half_z, x + half_x, y + half_y,\n               z + half_z, x + half_x, y + half_y, z - half_z);\n\n    AddFace(f1);\n    AddFace(f2);\n    AddFace(f3);\n    AddFace(f4);\n    AddFace(f5);\n    AddFace(f6);\n  }\n\n#ifdef __MQL5__\n  /**\n   * Initializes graphics device-related things.\n   */\n  virtual void Initialize(Device* _device) {\n    SetShaderVS(_device.VertexShader(ShaderCubeSourceVS, T::Layout));\n    SetShaderPS(_device.PixelShader(ShaderCubeSourcePS));\n  }\n#endif\n};\n"}, {"filename": "Frontend.h", "path": "new_knowledge/EA31337-classes-master/3D/Frontend.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics front-end (display buffer target).\n */\n\n#include \"../Refs.mqh\"\n\nstruct DrawTextQueueItem {\n  float x;\n  float y;\n  string text;\n  unsigned int rgb;\n  unsigned int align;\n};\n\n/**\n * Represents visual target (OS window/canvas for rendering).\n */\nclass Frontend : public Dynamic {\n protected:\n  DrawTextQueueItem draw_text_queue[];\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  bool Start() { return Init(); }\n\n  /**\n   * Deinitializes canvas.\n   */\n  bool End() { return Deinit(); }\n\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() = NULL;\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() = NULL;\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) = NULL;\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) = NULL;\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() = NULL;\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() = NULL;\n\n  /**\n   * Enqueues text to be drawn directly into the pixel buffer. Queue will be processed in the Device::End() method.\n   */\n  virtual void DrawText(float _x, float _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    DrawTextQueueItem _item;\n    _item.x = _x;\n    _item.y = _y;\n    _item.text = _text;\n    _item.rgb = _color;\n    _item.align = _align;\n    Util::ArrayPush(draw_text_queue, _item);\n  }\n\n  void ProcessDrawText() {\n    for (int i = 0; i < ArraySize(draw_text_queue); ++i) {\n      DrawTextQueueItem _item = draw_text_queue[i];\n      DrawTextNow((int)_item.x, (int)_item.y, _item.text, _item.rgb, _item.align);\n    }\n    ArrayResize(draw_text_queue, 0);\n  }\n\n protected:\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {}\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics front-end (display buffer target).\n */\n\n#include \"../Refs.mqh\"\n\nstruct DrawTextQueueItem {\n  float x;\n  float y;\n  string text;\n  unsigned int rgb;\n  unsigned int align;\n};\n\n/**\n * Represents visual target (OS window/canvas for rendering).\n */\nclass Frontend : public Dynamic {\n protected:\n  DrawTextQueueItem draw_text_queue[];\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  bool Start() { return Init(); }\n\n  /**\n   * Deinitializes canvas.\n   */\n  bool End() { return Deinit(); }\n\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() = NULL;\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() = NULL;\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) = NULL;\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) = NULL;\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() = NULL;\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() = NULL;\n\n  /**\n   * Enqueues text to be drawn directly into the pixel buffer. Queue will be processed in the Device::End() method.\n   */\n  virtual void DrawText(float _x, float _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    DrawTextQueueItem _item;\n    _item.x = _x;\n    _item.y = _y;\n    _item.text = _text;\n    _item.rgb = _color;\n    _item.align = _align;\n    Util::ArrayPush(draw_text_queue, _item);\n  }\n\n  void ProcessDrawText() {\n    for (int i = 0; i < ArraySize(draw_text_queue); ++i) {\n      DrawTextQueueItem _item = draw_text_queue[i];\n      DrawTextNow((int)_item.x, (int)_item.y, _item.text, _item.rgb, _item.align);\n    }\n    ArrayResize(draw_text_queue, 0);\n  }\n\n protected:\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {}\n};\n"}, {"filename": "Material.h", "path": "new_knowledge/EA31337-classes-master/3D/Material.h", "content": "#include \"Math.h\"\n\n/**\n * Generic vertex to be used by meshes.\n */\nclass Material {\n public:\n  DXColor Color;\n\n  Material(unsigned int _color = 0xFFFFFFFF) { Color = DXColor(_color); }\n\n  Material(const Material& _r) { Color = _r.Color; }\n\n  Material* SetColor(unsigned int _color) {\n    Color = DXColor(_color);\n    return &this;\n  }\n};\n", "search_content": "#include \"Math.h\"\n\n/**\n * Generic vertex to be used by meshes.\n */\nclass Material {\n public:\n  DXColor Color;\n\n  Material(unsigned int _color = 0xFFFFFFFF) { Color = DXColor(_color); }\n\n  Material(const Material& _r) { Color = _r.Color; }\n\n  Material* SetColor(unsigned int _color) {\n    Color = DXColor(_color);\n    return &this;\n  }\n};\n"}, {"filename": "VertexBuffer.h", "path": "new_knowledge/EA31337-classes-master/3D/VertexBuffer.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics vertex buffer.\n */\n\n#include \"../Refs.mqh\"\n\nclass VertexBuffer : public Dynamic {\n  // Reference to graphics device.\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  VertexBuffer(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  virtual void Select() = NULL;\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics vertex buffer.\n */\n\n#include \"../Refs.mqh\"\n\nclass VertexBuffer : public Dynamic {\n  // Reference to graphics device.\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  VertexBuffer(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  virtual void Select() = NULL;\n};\n"}, {"filename": "Device.h", "path": "new_knowledge/EA31337-classes-master/3D/Device.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics device.\n */\n\n#include \"../Refs.mqh\"\n#include \"../Util.h\"\n#include \"Frontend.h\"\n#include \"IndexBuffer.h\"\n#include \"Material.h\"\n#include \"Math.h\"\n#include \"Mesh.h\"\n#include \"Shader.h\"\n#include \"VertexBuffer.h\"\n\nenum GFX_DRAW_TEXT_FLAGS { GFX_DRAW_TEXT_FLAG_NONE, GFX_DRAW_TEXT_FLAG_2D_COORD_X, GFX_DRAW_TEXT_FLAG_2D_COORD_Y };\n\nenum ENUM_CLEAR_BUFFER_TYPE { CLEAR_BUFFER_TYPE_COLOR, CLEAR_BUFFER_TYPE_DEPTH };\n\n/**\n * Graphics device.\n */\nclass Device : public Dynamic {\n protected:\n  int context;\n  Ref<Frontend> frontend;\n  DXMatrix mtx_stack[];\n  DXMatrix mtx_world;\n  DXMatrix mtx_view;\n  DXMatrix mtx_projection;\n  DXVector3 lightdir;\n  Material material;\n\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Start(Frontend* _frontend) {\n    frontend = _frontend;\n    DXMatrixIdentity(mtx_world);\n    DXMatrixIdentity(mtx_view);\n    DXMatrixIdentity(mtx_projection);\n    TSR _identity;\n    PushTransform(_identity);\n    lightdir = DXVector3(-0.2f, 0.2f, 1.0f);\n    return Init(_frontend);\n  }\n\n  void PushTransform(const TSR& tsr) {\n    Util::ArrayPush(mtx_stack, mtx_world);\n    DXMatrixMultiply(mtx_world, tsr.ToMatrix(), mtx_world);\n  }\n\n  void PopTransform() { mtx_world = Util::ArrayPop(mtx_stack); }\n\n  /**\n   * Begins render loop.\n   */\n  Device* Begin(unsigned int clear_color = 0) {\n    frontend.Ptr().RenderBegin(context);\n    Clear(clear_color);\n    ClearDepth();\n    RenderBegin();\n    return &this;\n  }\n\n  /**\n   * Ends render loop.\n   */\n  Device* End() {\n    RenderEnd();\n    frontend.Ptr().RenderEnd(context);\n    frontend.Ptr().ProcessDrawText();\n    return &this;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  Device* Stop() {\n    Deinit();\n    return &this;\n  }\n\n  /**\n   * Clears scene's color buffer.\n   */\n  Device* Clear(unsigned int _color = 0xFF000000) {\n    ClearBuffer(CLEAR_BUFFER_TYPE_COLOR, _color);\n    return &this;\n  }\n\n  /**\n   * Begins scene's depth buffer.\n   */\n  Device* ClearDepth() {\n    ClearBuffer(CLEAR_BUFFER_TYPE_DEPTH, 0);\n    return &this;\n  }\n\n  /**\n   * Returns current material.\n   */\n  Material GetMaterial() { return material; }\n\n  /**\n   * Assigns material for later rendering.\n   */\n  void SetMaterial(Material& _material) { material = _material; }\n\n  /**\n   * Returns graphics device context as integer.\n   */\n  int Context() { return context; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[],\n                               string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  template <typename T>\n  VertexBuffer* VertexBuffer(T& data[]) {\n    VertexBuffer* _buff = VertexBuffer();\n    // Unfortunately we can't make this method virtual.\n    if (dynamic_cast<MTDXVertexBuffer*>(_buff) != NULL) {\n// MT5's DirectX.\n#ifdef __debug__\n      Print(\"Filling vertex buffer via MTDXVertexBuffer\");\n#endif\n      ((MTDXVertexBuffer*)_buff).Fill<T>(data);\n    } else {\n      Alert(\"Unsupported vertex buffer device target\");\n    }\n    return _buff;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  virtual VertexBuffer* VertexBuffer() = NULL;\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  void Render(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) { RenderBuffers(_vertices, _indices); }\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) = NULL;\n\n  /**\n   * Renders given mesh.\n   */\n  template <typename T>\n  void Render(Mesh<T>* _mesh, Shader* _vs = NULL, Shader* _ps = NULL) {\n#ifdef __debug__\n    Print(\"Rendering mesh\");\n#endif\n    VertexBuffer* _vertices;\n    IndexBuffer* _indices;\n    _mesh.GetBuffers(&this, _vertices, _indices);\n\n    SetMaterial(_mesh.GetMaterial());\n\n    PushTransform(_mesh.GetTSR());\n\n    SetShader(_vs != NULL ? _vs : _mesh.GetShaderVS());\n    SetShader(_ps != NULL ? _ps : _mesh.GetShaderPS());\n\n    Render(_vertices, _indices);\n\n    PopTransform();\n  }\n\n  /**\n   * Activates shader for rendering.\n   */\n  void SetShader(Shader* _shader) { _shader.Select(); }\n\n  /**\n   * Activates shaders for rendering.\n   */\n  void SetShader(Shader* _shader1, Shader* _shader2) {\n    _shader1.Select();\n    _shader2.Select();\n  }\n\n  /**\n   * Returns front-end's viewport width.\n   */\n  int Width() { return frontend.Ptr().Width(); }\n\n  /**\n   * Returns front-end's viewport height.\n   */\n  int Height() { return frontend.Ptr().Height(); }\n\n  void SetCameraOrtho3D(float _pos_x = 0.0f, float _pos_y = 0.0f, float _pos_z = 0.0f) {\n    DXMatrixOrthoLH(mtx_projection, 1.0f * _pos_z, 1.0f / Width() * Height() * _pos_z, -10000, 10000);\n  }\n\n  DXMatrix GetWorldMatrix() { return mtx_world; }\n\n  void SetWorldMatrix(DXMatrix& _matrix) { mtx_world = _matrix; }\n\n  DXMatrix GetViewMatrix() { return mtx_view; }\n\n  void SetViewMatrix(DXMatrix& _matrix) { mtx_view = _matrix; }\n\n  DXMatrix GetProjectionMatrix() { return mtx_projection; }\n\n  void SetProjectionMatrix(DXMatrix& _matrix) { mtx_projection = _matrix; }\n\n  DXVector3 GetLightDirection() { return lightdir; }\n\n  void SetLightDirection(float x, float y, float z) {\n    lightdir.x = x;\n    lightdir.y = y;\n    lightdir.z = z;\n  }\n\n  /**\n   * Enqueues text to be drawn directly into the pixel buffer. Queue will be processed in the Device::End() method.\n   */\n  void DrawText(float _x, float _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0,\n                unsigned int _flags = 0) {\n    DViewport _viewport;\n    _viewport.x = 0;\n    _viewport.y = 0;\n    _viewport.width = frontend.Ptr().Width();\n    _viewport.height = frontend.Ptr().Height();\n    _viewport.minz = -10000.0f;\n    _viewport.maxz = 10000.0f;\n\n    DXVector3 _vec3_in(_x, _y, 0.0f);\n    DXVector3 _vec3_out;\n    DXVec3Project(_vec3_out, _vec3_in, _viewport, GetProjectionMatrix(), GetViewMatrix(), GetWorldMatrix());\n\n    if ((_flags & GFX_DRAW_TEXT_FLAG_2D_COORD_X) == GFX_DRAW_TEXT_FLAG_2D_COORD_X) {\n      _vec3_out.x = _x;\n    }\n\n    if ((_flags & GFX_DRAW_TEXT_FLAG_2D_COORD_Y) == GFX_DRAW_TEXT_FLAG_2D_COORD_Y) {\n      _vec3_out.y = _y;\n    }\n\n    frontend.Ptr().DrawText(_vec3_out.x, _vec3_out.y, _text, _color, _align);\n  }\n\n protected:\n  /**\n   * Initializes graphics device.\n   */\n  virtual bool Init(Frontend*) = NULL;\n\n  /**\n   * Deinitializes graphics device.\n   */\n  virtual bool Deinit() = NULL;\n\n  /**\n   * Starts rendering loop.\n   */\n  virtual bool RenderBegin() = NULL;\n\n  /**\n   * Ends rendering loop.\n   */\n  virtual bool RenderEnd() = NULL;\n\n  /**\n   * Clears color buffer.\n   */\n  virtual void ClearBuffer(ENUM_CLEAR_BUFFER_TYPE _type, unsigned int _color) = NULL;\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics device.\n */\n\n#include \"../Refs.mqh\"\n#include \"../Util.h\"\n#include \"Frontend.h\"\n#include \"IndexBuffer.h\"\n#include \"Material.h\"\n#include \"Math.h\"\n#include \"Mesh.h\"\n#include \"Shader.h\"\n#include \"VertexBuffer.h\"\n\nenum GFX_DRAW_TEXT_FLAGS { GFX_DRAW_TEXT_FLAG_NONE, GFX_DRAW_TEXT_FLAG_2D_COORD_X, GFX_DRAW_TEXT_FLAG_2D_COORD_Y };\n\nenum ENUM_CLEAR_BUFFER_TYPE { CLEAR_BUFFER_TYPE_COLOR, CLEAR_BUFFER_TYPE_DEPTH };\n\n/**\n * Graphics device.\n */\nclass Device : public Dynamic {\n protected:\n  int context;\n  Ref<Frontend> frontend;\n  DXMatrix mtx_stack[];\n  DXMatrix mtx_world;\n  DXMatrix mtx_view;\n  DXMatrix mtx_projection;\n  DXVector3 lightdir;\n  Material material;\n\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Start(Frontend* _frontend) {\n    frontend = _frontend;\n    DXMatrixIdentity(mtx_world);\n    DXMatrixIdentity(mtx_view);\n    DXMatrixIdentity(mtx_projection);\n    TSR _identity;\n    PushTransform(_identity);\n    lightdir = DXVector3(-0.2f, 0.2f, 1.0f);\n    return Init(_frontend);\n  }\n\n  void PushTransform(const TSR& tsr) {\n    Util::ArrayPush(mtx_stack, mtx_world);\n    DXMatrixMultiply(mtx_world, tsr.ToMatrix(), mtx_world);\n  }\n\n  void PopTransform() { mtx_world = Util::ArrayPop(mtx_stack); }\n\n  /**\n   * Begins render loop.\n   */\n  Device* Begin(unsigned int clear_color = 0) {\n    frontend.Ptr().RenderBegin(context);\n    Clear(clear_color);\n    ClearDepth();\n    RenderBegin();\n    return &this;\n  }\n\n  /**\n   * Ends render loop.\n   */\n  Device* End() {\n    RenderEnd();\n    frontend.Ptr().RenderEnd(context);\n    frontend.Ptr().ProcessDrawText();\n    return &this;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  Device* Stop() {\n    Deinit();\n    return &this;\n  }\n\n  /**\n   * Clears scene's color buffer.\n   */\n  Device* Clear(unsigned int _color = 0xFF000000) {\n    ClearBuffer(CLEAR_BUFFER_TYPE_COLOR, _color);\n    return &this;\n  }\n\n  /**\n   * Begins scene's depth buffer.\n   */\n  Device* ClearDepth() {\n    ClearBuffer(CLEAR_BUFFER_TYPE_DEPTH, 0);\n    return &this;\n  }\n\n  /**\n   * Returns current material.\n   */\n  Material GetMaterial() { return material; }\n\n  /**\n   * Assigns material for later rendering.\n   */\n  void SetMaterial(Material& _material) { material = _material; }\n\n  /**\n   * Returns graphics device context as integer.\n   */\n  int Context() { return context; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[],\n                               string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") = NULL;\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  template <typename T>\n  VertexBuffer* VertexBuffer(T& data[]) {\n    VertexBuffer* _buff = VertexBuffer();\n    // Unfortunately we can't make this method virtual.\n    if (dynamic_cast<MTDXVertexBuffer*>(_buff) != NULL) {\n// MT5's DirectX.\n#ifdef __debug__\n      Print(\"Filling vertex buffer via MTDXVertexBuffer\");\n#endif\n      ((MTDXVertexBuffer*)_buff).Fill<T>(data);\n    } else {\n      Alert(\"Unsupported vertex buffer device target\");\n    }\n    return _buff;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  virtual VertexBuffer* VertexBuffer() = NULL;\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  void Render(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) { RenderBuffers(_vertices, _indices); }\n\n  /**\n   * Renders vertex buffer with optional point indices.\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) = NULL;\n\n  /**\n   * Renders given mesh.\n   */\n  template <typename T>\n  void Render(Mesh<T>* _mesh, Shader* _vs = NULL, Shader* _ps = NULL) {\n#ifdef __debug__\n    Print(\"Rendering mesh\");\n#endif\n    VertexBuffer* _vertices;\n    IndexBuffer* _indices;\n    _mesh.GetBuffers(&this, _vertices, _indices);\n\n    SetMaterial(_mesh.GetMaterial());\n\n    PushTransform(_mesh.GetTSR());\n\n    SetShader(_vs != NULL ? _vs : _mesh.GetShaderVS());\n    SetShader(_ps != NULL ? _ps : _mesh.GetShaderPS());\n\n    Render(_vertices, _indices);\n\n    PopTransform();\n  }\n\n  /**\n   * Activates shader for rendering.\n   */\n  void SetShader(Shader* _shader) { _shader.Select(); }\n\n  /**\n   * Activates shaders for rendering.\n   */\n  void SetShader(Shader* _shader1, Shader* _shader2) {\n    _shader1.Select();\n    _shader2.Select();\n  }\n\n  /**\n   * Returns front-end's viewport width.\n   */\n  int Width() { return frontend.Ptr().Width(); }\n\n  /**\n   * Returns front-end's viewport height.\n   */\n  int Height() { return frontend.Ptr().Height(); }\n\n  void SetCameraOrtho3D(float _pos_x = 0.0f, float _pos_y = 0.0f, float _pos_z = 0.0f) {\n    DXMatrixOrthoLH(mtx_projection, 1.0f * _pos_z, 1.0f / Width() * Height() * _pos_z, -10000, 10000);\n  }\n\n  DXMatrix GetWorldMatrix() { return mtx_world; }\n\n  void SetWorldMatrix(DXMatrix& _matrix) { mtx_world = _matrix; }\n\n  DXMatrix GetViewMatrix() { return mtx_view; }\n\n  void SetViewMatrix(DXMatrix& _matrix) { mtx_view = _matrix; }\n\n  DXMatrix GetProjectionMatrix() { return mtx_projection; }\n\n  void SetProjectionMatrix(DXMatrix& _matrix) { mtx_projection = _matrix; }\n\n  DXVector3 GetLightDirection() { return lightdir; }\n\n  void SetLightDirection(float x, float y, float z) {\n    lightdir.x = x;\n    lightdir.y = y;\n    lightdir.z = z;\n  }\n\n  /**\n   * Enqueues text to be drawn directly into the pixel buffer. Queue will be processed in the Device::End() method.\n   */\n  void DrawText(float _x, float _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0,\n                unsigned int _flags = 0) {\n    DViewport _viewport;\n    _viewport.x = 0;\n    _viewport.y = 0;\n    _viewport.width = frontend.Ptr().Width();\n    _viewport.height = frontend.Ptr().Height();\n    _viewport.minz = -10000.0f;\n    _viewport.maxz = 10000.0f;\n\n    DXVector3 _vec3_in(_x, _y, 0.0f);\n    DXVector3 _vec3_out;\n    DXVec3Project(_vec3_out, _vec3_in, _viewport, GetProjectionMatrix(), GetViewMatrix(), GetWorldMatrix());\n\n    if ((_flags & GFX_DRAW_TEXT_FLAG_2D_COORD_X) == GFX_DRAW_TEXT_FLAG_2D_COORD_X) {\n      _vec3_out.x = _x;\n    }\n\n    if ((_flags & GFX_DRAW_TEXT_FLAG_2D_COORD_Y) == GFX_DRAW_TEXT_FLAG_2D_COORD_Y) {\n      _vec3_out.y = _y;\n    }\n\n    frontend.Ptr().DrawText(_vec3_out.x, _vec3_out.y, _text, _color, _align);\n  }\n\n protected:\n  /**\n   * Initializes graphics device.\n   */\n  virtual bool Init(Frontend*) = NULL;\n\n  /**\n   * Deinitializes graphics device.\n   */\n  virtual bool Deinit() = NULL;\n\n  /**\n   * Starts rendering loop.\n   */\n  virtual bool RenderBegin() = NULL;\n\n  /**\n   * Ends rendering loop.\n   */\n  virtual bool RenderEnd() = NULL;\n\n  /**\n   * Clears color buffer.\n   */\n  virtual void ClearBuffer(ENUM_CLEAR_BUFFER_TYPE _type, unsigned int _color) = NULL;\n};\n"}, {"filename": "Chart3DType.h", "path": "new_knowledge/EA31337-classes-master/3D/Chart3DType.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart type renderer.\n */\n\n#include \"../Refs.mqh\"\n#include \"Device.h\"\n\nclass Chart3D;\nclass Device;\n\n/**\n * 3D chart type renderer.\n */\nclass Chart3DType : public Dynamic {\n protected:\n  Chart3D* chart3d;\n  Device* device;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DType(Chart3D* _chart3d, Device* _device) : chart3d(_chart3d), device(_device) {}\n\n  Device* GetDevice() { return device; }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {}\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart type renderer.\n */\n\n#include \"../Refs.mqh\"\n#include \"Device.h\"\n\nclass Chart3D;\nclass Device;\n\n/**\n * 3D chart type renderer.\n */\nclass Chart3DType : public Dynamic {\n protected:\n  Chart3D* chart3d;\n  Device* device;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DType(Chart3D* _chart3d, Device* _device) : chart3d(_chart3d), device(_device) {}\n\n  Device* GetDevice() { return device; }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {}\n};\n"}, {"filename": "Face.h", "path": "new_knowledge/EA31337-classes-master/3D/Face.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics face object.\n */\n\n#include \"Math.h\"\n\n// Face flags.\nenum ENUM_FACE_FLAGS { FACE_FLAGS_NONE, FACE_FLAGS_TRIANGLE, FACE_FLAGS_QUAD };\n\n// Face (3 or 4 vertices).\ntemplate <typename T>\nstruct Face {\n  // Flags.\n  ENUM_FACE_FLAGS flags;\n\n  // 3 or 4 points.\n  T points[4];\n\n  /**\n   * Constructor.\n   */\n  Face() { flags = FACE_FLAGS_NONE; }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {\n    flags = FACE_FLAGS_TRIANGLE;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n  }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4,\n       float z4) {\n    flags = FACE_FLAGS_QUAD;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n    points[3].Position.x = x4;\n    points[3].Position.y = y4;\n    points[3].Position.z = z4;\n  }\n\n  void UpdateNormal() {\n    DXVector3 _normal, _v1, _v2;\n\n    DXVec3Subtract(_v1, points[1].Position, points[0].Position);\n    DXVec3Subtract(_v2, points[2].Position, points[0].Position);\n\n    DXVec3Cross(_normal, _v1, _v2);\n    DXVec3Normalize(_normal, _normal);\n\n    for (int i = 0; i < 4; ++i) {\n      points[i].Normal = _normal;\n    }\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics face object.\n */\n\n#include \"Math.h\"\n\n// Face flags.\nenum ENUM_FACE_FLAGS { FACE_FLAGS_NONE, FACE_FLAGS_TRIANGLE, FACE_FLAGS_QUAD };\n\n// Face (3 or 4 vertices).\ntemplate <typename T>\nstruct Face {\n  // Flags.\n  ENUM_FACE_FLAGS flags;\n\n  // 3 or 4 points.\n  T points[4];\n\n  /**\n   * Constructor.\n   */\n  Face() { flags = FACE_FLAGS_NONE; }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3) {\n    flags = FACE_FLAGS_TRIANGLE;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n  }\n\n  /**\n   * Constructor.\n   */\n  Face(float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4,\n       float z4) {\n    flags = FACE_FLAGS_QUAD;\n    points[0].Position.x = x1;\n    points[0].Position.y = y1;\n    points[0].Position.z = z1;\n    points[1].Position.x = x2;\n    points[1].Position.y = y2;\n    points[1].Position.z = z2;\n    points[2].Position.x = x3;\n    points[2].Position.y = y3;\n    points[2].Position.z = z3;\n    points[3].Position.x = x4;\n    points[3].Position.y = y4;\n    points[3].Position.z = z4;\n  }\n\n  void UpdateNormal() {\n    DXVector3 _normal, _v1, _v2;\n\n    DXVec3Subtract(_v1, points[1].Position, points[0].Position);\n    DXVec3Subtract(_v2, points[2].Position, points[0].Position);\n\n    DXVec3Cross(_normal, _v1, _v2);\n    DXVec3Normalize(_normal, _normal);\n\n    for (int i = 0; i < 4; ++i) {\n      points[i].Normal = _normal;\n    }\n  }\n};\n"}, {"filename": "Interface.h", "path": "new_knowledge/EA31337-classes-master/3D/Interface.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Chart events.\n */\n\n#include \"../Util.h\"\n\nenum ENUM_INTERFACE_EVENT {\n  INTERFACE_EVENT_NONE,\n  INTERFACE_EVENT_MOUSE_MOVE,\n  INTERFACE_EVENT_MOUSE_DOWN,\n  INTERFACE_EVENT_MOUSE_UP\n};\n\nstruct InterfaceEvent {\n  ENUM_INTERFACE_EVENT type;\n  struct EventMouse {\n    int x;\n    int y;\n    datetime dt;\n  };\n\n  union EventData {\n    EventMouse mouse;\n  } data;\n};\n\n#ifdef __MQL5__\n/**\n * \"OnChart\" event handler function (MQL5 only).\n *\n * Invoked when the ChartEvent event occurs.\n */\nvoid OnChartEvent(const int id, const long& lparam, const double& dparam, const string& sparam) {\n  datetime _dt;\n  double _mp;\n  int _window = 0;\n  InterfaceEvent _event;\n\n  if (id == CHART_EVENT_MOUSE_MOVE) {\n    Interface::mouse_pos_x = (int)lparam;\n    Interface::mouse_pos_y = (int)dparam;\n    ChartXYToTimePrice(0, Interface::mouse_pos_x, Interface::mouse_pos_y, _window, _dt, _mp);\n    _event.type = INTERFACE_EVENT_MOUSE_MOVE;\n    _event.data.mouse.x = Interface::mouse_pos_x;\n    _event.data.mouse.y = Interface::mouse_pos_y;\n    Interface::FireEvent(_event);\n  }\n}\n#endif\n\ntypedef void (*InterfaceListener)(InterfaceEvent&, void*);\n\nclass Interface {\n public:\n  struct Installation {\n    InterfaceListener listener;\n    void* target;\n  };\n\n  static Installation installations[];\n\n  static bool mouse_was_down;\n  static int mouse_pos_x;\n  static int mouse_pos_y;\n  static bool initialized;\n\n#ifdef __MQL5__\n  static void AddListener(InterfaceListener _listener, void* _target) {\n    if (!initialized) {\n      ChartSetInteger(0, CHART_EVENT_MOUSE_MOVE, true);\n      ChartRedraw();\n      initialized = true;\n    }\n\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      if (installations[i].listener == _listener) {\n        // Listener already added.\n        return;\n      }\n    }\n\n    Installation _installation;\n    _installation.listener = _listener;\n    _installation.target = _target;\n\n    Util::ArrayPush(installations, _installation);\n  }\n\n  static void FireEvent(InterfaceEvent& _event) {\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      Installation _installation = installations[i];\n      _installation.listener(_event, _installation.target);\n    }\n  }\n\n  static int GetMouseX() { return mouse_pos_x; }\n\n  static int GetMouseY() { return mouse_pos_y; }\n#endif\n};\n\n#ifdef __MQL5__\nInterface::Installation Interface::installations[];\nbool Interface::mouse_was_down = false;\nint Interface::mouse_pos_x = 0;\nint Interface::mouse_pos_y = 0;\nbool Interface::initialized = false;\n#endif\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Chart events.\n */\n\n#include \"../Util.h\"\n\nenum ENUM_INTERFACE_EVENT {\n  INTERFACE_EVENT_NONE,\n  INTERFACE_EVENT_MOUSE_MOVE,\n  INTERFACE_EVENT_MOUSE_DOWN,\n  INTERFACE_EVENT_MOUSE_UP\n};\n\nstruct InterfaceEvent {\n  ENUM_INTERFACE_EVENT type;\n  struct EventMouse {\n    int x;\n    int y;\n    datetime dt;\n  };\n\n  union EventData {\n    EventMouse mouse;\n  } data;\n};\n\n#ifdef __MQL5__\n/**\n * \"OnChart\" event handler function (MQL5 only).\n *\n * Invoked when the ChartEvent event occurs.\n */\nvoid OnChartEvent(const int id, const long& lparam, const double& dparam, const string& sparam) {\n  datetime _dt;\n  double _mp;\n  int _window = 0;\n  InterfaceEvent _event;\n\n  if (id == CHART_EVENT_MOUSE_MOVE) {\n    Interface::mouse_pos_x = (int)lparam;\n    Interface::mouse_pos_y = (int)dparam;\n    ChartXYToTimePrice(0, Interface::mouse_pos_x, Interface::mouse_pos_y, _window, _dt, _mp);\n    _event.type = INTERFACE_EVENT_MOUSE_MOVE;\n    _event.data.mouse.x = Interface::mouse_pos_x;\n    _event.data.mouse.y = Interface::mouse_pos_y;\n    Interface::FireEvent(_event);\n  }\n}\n#endif\n\ntypedef void (*InterfaceListener)(InterfaceEvent&, void*);\n\nclass Interface {\n public:\n  struct Installation {\n    InterfaceListener listener;\n    void* target;\n  };\n\n  static Installation installations[];\n\n  static bool mouse_was_down;\n  static int mouse_pos_x;\n  static int mouse_pos_y;\n  static bool initialized;\n\n#ifdef __MQL5__\n  static void AddListener(InterfaceListener _listener, void* _target) {\n    if (!initialized) {\n      ChartSetInteger(0, CHART_EVENT_MOUSE_MOVE, true);\n      ChartRedraw();\n      initialized = true;\n    }\n\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      if (installations[i].listener == _listener) {\n        // Listener already added.\n        return;\n      }\n    }\n\n    Installation _installation;\n    _installation.listener = _listener;\n    _installation.target = _target;\n\n    Util::ArrayPush(installations, _installation);\n  }\n\n  static void FireEvent(InterfaceEvent& _event) {\n    for (int i = 0; i < ArraySize(installations); ++i) {\n      Installation _installation = installations[i];\n      _installation.listener(_event, _installation.target);\n    }\n  }\n\n  static int GetMouseX() { return mouse_pos_x; }\n\n  static int GetMouseY() { return mouse_pos_y; }\n#endif\n};\n\n#ifdef __MQL5__\nInterface::Installation Interface::installations[];\nbool Interface::mouse_was_down = false;\nint Interface::mouse_pos_x = 0;\nint Interface::mouse_pos_y = 0;\nbool Interface::initialized = false;\n#endif\n"}, {"filename": "IndexBuffer.h", "path": "new_knowledge/EA31337-classes-master/3D/IndexBuffer.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics index buffer.\n */\n\n#include \"../Refs.mqh\"\n\nclass Device;\n\n/**\n * Vertices' index buffer.\n */\nclass IndexBuffer : public Dynamic {\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  IndexBuffer(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) = NULL;\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() = NULL;\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics index buffer.\n */\n\n#include \"../Refs.mqh\"\n\nclass Device;\n\n/**\n * Vertices' index buffer.\n */\nclass IndexBuffer : public Dynamic {\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  IndexBuffer(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) = NULL;\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) = NULL;\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() = NULL;\n};\n"}, {"filename": "Vertex.h", "path": "new_knowledge/EA31337-classes-master/3D/Vertex.h", "content": "#include \"../Refs.mqh\"\n\n/**\n * Generic vertex to be used by meshes.\n */\nstruct Vertex {\n  DXVector3 Position;\n  DXVector3 Normal;\n  DXColor Color;\n\n  Vertex() {\n    Color.r = 1.0f;\n    Color.g = 1.0f;\n    Color.b = 1.0f;\n    Color.a = 1.0f;\n  }\n\n  static const ShaderVertexLayout Layout[3];\n};\n\nconst ShaderVertexLayout Vertex::Layout[3] = {\n    {\"POSITION\", 0, GFX_VAR_TYPE_FLOAT, 3, false, sizeof(Vertex), 0},\n    {\"NORMAL\", 0, GFX_VAR_TYPE_FLOAT, 3, false, sizeof(Vertex), sizeof(float) * 3},\n    {\"COLOR\", 0, GFX_VAR_TYPE_FLOAT, 4, false, sizeof(Vertex), sizeof(float) * 6}};\n", "search_content": "#include \"../Refs.mqh\"\n\n/**\n * Generic vertex to be used by meshes.\n */\nstruct Vertex {\n  DXVector3 Position;\n  DXVector3 Normal;\n  DXColor Color;\n\n  Vertex() {\n    Color.r = 1.0f;\n    Color.g = 1.0f;\n    Color.b = 1.0f;\n    Color.a = 1.0f;\n  }\n\n  static const ShaderVertexLayout Layout[3];\n};\n\nconst ShaderVertexLayout Vertex::Layout[3] = {\n    {\"POSITION\", 0, GFX_VAR_TYPE_FLOAT, 3, false, sizeof(Vertex), 0},\n    {\"NORMAL\", 0, GFX_VAR_TYPE_FLOAT, 3, false, sizeof(Vertex), sizeof(float) * 3},\n    {\"COLOR\", 0, GFX_VAR_TYPE_FLOAT, 4, false, sizeof(Vertex), sizeof(float) * 6}};\n"}, {"filename": "Chart3D.h", "path": "new_knowledge/EA31337-classes-master/3D/Chart3D.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D Chart.\n */\n\n#include \"../Bar.struct.h\"\n#include \"../Indicators/Indi_MA.mqh\"\n#include \"../Instances.h\"\n#include \"../Refs.mqh\"\n#include \"../SerializerConverter.mqh\"\n#include \"../SerializerJson.mqh\"\n#include \"Chart3DCandles.h\"\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Interface.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/chart3d_vs.hlsl\" as string Chart3DShaderSourceVS;\n#resource \"Shaders/chart3d_ps.hlsl\" as string Chart3DShaderSourcePS;\n#endif\n\ntypedef BarOHLC (*Chart3DPriceFetcher)(ENUM_TIMEFRAMES, int);\n\n// Type of the currently rendered 3d chart.\nenum ENUM_CHART3D_TYPE {\n  CHART3D_TYPE_BARS,\n  CHART3D_TYPE_CANDLES,\n  CHART3D_TYPE_LINES,\n};\n\nclass Chart3D;\n\nvoid chart3d_interface_listener(InterfaceEvent& _event, void* _target) {\n  Chart3D* chart3d = (Chart3D*)_target;\n  chart3d.OnInterfaceEvent(_event);\n}\n\n/**\n * 3D chart renderer.\n */\nclass Chart3D : public Dynamic {\n  // Camera offset. Z component indicates number of bars per screen's width.\n  DXVector3 offset;\n\n  // Current chart type.\n  ENUM_CHART3D_TYPE type;\n\n  // References to chart type renderers.\n  Ref<Chart3DType> renderers[3];\n\n  // OHLC prices fetcher callback.\n  Chart3DPriceFetcher price_fetcher;\n\n  // Whether graphics were initialized.\n  bool initialized;\n\n  // Shaders.\n  Ref<Shader> shader_vs;\n  Ref<Shader> shader_ps;\n\n  Chart3DType* current_renderer;\n\n  Instances<Chart3D> instances;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3D(Chart3DPriceFetcher _price_fetcher, ENUM_CHART3D_TYPE _type = CHART3D_TYPE_CANDLES) : instances(&this) {\n    price_fetcher = _price_fetcher;\n    type = _type;\n    offset.x = offset.y = 0.0f;\n    offset.z = 25.0f;\n    initialized = false;\n#ifdef __MQL5__\n    Interface::AddListener(chart3d_interface_listener, &this);\n#endif\n  }\n\n  void OnInterfaceEvent(InterfaceEvent& _event) {\n    if (GetCurrentRenderer() == NULL) {\n      return;\n    }\n\n    Device* _gfx = GetCurrentRenderer().GetDevice();\n\n    _gfx.DrawText(10, 10, \"Event!\");\n  }\n\n  Shader* GetShaderVS() { return shader_vs.Ptr(); }\n\n  Shader* GetShaderPS() { return shader_ps.Ptr(); }\n\n  Chart3DType* GetCurrentRenderer() { return current_renderer; }\n\n  Chart3DType* GetRenderer(Device* _device) {\n    if (!initialized) {\n      // shader_vs = _device.VertexShader(Chart3DShaderSourceVS, Vertex::Layout);\n      // shader_ps = _device.PixelShader(Chart3DShaderSourcePS);\n      initialized = true;\n    }\n\n    if (!renderers[type].IsSet()) {\n      switch (type) {\n        case CHART3D_TYPE_BARS:\n          // renderers[type] = new Chart3DBars(_device);\n          break;\n        case CHART3D_TYPE_CANDLES:\n          renderers[type] = new Chart3DCandles(&this, _device);\n          break;\n        case CHART3D_TYPE_LINES:\n          // renderers[type] = new Chart3DLines(_device);\n          break;\n        default:\n          Alert(\"Internal error: Wrong type for Chart3D in Chart3D::GetRenderer()!\");\n          DebugBreak();\n          return NULL;\n      }\n    }\n\n    current_renderer = renderers[type].Ptr();\n\n    return renderers[type].Ptr();\n  }\n\n  /**\n   * Returns given bar's OHLC.\n   */\n  BarOHLC GetPrice(ENUM_TIMEFRAMES _tf, int _shift) {\n    BarOHLC _ohlc;\n    return _ohlc;\n    // return price_fetcher(_tf, _shift); // @fixme: 'price_fetcher' - internal error #%d\n  }\n\n  /**\n   * Return first shift that are visible on the screen. Values is away from 0.\n   */\n  int GetBarsVisibleShiftStart() { return 80; }\n\n  /**\n   * Return last shift that are visible on the screen. Value is closer to 0.\n   */\n  int GetBarsVisibleShiftEnd() { return 0; }\n\n  /**\n   * Returns lowest price of bars on the screen.\n   */\n  float GetMinBarsPrice() {\n    return (float)ChartStatic::iLow(\n        Symbol(), PERIOD_CURRENT,\n        ChartStatic::iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd(),\n                             GetBarsVisibleShiftEnd()));\n  }\n\n  /**\n   * Returns highest price of bars on the screen.\n   */\n  float GetMaxBarsPrice() {\n    return (float)ChartStatic::iHigh(\n        Symbol(), PERIOD_CURRENT,\n        ChartStatic::iHighest(Symbol(), PERIOD_CURRENT, MODE_HIGH,\n                              GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd(), GetBarsVisibleShiftEnd()));\n  }\n\n  /**\n   * Returns number of bars that are visible on te screen.\n   */\n  int GetBarsVisibleCount() { return GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd() + 1; }\n\n  /**\n   * Returns absolute x coordinate of bar on the screen. Must not be affected by camera's x offset.\n   */\n  float GetBarPositionX(int _shift) { return -(float)GetBarsVisibleCount() * 1.35f / 2.0f + 1.35f * _shift; }\n\n  /**\n   * Returns y coordinate of price on the screen. Takes into consideration zoom and min/max prices on the screen.\n   */\n  float GetPriceScale(float price) {\n    float _scale_y = 40.0f;\n    float _price_min = GetMinBarsPrice();\n    float _price_max = GetMaxBarsPrice();\n    float _result = 1.0f / (_price_max - _price_min) * (price - _price_min) * _scale_y - (_scale_y / 2);\n    return _result;\n  }\n\n  /**\n   * Renders chart.\n   */\n  void Render(Device* _device) {\n    Chart3DType* _type_renderer = GetRenderer(_device);\n\n    BarOHLC _ohlc;\n    // BarOHLC _ohlc = price_fetcher(PERIOD_CURRENT, 0);  // @fixme: 'price_fetcher' - internal error #%d\n\n#ifdef __debug__\n    Print(SerializerConverter::FromObject(_ohlc).ToString<SerializerJson>());\n#endif\n\n    _type_renderer.Render(_device);\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D Chart.\n */\n\n#include \"../Bar.struct.h\"\n#include \"../Indicators/Indi_MA.mqh\"\n#include \"../Instances.h\"\n#include \"../Refs.mqh\"\n#include \"../SerializerConverter.mqh\"\n#include \"../SerializerJson.mqh\"\n#include \"Chart3DCandles.h\"\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Interface.h\"\n\n#ifdef __MQL5__\n// Resource variables.\n#resource \"Shaders/chart3d_vs.hlsl\" as string Chart3DShaderSourceVS;\n#resource \"Shaders/chart3d_ps.hlsl\" as string Chart3DShaderSourcePS;\n#endif\n\ntypedef BarOHLC (*Chart3DPriceFetcher)(ENUM_TIMEFRAMES, int);\n\n// Type of the currently rendered 3d chart.\nenum ENUM_CHART3D_TYPE {\n  CHART3D_TYPE_BARS,\n  CHART3D_TYPE_CANDLES,\n  CHART3D_TYPE_LINES,\n};\n\nclass Chart3D;\n\nvoid chart3d_interface_listener(InterfaceEvent& _event, void* _target) {\n  Chart3D* chart3d = (Chart3D*)_target;\n  chart3d.OnInterfaceEvent(_event);\n}\n\n/**\n * 3D chart renderer.\n */\nclass Chart3D : public Dynamic {\n  // Camera offset. Z component indicates number of bars per screen's width.\n  DXVector3 offset;\n\n  // Current chart type.\n  ENUM_CHART3D_TYPE type;\n\n  // References to chart type renderers.\n  Ref<Chart3DType> renderers[3];\n\n  // OHLC prices fetcher callback.\n  Chart3DPriceFetcher price_fetcher;\n\n  // Whether graphics were initialized.\n  bool initialized;\n\n  // Shaders.\n  Ref<Shader> shader_vs;\n  Ref<Shader> shader_ps;\n\n  Chart3DType* current_renderer;\n\n  Instances<Chart3D> instances;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3D(Chart3DPriceFetcher _price_fetcher, ENUM_CHART3D_TYPE _type = CHART3D_TYPE_CANDLES) : instances(&this) {\n    price_fetcher = _price_fetcher;\n    type = _type;\n    offset.x = offset.y = 0.0f;\n    offset.z = 25.0f;\n    initialized = false;\n#ifdef __MQL5__\n    Interface::AddListener(chart3d_interface_listener, &this);\n#endif\n  }\n\n  void OnInterfaceEvent(InterfaceEvent& _event) {\n    if (GetCurrentRenderer() == NULL) {\n      return;\n    }\n\n    Device* _gfx = GetCurrentRenderer().GetDevice();\n\n    _gfx.DrawText(10, 10, \"Event!\");\n  }\n\n  Shader* GetShaderVS() { return shader_vs.Ptr(); }\n\n  Shader* GetShaderPS() { return shader_ps.Ptr(); }\n\n  Chart3DType* GetCurrentRenderer() { return current_renderer; }\n\n  Chart3DType* GetRenderer(Device* _device) {\n    if (!initialized) {\n      // shader_vs = _device.VertexShader(Chart3DShaderSourceVS, Vertex::Layout);\n      // shader_ps = _device.PixelShader(Chart3DShaderSourcePS);\n      initialized = true;\n    }\n\n    if (!renderers[type].IsSet()) {\n      switch (type) {\n        case CHART3D_TYPE_BARS:\n          // renderers[type] = new Chart3DBars(_device);\n          break;\n        case CHART3D_TYPE_CANDLES:\n          renderers[type] = new Chart3DCandles(&this, _device);\n          break;\n        case CHART3D_TYPE_LINES:\n          // renderers[type] = new Chart3DLines(_device);\n          break;\n        default:\n          Alert(\"Internal error: Wrong type for Chart3D in Chart3D::GetRenderer()!\");\n          DebugBreak();\n          return NULL;\n      }\n    }\n\n    current_renderer = renderers[type].Ptr();\n\n    return renderers[type].Ptr();\n  }\n\n  /**\n   * Returns given bar's OHLC.\n   */\n  BarOHLC GetPrice(ENUM_TIMEFRAMES _tf, int _shift) {\n    BarOHLC _ohlc;\n    return _ohlc;\n    // return price_fetcher(_tf, _shift); // @fixme: 'price_fetcher' - internal error #%d\n  }\n\n  /**\n   * Return first shift that are visible on the screen. Values is away from 0.\n   */\n  int GetBarsVisibleShiftStart() { return 80; }\n\n  /**\n   * Return last shift that are visible on the screen. Value is closer to 0.\n   */\n  int GetBarsVisibleShiftEnd() { return 0; }\n\n  /**\n   * Returns lowest price of bars on the screen.\n   */\n  float GetMinBarsPrice() {\n    return (float)ChartStatic::iLow(\n        Symbol(), PERIOD_CURRENT,\n        ChartStatic::iLowest(Symbol(), PERIOD_CURRENT, MODE_LOW, GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd(),\n                             GetBarsVisibleShiftEnd()));\n  }\n\n  /**\n   * Returns highest price of bars on the screen.\n   */\n  float GetMaxBarsPrice() {\n    return (float)ChartStatic::iHigh(\n        Symbol(), PERIOD_CURRENT,\n        ChartStatic::iHighest(Symbol(), PERIOD_CURRENT, MODE_HIGH,\n                              GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd(), GetBarsVisibleShiftEnd()));\n  }\n\n  /**\n   * Returns number of bars that are visible on te screen.\n   */\n  int GetBarsVisibleCount() { return GetBarsVisibleShiftStart() - GetBarsVisibleShiftEnd() + 1; }\n\n  /**\n   * Returns absolute x coordinate of bar on the screen. Must not be affected by camera's x offset.\n   */\n  float GetBarPositionX(int _shift) { return -(float)GetBarsVisibleCount() * 1.35f / 2.0f + 1.35f * _shift; }\n\n  /**\n   * Returns y coordinate of price on the screen. Takes into consideration zoom and min/max prices on the screen.\n   */\n  float GetPriceScale(float price) {\n    float _scale_y = 40.0f;\n    float _price_min = GetMinBarsPrice();\n    float _price_max = GetMaxBarsPrice();\n    float _result = 1.0f / (_price_max - _price_min) * (price - _price_min) * _scale_y - (_scale_y / 2);\n    return _result;\n  }\n\n  /**\n   * Renders chart.\n   */\n  void Render(Device* _device) {\n    Chart3DType* _type_renderer = GetRenderer(_device);\n\n    BarOHLC _ohlc;\n    // BarOHLC _ohlc = price_fetcher(PERIOD_CURRENT, 0);  // @fixme: 'price_fetcher' - internal error #%d\n\n#ifdef __debug__\n    Print(SerializerConverter::FromObject(_ohlc).ToString<SerializerJson>());\n#endif\n\n    _type_renderer.Render(_device);\n  }\n};\n"}, {"filename": "TSR.h", "path": "new_knowledge/EA31337-classes-master/3D/TSR.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Translations, scale and rotation matrices.\n */\n\n#include \"Math.h\"\n\nclass TSR {\n public:\n  DXVector3 translation;\n  DXVector3 scale;\n  DXVector3 rotation;\n\n  TSR() {\n    translation.x = translation.y = translation.z = 0.0f;\n    scale.x = scale.y = scale.z = 1.0f;\n    rotation.x = rotation.y = rotation.z = 0.0f;\n  }\n\n  DXMatrix ToMatrix() const {\n    DXMatrix _mtx_translation = {};\n    DXMatrix _mtx_scale = {};\n    DXMatrix _mtx_rotation_1 = {};\n    DXMatrix _mtx_rotation_2 = {};\n    DXMatrix _mtx_result = {};\n\n    DXMatrixTranslation(_mtx_translation, translation.x, translation.y, translation.z);\n    DXMatrixScaling(_mtx_scale, scale.x, scale.y, scale.z);\n    DXMatrixRotationYawPitchRoll(_mtx_rotation_1, rotation.x, 0, rotation.z);\n    DXMatrixRotationYawPitchRoll(_mtx_rotation_2, 0, rotation.y, 0);\n\n    DXMatrixIdentity(_mtx_result);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_rotation_1);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_rotation_2);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_scale);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_translation);\n\n    return _mtx_result;\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Translations, scale and rotation matrices.\n */\n\n#include \"Math.h\"\n\nclass TSR {\n public:\n  DXVector3 translation;\n  DXVector3 scale;\n  DXVector3 rotation;\n\n  TSR() {\n    translation.x = translation.y = translation.z = 0.0f;\n    scale.x = scale.y = scale.z = 1.0f;\n    rotation.x = rotation.y = rotation.z = 0.0f;\n  }\n\n  DXMatrix ToMatrix() const {\n    DXMatrix _mtx_translation = {};\n    DXMatrix _mtx_scale = {};\n    DXMatrix _mtx_rotation_1 = {};\n    DXMatrix _mtx_rotation_2 = {};\n    DXMatrix _mtx_result = {};\n\n    DXMatrixTranslation(_mtx_translation, translation.x, translation.y, translation.z);\n    DXMatrixScaling(_mtx_scale, scale.x, scale.y, scale.z);\n    DXMatrixRotationYawPitchRoll(_mtx_rotation_1, rotation.x, 0, rotation.z);\n    DXMatrixRotationYawPitchRoll(_mtx_rotation_2, 0, rotation.y, 0);\n\n    DXMatrixIdentity(_mtx_result);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_rotation_1);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_rotation_2);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_scale);\n    DXMatrixMultiply(_mtx_result, _mtx_result, _mtx_translation);\n\n    return _mtx_result;\n  }\n};\n"}, {"filename": "Shader.h", "path": "new_knowledge/EA31337-classes-master/3D/Shader.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics shader.\n */\n\n#include \"../Refs.mqh\"\n\n// Shader type.\nenum ENUM_SHADER_TYPE {\n  SHADER_TYPE_VS,\n  SHADER_TYPE_PS,\n};\n\nclass Device;\nclass MTDXShader;\n\nenum ENUM_GFX_VAR_TYPE_FLOAT { GFX_VAR_TYPE_INT32, GFX_VAR_TYPE_FLOAT };\n\n// Note that shader buffers's size must be multiple of 4!\nstruct MVPBuffer {\n  DXMatrix world;\n  DXMatrix view;\n  DXMatrix projection;\n  DXVector3 lightdir;\n\n private:\n  float _unused1;\n\n public:\n  DXColor mat_color;\n\n private:\n  // char _unused2[1];\n};\n\n// Vertex layout used for Vertex Shaders.\nstruct ShaderVertexLayout {\n  string name;\n  unsigned int index;\n  ENUM_GFX_VAR_TYPE_FLOAT type;\n  unsigned int num_components;\n  bool clamped;\n  unsigned int stride;\n  unsigned int offset;\n};\n\n/**\n * Unified vertex/pixel shader.\n */\nclass Shader : public Dynamic {\n  // Reference to graphics device.\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  Shader(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  /**\n   * Sets custom input buffer for shader.\n   */\n  template <typename X>\n  void SetCBuffer(const X& data) {\n    // Unfortunately we can't make this method virtual.\n    if (dynamic_cast<MTDXShader*>(&this) != NULL) {\n// MT5's DirectX.\n#ifdef __debug__\n      Print(\"Setting CBuffer data for MT5\");\n#endif\n      ((MTDXShader*)&this).SetCBuffer(data);\n    } else {\n      Alert(\"Unsupported cbuffer device target\");\n    }\n  }\n\n  /**\n   * Selectes shader to be used by graphics device for rendering.\n   */\n  virtual void Select() = NULL;\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics shader.\n */\n\n#include \"../Refs.mqh\"\n\n// Shader type.\nenum ENUM_SHADER_TYPE {\n  SHADER_TYPE_VS,\n  SHADER_TYPE_PS,\n};\n\nclass Device;\nclass MTDXShader;\n\nenum ENUM_GFX_VAR_TYPE_FLOAT { GFX_VAR_TYPE_INT32, GFX_VAR_TYPE_FLOAT };\n\n// Note that shader buffers's size must be multiple of 4!\nstruct MVPBuffer {\n  DXMatrix world;\n  DXMatrix view;\n  DXMatrix projection;\n  DXVector3 lightdir;\n\n private:\n  float _unused1;\n\n public:\n  DXColor mat_color;\n\n private:\n  // char _unused2[1];\n};\n\n// Vertex layout used for Vertex Shaders.\nstruct ShaderVertexLayout {\n  string name;\n  unsigned int index;\n  ENUM_GFX_VAR_TYPE_FLOAT type;\n  unsigned int num_components;\n  bool clamped;\n  unsigned int stride;\n  unsigned int offset;\n};\n\n/**\n * Unified vertex/pixel shader.\n */\nclass Shader : public Dynamic {\n  // Reference to graphics device.\n  WeakRef<Device> device;\n\n public:\n  /**\n   * Constructor.\n   */\n  Shader(Device* _device) { device = _device; }\n\n  /**\n   * Returns base graphics device.\n   */\n  Device* GetDevice() { return device.Ptr(); }\n\n  /**\n   * Sets custom input buffer for shader.\n   */\n  template <typename X>\n  void SetCBuffer(const X& data) {\n    // Unfortunately we can't make this method virtual.\n    if (dynamic_cast<MTDXShader*>(&this) != NULL) {\n// MT5's DirectX.\n#ifdef __debug__\n      Print(\"Setting CBuffer data for MT5\");\n#endif\n      ((MTDXShader*)&this).SetCBuffer(data);\n    } else {\n      Alert(\"Unsupported cbuffer device target\");\n    }\n  }\n\n  /**\n   * Selectes shader to be used by graphics device for rendering.\n   */\n  virtual void Select() = NULL;\n};\n"}, {"filename": "Math.h", "path": "new_knowledge/EA31337-classes-master/3D/Math.h", "content": "//+------------------------------------------------------------------+\n//|                                                       DXMath.mqh |\n//|                        Copyright 2019,MetaQuotes Software Corp. |\n//|                                             https://www.mql5.com |\n//+------------------------------------------------------------------+\n#property copyright \"Copyright 2019,MetaQuotes Software Corp.\"\n#property link \"https://www.mql5.com\"\n//+------------------------------------------------------------------+\n//| DirectX Math Routines                                            |\n//+------------------------------------------------------------------+\n//| Ported from C++ code of ReactOS, written by David Adam           |\n//| and Tony Wasserka                                                |\n//|                                                                  |\n//| https://doxygen.reactos.org/de/d57/                              |\n//| dll_2directx_2wine_2d3dx9__36_2math_8c_source.html               |\n//|                                                                  |\n//| Copyright (C) 2007 David Adam                                    |\n//| Copyright (C) 2007 Tony Wasserka                                 |\n//+------------------------------------------------------------------+\n#define DX_PI 3.1415926535897932384626f\n#define DX_PI_DIV2 1.5707963267948966192313f\n#define DX_PI_DIV3 1.0471975511965977461542f\n#define DX_PI_DIV4 0.7853981633974483096156f\n#define DX_PI_DIV6 0.5235987755982988730771f\n#define DX_PI_MUL2 6.2831853071795864769253f\n#define DXSH_MINORDER 2\n#define DXSH_MAXORDER 6\n//+------------------------------------------------------------------+\n//| Preliminary declarations                                         |\n//+------------------------------------------------------------------+\n//+------------------------------------------------------------------+\n//| DXColor                                                          |\n//+------------------------------------------------------------------+\nstruct DXColor;\nstruct DXPlane;\nstruct DXVector2;\nstruct DXVector3;\nstruct DXVector4;\nstruct DXMatrix;\nstruct DXQuaternion;\nstruct DViewport;\n//+------------------------------------------------------------------+\n//| DXColor                                                          |\n//+------------------------------------------------------------------+\nstruct DXColor {\n  float r;\n  float g;\n  float b;\n  float a;\n  //--- constructors\n  DXColor(void) {\n    r = 0.0;\n    g = 0.0;\n    b = 0.0;\n    a = 1.0;\n  }\n  DXColor(float red, float green, float blue, float alpha) {\n    r = red;\n    g = green;\n    b = blue;\n    a = alpha;\n  }\n  DXColor(const DXVector4 &v) {\n    r = v.x;\n    g = v.y;\n    b = v.z;\n    a = v.w;\n  }\n  DXColor(const DXVector3 &v) {\n    r = v.x;\n    g = v.y;\n    b = v.z;\n    a = 1.0;\n  }\n  DXColor(unsigned int _color) {\n    a = 1.0f / 255.0f * ((_color & 0xFF000000) >> 24);\n    r = 1.0f / 255.0f * ((_color & 0x00FF0000) >> 16);\n    g = 1.0f / 255.0f * ((_color & 0x0000FF00) >> 8);\n    b = 1.0f / 255.0f * ((_color & 0x000000FF) >> 0);\n  }\n};\n//+------------------------------------------------------------------+\n//| DXPlane                                                          |\n//+------------------------------------------------------------------+\nstruct DXPlane {\n  float a;\n  float b;\n  float c;\n  float d;\n};\n//+------------------------------------------------------------------+\n//| DXVector2                                                        |\n//+------------------------------------------------------------------+\nstruct DXVector2 {\n  float x;\n  float y;\n  //--- constructors\n  DXVector2(void) {\n    x = 0.0;\n    y = 0.0;\n  }\n  DXVector2(float v) {\n    x = v;\n    y = v;\n  }\n  DXVector2(float vx, float vy) {\n    x = vx;\n    y = vy;\n  }\n  DXVector2(const DXVector3 &v) {\n    x = v.x;\n    y = v.y;\n  }\n  DXVector2(const DXVector4 &v) {\n    x = v.x;\n    y = v.y;\n  }\n};\n//+------------------------------------------------------------------+\n//| DXVector3                                                        |\n//+------------------------------------------------------------------+\nstruct DXVector3 {\n  float x;\n  float y;\n  float z;\n  //--- constructors\n  DXVector3(void) {\n    x = 0.0;\n    y = 0.0;\n    z = 0.0;\n  }\n  DXVector3(float v) {\n    x = v;\n    y = v;\n    z = v;\n  }\n  DXVector3(float vx, float vy, float vz) {\n    x = vx;\n    y = vy;\n    z = vz;\n  }\n  DXVector3(const DXVector2 &v) {\n    x = v.x;\n    y = v.y;\n    z = 0.0;\n  }\n  DXVector3(const DXVector4 &v) {\n    x = v.x;\n    y = v.y;\n    z = v.z;\n  }\n};\n//+------------------------------------------------------------------+\n//| DXVector4                                                        |\n//+------------------------------------------------------------------+\nstruct DXVector4 {\n  float x;\n  float y;\n  float z;\n  float w;\n  //--- constructors\n  DXVector4(void) {\n    x = 0.0;\n    y = 0.0;\n    z = 0.0;\n    w = 1.0;\n  }\n  DXVector4(float v) {\n    x = v;\n    y = v;\n    z = v;\n    w = v;\n  }\n  DXVector4(float vx, float vy, float vz, float vw) {\n    x = vx;\n    y = vy;\n    z = vz;\n    w = vw;\n  }\n  DXVector4(const DXVector2 &v) {\n    x = v.x;\n    y = v.y;\n    z = 0.0;\n    w = 1.0;\n  }\n  DXVector4(const DXVector3 &v) {\n    x = v.x;\n    y = v.y;\n    z = v.z;\n    w = 1.0;\n  }\n};\n//+------------------------------------------------------------------+\n//| DXMatrix                                                         |\n//+------------------------------------------------------------------+\nstruct DXMatrix {\n  float m[4][4];\n};\n//+------------------------------------------------------------------+\n//| DXQuaternion                                                     |\n//+------------------------------------------------------------------+\nstruct DXQuaternion {\n  float x;\n  float y;\n  float z;\n  float w;\n};\n//+------------------------------------------------------------------+\n//| DViewport                                                        |\n//+------------------------------------------------------------------+\nstruct DViewport {\n  unsigned long x;\n  unsigned long y;\n  unsigned long width;\n  unsigned long height;\n  float minz;\n  float maxz;\n};\n\n/*\n//--- DXColor functions\nvoid  DXColorAdd(DXColor &pout,const DXColor &pc1,const DXColor &pc2);\nvoid  DXColorAdjustContrast(DXColor &pout,const DXColor &pc,float s);\nvoid  DXColorAdjustSaturation(DXColor &pout,const DXColor &pc,float s);\nvoid  DXColorLerp(DXColor &pout,const DXColor &pc1,const DXColor &pc2,float s);\nvoid  DXColorModulate(DXColor &pout,const DXColor &pc1,const DXColor &pc2);\nvoid  DXColorNegative(DXColor &pout,const DXColor &pc);\nvoid  DXColorScale(DXColor &pout,const DXColor &pc,float s);\nvoid  DXColorSubtract(DXColor &pout,const DXColor &pc1,const DXColor &pc2);\nfloat DXFresnelTerm(float costheta,float refractionindex);\n\n//--- DXVector2 functions\nvoid  DXVec2Add(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2BaryCentric(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2,const DXVector2 &pv3,float f,float g);\nvoid  DXVec2CatmullRom(DXVector2 &pout,const DXVector2 &pv0,const DXVector2 &pv1,const DXVector2 &pv2,const DXVector2\n&pv3,float s); float DXVec2CCW(const DXVector2 &pv1,const DXVector2 &pv2); float DXVec2Dot(const DXVector2 &pv1,const\nDXVector2 &pv2); void  DXVec2Hermite(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pt1,const DXVector2\n&pv2,const DXVector2 &pt2,float s); float DXVec2Length(const DXVector2 &v); float DXVec2LengthSq(const DXVector2 &v);\nvoid  DXVec2Lerp(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2,float s);\nvoid  DXVec2Maximize(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2Minimize(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2Normalize(DXVector2 &pout,const DXVector2 &pv);\nvoid  DXVec2Scale(DXVector2 &pout,const DXVector2 &pv,float s);\nvoid  DXVec2Subtract(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2Transform(DXVector4 &pout,const DXVector2 &pv,const DXMatrix &pm);\nvoid  DXVec2TransformCoord(DXVector2 &pout,const DXVector2 &pv,const DXMatrix &pm);\nvoid  DXVec2TransformNormal(DXVector2 &pout,const DXVector2 &pv,const DXMatrix &pm);\n\n//--- DXVector3 functions\nvoid  DXVec3Add(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2);\nvoid  DXVec3BaryCentric(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2,const DXVector3 &pv3,float f,float g);\nvoid  DXVec3CatmullRom(DXVector3 &pout,const DXVector3 &pv0,const DXVector3 &pv1,const DXVector3 &pv2,const DXVector3\n&pv3,float s); void  DXVec3Cross(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2); float DXVec3Dot(const\nDXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Hermite(DXVector3 &pout,const DXVector3 &pv1,const DXVector3\n&pt1,const DXVector3 &pv2,const DXVector3 &pt2,float s); float DXVec3Length(const DXVector3 &pv); float\nDXVec3LengthSq(const DXVector3 &pv); void  DXVec3Lerp(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2,float\ns); void  DXVec3Maximize(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Minimize(DXVector3\n&pout,const DXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Normalize(DXVector3 &pout,const DXVector3 &pv); void\nDXVec3Project(DXVector3 &pout,const DXVector3 &pv,const DViewport &pviewport,const DXMatrix &pprojection,const DXMatrix\n&pview,const DXMatrix &pworld); void  DXVec3Scale(DXVector3 &pout,const DXVector3 &pv,float s); void\nDXVec3Subtract(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Transform(DXVector4 &pout,const\nDXVector3 &pv,const DXMatrix &pm); void  DXVec3TransformCoord(DXVector3 &pout,const DXVector3 &pv,const DXMatrix &pm);\nvoid  DXVec3TransformNormal(DXVector3 &pout,const DXVector3 &pv,const DXMatrix &pm);\nvoid  DXVec3Unproject(DXVector3 &out,const DXVector3 &v,const DViewport &viewport,const DXMatrix &projection,const\nDXMatrix &view,const DXMatrix &world);\n\n//--- DXVector4 vector functions\nvoid  DXVec4Add(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2);\nvoid  DXVec4BaryCentric(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2,const DXVector4 &pv3,float f,float g);\nvoid  DXVec4CatmullRom(DXVector4 &pout,const DXVector4 &pv0,const DXVector4 &pv1,const DXVector4 &pv2,const DXVector4\n&pv3,float s); void  DXVec4Cross(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2,const DXVector4 &pv3); float\nDXVec4Dot(const DXVector4 &pv1,const DXVector4 &pv2); void  DXVec4Hermite(DXVector4 &pout,const DXVector4 &pv1,const\nDXVector4 &pt1,const DXVector4 &pv2,const DXVector4 &pt2,float s); float DXVec4Length(const DXVector4 &pv); float\nDXVec4LengthSq(const DXVector4 &pv); void  DXVec4Lerp(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2,float\ns); void  DXVec4Maximize(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2); void  DXVec4Minimize(DXVector4\n&pout,const DXVector4 &pv1,const DXVector4 &pv2); void  DXVec4Normalize(DXVector4 &pout,const DXVector4 &pv); void\nDXVec4Scale(DXVector4 &pout,const DXVector4 &pv,float s); void  DXVec4Subtract(DXVector4 &pout,const DXVector4\n&pv1,const DXVector4 &pv2); void  DXVec4Transform(DXVector4 &pout,const DXVector4 &pv,const DXMatrix &pm);\n\n//---DXQuaternion functions\nvoid  DXQuaternionBaryCentric(DXQuaternion &pout,DXQuaternion &pq1,DXQuaternion &pq2,DXQuaternion &pq3,float f,float g);\nvoid  DXQuaternionConjugate(DXQuaternion &pout,const DXQuaternion &pq);\nfloat DXQuaternionDot(DXQuaternion &a,DXQuaternion &b);\nvoid  DXQuaternionExp(DXQuaternion &out,const DXQuaternion &q);\nvoid  DXQuaternionIdentity(DXQuaternion &out);\nbool  DXQuaternionIsIdentity(DXQuaternion &pq);\nfloat DXQuaternionLength(const DXQuaternion &pq);\nfloat DXQuaternionLengthSq(const DXQuaternion &pq);\nvoid  DXQuaternionInverse(DXQuaternion &pout,const DXQuaternion &pq);\nvoid  DXQuaternionLn(DXQuaternion &out,const DXQuaternion &q);\nvoid  DXQuaternionMultiply(DXQuaternion &pout,const DXQuaternion &pq1,const DXQuaternion &pq2);\nvoid  DXQuaternionNormalize(DXQuaternion &out,const DXQuaternion &q);\nvoid  DXQuaternionRotationAxis(DXQuaternion &out,const DXVector3 &v,float angle);\nvoid  DXQuaternionRotationMatrix(DXQuaternion &out,const DXMatrix &m);\nvoid  DXQuaternionRotationYawPitchRoll(DXQuaternion &out,float yaw,float pitch,float roll);\nvoid  DXQuaternionSlerp(DXQuaternion &out,DXQuaternion &q1,DXQuaternion &q2,float t);\nvoid  DXQuaternionSquad(DXQuaternion &pout,DXQuaternion &pq1,DXQuaternion &pq2,DXQuaternion &pq3,DXQuaternion &pq4,float\nt); void  DXQuaternionSquadSetup(DXQuaternion &paout,DXQuaternion &pbout,DXQuaternion &pcout,DXQuaternion\n&pq0,DXQuaternion &pq1,DXQuaternion &pq2,DXQuaternion &pq3); void  DXQuaternionToAxisAngle(const DXQuaternion\n&pq,DXVector3 &paxis,float &pangle); DXQuaternion add_diff(const DXQuaternion &q1,const DXQuaternion &q2,const float\nadd);\n\n//--- DXMatrix functions\nvoid  DXMatrixIdentity(DXMatrix &out);\nbool  DXMatrixIsIdentity(DXMatrix &pm);\nvoid  DXMatrixAffineTransformation(DXMatrix &out,float scaling,const DXVector3 &rotationcenter,const DXQuaternion\n&rotation,const DXVector3 &translation); void  DXMatrixAffineTransformation2D(DXMatrix &out,float scaling,const\nDXVector2 &rotationcenter,float rotation,const DXVector2 &translation); int   DXMatrixDecompose(DXVector3\n&poutscale,DXQuaternion &poutrotation,DXVector3 &pouttranslation,const DXMatrix &pm); float DXMatrixDeterminant(const\nDXMatrix &pm); void  DXMatrixInverse(DXMatrix &pout,float &pdeterminant,const DXMatrix &pm); void\nDXMatrixLookAtLH(DXMatrix &out,const DXVector3 &eye,const DXVector3 &at,const DXVector3 &up); void\nDXMatrixLookAtRH(DXMatrix &out,const DXVector3 &eye,const DXVector3 &at,const DXVector3 &up); void\nDXMatrixMultiply(DXMatrix &pout,const DXMatrix &pm1,const DXMatrix &pm2); void  DXMatrixMultiplyTranspose(DXMatrix\n&pout,const DXMatrix &pm1,const DXMatrix &pm2); void  DXMatrixOrthoLH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixOrthoOffCenterLH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixOrthoOffCenterRH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixOrthoRH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixPerspectiveFovLH(DXMatrix &pout,float fovy,float aspect,float zn,float zf);\nvoid  DXMatrixPerspectiveFovRH(DXMatrix &pout,float fovy,float aspect,float zn,float zf);\nvoid  DXMatrixPerspectiveLH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixPerspectiveOffCenterLH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixPerspectiveOffCenterRH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixPerspectiveRH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixReflect(DXMatrix &pout,const DXPlane &pplane);\nvoid  DXMatrixRotationAxis(DXMatrix &out,const DXVector3 &v,float angle);\nvoid  DXMatrixRotationQuaternion(DXMatrix &pout,const DXQuaternion &pq);\nvoid  DXMatrixRotationX(DXMatrix &pout,float angle);\nvoid  DXMatrixRotationY(DXMatrix &pout,float angle);\nvoid  DXMatrixRotationYawPitchRoll(DXMatrix &out,float yaw,float pitch,float roll);\nvoid  DXMatrixRotationZ(DXMatrix &pout,float angle);\nvoid  DXMatrixScaling(DXMatrix &pout,float sx,float sy,float sz);\nvoid  DXMatrixShadow(DXMatrix &pout,const DXVector4 &plight,const DXPlane &pplane);\nvoid  DXMatrixTransformation(DXMatrix &pout,const DXVector3 &pscalingcenter,const DXQuaternion &pscalingrotation,const\nDXVector3 &pscaling,const DXVector3 &protationcenter,const DXQuaternion &protation,const DXVector3 &ptranslation); void\nDXMatrixTransformation2D(DXMatrix &pout,const DXVector2 &pscalingcenter,float scalingrotation,const DXVector2\n&pscaling,const DXVector2 &protationcenter,float rotation,const DXVector2 &ptranslation); void\nDXMatrixTranslation(DXMatrix &pout,float x,float y,float z); void  DXMatrixTranspose(DXMatrix &pout,const DXMatrix &pm);\n\n//--- DXPlane functions                                              |\nfloat DXPlaneDot(const DXPlane &p1,const DXVector4 &p2);\nfloat DXPlaneDotCoord(const DXPlane &pp,const DXVector4 &pv);\nfloat DXPlaneDotNormal(const DXPlane &pp,const DXVector4 &pv);\nvoid  DXPlaneFromPointNormal(DXPlane &pout,const DXVector3 &pvpoint,const DXVector3 &pvnormal);\nvoid  DXPlaneFromPoints(DXPlane &pout,const DXVector3 &pv1,const DXVector3 &pv2,const DXVector3 &pv3);\nvoid  DXPlaneIntersectLine(DXVector3 &pout,const DXPlane &pp,const DXVector3 &pv1,const DXVector3 &pv2);\nvoid  DXPlaneNormalize(DXPlane &out,const DXPlane &p);\nvoid  DXPlaneScale(DXPlane &pout,const DXPlane &p,float s);\nvoid  DXPlaneTransform(DXPlane &pout,const DXPlane &pplane,const DXMatrix &pm);\n\n//---- spherical harmonic functions\nvoid  DXSHAdd(float &out[],int order,const float &a[],const float &b[]);\nfloat DXSHDot(int order,const float &a[],const float &b[]);\nint   DXSHEvalConeLight(int order,const DXVector3 &dir,float radius,float Rintensity,float Gintensity,float\nBintensity,float &rout[],float &gout[],float &bout[]); void  DXSHEvalDirection(float &out[],int order,const DXVector3\n&dir); int   DXSHEvalDirectionalLight(int order,const DXVector3 &dir,float Rintensity,float Gintensity,float\nBintensity,float &rout[],float &gout[],float &bout[]); int   DXSHEvalHemisphereLight(int order,const DXVector3\n&dir,DXColor &top,DXColor &bottom,float &rout[],float &gout[],float &bout[]); int   DXSHEvalSphericalLight(int\norder,const DXVector3 &dir,float radius,float Rintensity,float Gintensity,float Bintensity,float &rout[],float\n&gout[],float &bout[]); void  DXSHMultiply2(float &out[],const float &a[],const float &b[]); void  DXSHMultiply3(float\n&out[],const float &a[],const float &b[]); void  DXSHMultiply4(float &out[],const float &a[],const float &b[]); void\nDXSHRotate(float &out[],int order,const DXMatrix &_matrix,const float &in[]); void  DXSHRotateZ(float &out[],int\norder,float angle,const float &in[]); void  DXSHScale(float &out[],int order,const float &a[],const float scale);\n\n//--- scalar functions\nfloat DXScalarLerp(const float val1,const float val2,float s)\nfloat DXScalarBiasScale(const float val,const float bias,const float scale)\n*/\n\n//+------------------------------------------------------------------+\n//| Adds two color values together to create a new color value.      |\n//+------------------------------------------------------------------+\nvoid DXColorAdd(DXColor &pout, const DXColor &pc1, const DXColor &pc2) {\n  pout.r = pc1.r + pc2.r;\n  pout.g = pc1.g + pc2.g;\n  pout.b = pc1.b + pc2.b;\n  pout.a = pc1.a + pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Adjusts the contrast value of a color.                           |\n//+------------------------------------------------------------------+\n//| The input alpha channel is copied, unmodified,                   |\n//| to the output alpha channel.                                     |\n//|                                                                  |\n//| This function interpolates the red,green,and blue color          |\n//| components of a DXColor structure between fifty percent gray     |\n//| and a specified contrast value,as shown in the following example.|\n//|                                                                  |\n//| pout.r = 0.5f + s*(pc.r - 0.5f);                                 |\n//|                                                                  |\n//| If s is greater than 0 and less than 1,the contrast is decreased.|\n//| If s is greater than 1, the contrast is increased.               |\n//+------------------------------------------------------------------+\nvoid DXColorAdjustContrast(DXColor &pout, const DXColor &pc, float s) {\n  pout.r = 0.5f + s * (pc.r - 0.5f);\n  pout.g = 0.5f + s * (pc.g - 0.5f);\n  pout.b = 0.5f + s * (pc.b - 0.5f);\n  pout.a = pc.a;\n}\n//+------------------------------------------------------------------+\n//| Adjusts the saturation value of a color.                         |\n//+------------------------------------------------------------------+\n//| The input alpha channel is copied, unmodified,                   |\n//| to the output alpha channel.                                     |\n//|                                                                  |\n//| This function interpolates the red, green, and blue color        |\n//| components of a DXColor structure between an unsaturated color   |\n//| and a color, as shown in the following example.                  |\n//|                                                                  |\n//| Approximate values for each component's contribution to          |\n//| luminance. Based upon the NTSC standard described in             |\n//| ITU-R Recommendation BT.709.                                     |\n//| float grey = pc.r*0.2125f + pc.g*0.7154f + pc.b*0.0721f;         |\n//|                                                                  |\n//| pout.r = grey + s*(pc.r - grey);                                 |\n//| If s is greater than 0 and less than 1, the saturation is        |\n//| decreased. If s is greater than 1, the saturation is increased.  |\n//|                                                                  |\n//| The grayscale color is computed as:                              |\n//| r = g = b = 0.2125*r + 0.7154*g + 0.0721*b                       |\n//+------------------------------------------------------------------+\nvoid DXColorAdjustSaturation(DXColor &pout, const DXColor &pc, float s) {\n  float grey = pc.r * 0.2125f + pc.g * 0.7154f + pc.b * 0.0721f;\n  pout.r = grey + s * (pc.r - grey);\n  pout.g = grey + s * (pc.g - grey);\n  pout.b = grey + s * (pc.b - grey);\n  pout.a = pc.a;\n}\n//+------------------------------------------------------------------+\n//| Uses linear interpolation to create a color value.               |\n//+------------------------------------------------------------------+\n//| This function interpolates the red, green, blue, and alpha       |\n//| components of a DXColor structure between two colors, as shown   |\n//| in the following example.                                        |\n//|                                                                  |\n//| pout.r = pC1.r + s * (pC2.r - pC1.r);                            |\n//|                                                                  |\n//| If you are linearly interpolating between the colors A and B,    |\n//| and s is 0, the resulting color is A.                            |\n//| If s is 1, the resulting color is color B.                       |\n//+------------------------------------------------------------------+\nvoid DXColorLerp(DXColor &pout, const DXColor &pc1, const DXColor &pc2, float s) {\n  pout.r = (1 - s) * pc1.r + s * pc2.r;\n  pout.g = (1 - s) * pc1.g + s * pc2.g;\n  pout.b = (1 - s) * pc1.b + s * pc2.b;\n  pout.a = (1 - s) * pc1.a + s * pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Blends two colors.                                               |\n//+------------------------------------------------------------------+\n//| This function blends together two colors by multiplying matching |\n//| color components, as shown in the following example.             |\n//| pout.r = pC1.r * pC2.r;                                          |\n//+------------------------------------------------------------------+\nvoid DXColorModulate(DXColor &pout, const DXColor &pc1, const DXColor &pc2) {\n  pout.r = pc1.r * pc2.r;\n  pout.g = pc1.g * pc2.g;\n  pout.b = pc1.b * pc2.b;\n  pout.a = pc1.a * pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Creates the negative color value of a color value.               |\n//+------------------------------------------------------------------+\n//| The input alpha channel is copied, unmodified, to the output     |\n//| alpha channel.                                                   |\n//| This function returns the negative color value by subtracting 1.0|\n//| from the color components of the DXColor structure,              |\n//| as shown in the following example.                               |\n//|  pout.r = 1.0f - pc.r;                                           |\n//+------------------------------------------------------------------+\nvoid DXColorNegative(DXColor &pout, const DXColor &pc) {\n  pout.r = 1.0f - pc.r;\n  pout.g = 1.0f - pc.g;\n  pout.b = 1.0f - pc.b;\n  pout.a = pc.a;\n}\n//+------------------------------------------------------------------+\n//| Scales a color value.                                            |\n//+------------------------------------------------------------------+\n//| This function computes the scaled color value by multiplying     |\n//| the color components of the DXColor structure by the specified   |\n//| scale factor, as shown in the following example.                 |\n//| pOut.r = pC.r*s;                                                 |\n//+------------------------------------------------------------------+\nvoid DXColorScale(DXColor &pout, const DXColor &pc, float s) {\n  pout.r = s * pc.r;\n  pout.g = s * pc.g;\n  pout.b = s * pc.b;\n  pout.a = s * pc.a;\n}\n//+------------------------------------------------------------------+\n//| Subtracts two color values to create a new color value.          |\n//+------------------------------------------------------------------+\nvoid DXColorSubtract(DXColor &pout, const DXColor &pc1, const DXColor &pc2) {\n  pout.r = pc1.r - pc2.r;\n  pout.g = pc1.g - pc2.g;\n  pout.b = pc1.b - pc2.b;\n  pout.a = pc1.a - pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Calculate the Fresnel term.                                      |\n//+------------------------------------------------------------------+\n//| To find the Fresnel term (F):                                    |\n//| If A is angle of incidence and B is the angle of refraction,     |\n//| then                                                             |\n//| F = 0.5*[tan2(A - B)/tan2(A + B) + sin2(A - B)/sin2(A + B)]      |\n//|   = 0.5*sin2(A - B)/sin2(A + B)*[cos2(A + B)/cos2(A - B) + 1]    |\n//|                                                                  |\n//|  Let r = sina(A)/sin(B)      (the relative refractive index)     |\n//|  Let c = cos(A)                                                  |\n//|  Let g = (r2 + c2 - 1)1/2                                        |\n//|                                                                  |\n//| Then,expanding using the trig identities and simplifying,        |\n//| you get:                                                         |\n//| F = 0.5*(g + c)2/(g - c)2*([c(g + c)-1]2/[c(g - c) + 1]2 + 1)    |\n//+------------------------------------------------------------------+\nfloat DXFresnelTerm(float costheta, float refractionindex) {\n  float g = (float)sqrt(refractionindex * refractionindex + costheta * costheta - 1.0f);\n  float a = g + costheta;\n  float d = g - costheta;\n  float result = (costheta * a - 1.0f) * (costheta * a - 1.0f) / ((costheta * d + 1.0f) * (costheta * d + 1.0f)) + 1.0f;\n  result *= 0.5f * d * d / (a * a);\n  //---\n  return (result);\n}\n//+------------------------------------------------------------------+\n//| Adds two 2D vectors.                                             |\n//+------------------------------------------------------------------+\nvoid DXVec2Add(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = pv1.x + pv2.x;\n  pout.y = pv1.y + pv2.y;\n}\n//+------------------------------------------------------------------+\n//| Returns a point in Barycentric coordinates,                      |\n//| using the specified 2D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec2BaryCentric(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2, const DXVector2 &pv3, float f,\n                       float g) {\n  pout.x = (1.0f - f - g) * (pv1.x) + f * (pv2.x) + g * (pv3.x);\n  pout.y = (1.0f - f - g) * (pv1.y) + f * (pv2.y) + g * (pv3.y);\n}\n//+------------------------------------------------------------------+\n//| Performs a Catmull-Rom interpolation,                            |\n//| using the specified 2D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec2CatmullRom(DXVector2 &pout, const DXVector2 &pv0, const DXVector2 &pv1, const DXVector2 &pv2,\n                      const DXVector2 &pv3, float s) {\n  pout.x = 0.5f * (2.0f * pv1.x + (pv2.x - pv0.x) * s + (2.0f * pv0.x - 5.0f * pv1.x + 4.0f * pv2.x - pv3.x) * s * s +\n                   (pv3.x - 3.0f * pv2.x + 3.0f * pv1.x - pv0.x) * s * s * s);\n  pout.y = 0.5f * (2.0f * pv1.y + (pv2.y - pv0.y) * s + (2.0f * pv0.y - 5.0f * pv1.y + 4.0f * pv2.y - pv3.y) * s * s +\n                   (pv3.y - 3.0f * pv2.y + 3.0f * pv1.y - pv0.y) * s * s * s);\n}\n//+------------------------------------------------------------------+\n//| Returns the z-component by taking the cross product              |\n//| of two 2D vectors.                                               |\n//+------------------------------------------------------------------+\nfloat DXVec2CCW(const DXVector2 &pv1, const DXVector2 &pv2) { return (pv1.x * pv2.y - pv1.y * pv2.x); }\n//+------------------------------------------------------------------+\n//| Determines the dot product of two 2D vectors.                    |\n//+------------------------------------------------------------------+\nfloat DXVec2Dot(const DXVector2 &pv1, const DXVector2 &pv2) { return (pv1.x * pv2.x + pv1.y * pv2.y); }\n//+------------------------------------------------------------------+\n//| Performs a Hermite spline interpolation,                         |\n//| using the specified 2D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec2Hermite(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pt1, const DXVector2 &pv2,\n                   const DXVector2 &pt2, float s) {\n  //--- prepare coefficients\n  float h1 = 2.0f * s * s * s - 3.0f * s * s + 1.0f;\n  float h2 = s * s * s - 2.0f * s * s + s;\n  float h3 = -2.0f * s * s * s + 3.0f * s * s;\n  float h4 = s * s * s - s * s;\n  //--- calculate interpolated point\n  pout.x = h1 * pv1.x + h2 * pt1.x + h3 * pv2.x + h4 * pt2.x;\n  pout.y = h1 * pv1.y + h2 * pt1.y + h3 * pv2.y + h4 * pt2.y;\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a 2D vector.                               |\n//+------------------------------------------------------------------+\nfloat DXVec2Length(const DXVector2 &v) { return ((float)sqrt(v.x * v.x + v.y * v.y)); }\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a 2D vector.                 |\n//+------------------------------------------------------------------+\nfloat DXVec2LengthSq(const DXVector2 &v) { return ((float)(v.x * v.x + v.y * v.y)); }\n//+------------------------------------------------------------------+\n//| Performs a linear interpolation between two 2D vectors.          |\n//+------------------------------------------------------------------+\nvoid DXVec2Lerp(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2, float s) {\n  pout.x = (1.0f - s) * pv1.x + s * pv2.x;\n  pout.y = (1.0f - s) * pv1.y + s * pv2.y;\n}\n//+------------------------------------------------------------------+\n//| Returns a 2D vector that is made up of the largest components    |\n//| of two 2D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec2Maximize(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = (float)fmax(pv1.x, pv2.x);\n  pout.y = (float)fmax(pv1.y, pv2.y);\n}\n//+------------------------------------------------------------------+\n//| Returns a 2D vector that is made up of the smallest components   |\n//| of two 2D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec2Minimize(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = (float)fmin(pv1.x, pv2.x);\n  pout.y = (float)fmin(pv1.y, pv2.y);\n}\n//+------------------------------------------------------------------+\n//| Returns the normalized version of a 2D vector.                   |\n//+------------------------------------------------------------------+\nvoid DXVec2Normalize(DXVector2 &pout, const DXVector2 &pv) {\n  //--- calculate length\n  float norm = DXVec2Length(pv);\n  if (!norm) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n  } else {\n    pout.x = pv.x / norm;\n    pout.y = pv.y / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Scales a 2D vector.                                              |\n//+------------------------------------------------------------------+\nvoid DXVec2Scale(DXVector2 &pout, const DXVector2 &pv, float s) {\n  pout.x = s * pv.x;\n  pout.y = s * pv.y;\n}\n//+------------------------------------------------------------------+\n//| DXVec3Subtract                                                   |\n//+------------------------------------------------------------------+\nvoid DXVec2Subtract(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = pv1.x - pv2.x;\n  pout.y = pv1.y - pv2.y;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 2D vector by a given _matrix.                        |\n//| This function transforms the vector pv(x,y,0,1) by the _matrix pm.|\n//+------------------------------------------------------------------+\nvoid DXVec2Transform(DXVector4 &pout, const DXVector2 &pv, const DXMatrix &pm) {\n  DXVector4 out;\n  out.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[3][0];\n  out.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[3][1];\n  out.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[3][2];\n  out.w = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[3][3];\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 2D vector by a given _matrix,                        |\n//| projecting the result back into w = 1.                           |\n//| This function transforms the vector pv(x,y,0,1) by the _matrix pm.|\n//+------------------------------------------------------------------+\nvoid DXVec2TransformCoord(DXVector2 &pout, const DXVector2 &pv, const DXMatrix &pm) {\n  float norm = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[3][3];\n  if (norm) {\n    pout.x = (pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[3][0]) / norm;\n    pout.y = (pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[3][1]) / norm;\n  } else {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Transforms the 2D vector normal by the given _matrix.             |\n//+------------------------------------------------------------------+\nvoid DXVec2TransformNormal(DXVector2 &pout, const DXVector2 &pv, const DXMatrix &pm) {\n  pout.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y;\n  pout.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y;\n}\n//+------------------------------------------------------------------+\n//| Adds two 3D vectors.                                             |\n//+------------------------------------------------------------------+\nvoid DXVec3Add(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = pv1.x + pv2.x;\n  pout.y = pv1.y + pv2.y;\n  pout.z = pv1.z + pv2.z;\n}\n//+------------------------------------------------------------------+\n//| Returns a point in Barycentric coordinates,                      |\n//| using the specified 3D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec3BaryCentric(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2, const DXVector3 &pv3, float f,\n                       float g) {\n  pout.x = (1.0f - f - g) * pv1.x + f * pv2.x + g * pv3.x;\n  pout.y = (1.0f - f - g) * pv1.y + f * pv2.y + g * pv3.y;\n  pout.z = (1.0f - f - g) * pv1.z + f * pv2.z + g * pv3.z;\n}\n//+------------------------------------------------------------------+\n//| Performs a Catmull-Rom interpolation,                            |\n//| using the specified 3D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec3CatmullRom(DXVector3 &pout, const DXVector3 &pv0, const DXVector3 &pv1, const DXVector3 &pv2,\n                      const DXVector3 &pv3, float s) {\n  pout.x = 0.5f * (2.0f * pv1.x + (pv2.x - pv0.x) * s + (2.0f * pv0.x - 5.0f * pv1.x + 4.0f * pv2.x - pv3.x) * s * s +\n                   (pv3.x - 3.0f * pv2.x + 3.0f * pv1.x - pv0.x) * s * s * s);\n  pout.y = 0.5f * (2.0f * pv1.y + (pv2.y - pv0.y) * s + (2.0f * pv0.y - 5.0f * pv1.y + 4.0f * pv2.y - pv3.y) * s * s +\n                   (pv3.y - 3.0f * pv2.y + 3.0f * pv1.y - pv0.y) * s * s * s);\n  pout.z = 0.5f * (2.0f * pv1.z + (pv2.z - pv0.z) * s + (2.0f * pv0.z - 5.0f * pv1.z + 4.0f * pv2.z - pv3.z) * s * s +\n                   (pv3.z - 3.0f * pv2.z + 3.0f * pv1.z - pv0.z) * s * s * s);\n}\n//+------------------------------------------------------------------+\n//| Determines the cross-product of two 3D vectors.                  |\n//+------------------------------------------------------------------+\nvoid DXVec3Cross(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = pv1.y * pv2.z - pv1.z * pv2.y;\n  pout.y = pv1.z * pv2.x - pv1.x * pv2.z;\n  pout.z = pv1.x * pv2.y - pv1.y * pv2.x;\n}\n//+------------------------------------------------------------------+\n//| Determines the dot product of two 3D vectors.                    |\n//+------------------------------------------------------------------+\nfloat DXVec3Dot(const DXVector3 &pv1, const DXVector3 &pv2) { return (pv1.x * pv2.x + pv1.y * pv2.y + pv1.z * pv2.z); }\n//+------------------------------------------------------------------+\n//| Performs a Hermite spline interpolation,                         |\n//| using the specified 3D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec3Hermite(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pt1, const DXVector3 &pv2,\n                   const DXVector3 &pt2, float s) {\n  float h1 = 2.0f * s * s * s - 3.0f * s * s + 1.0f;\n  float h2 = s * s * s - 2.0f * s * s + s;\n  float h3 = -2.0f * s * s * s + 3.0f * s * s;\n  float h4 = s * s * s - s * s;\n  //--- calculate interpolated coordinates\n  pout.x = h1 * pv1.x + h2 * pt1.x + h3 * pv2.x + h4 * pt2.x;\n  pout.y = h1 * pv1.y + h2 * pt1.y + h3 * pv2.y + h4 * pt2.y;\n  pout.z = h1 * pv1.z + h2 * pt1.z + h3 * pv2.z + h4 * pt2.z;\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a 3D vector.                               |\n//+------------------------------------------------------------------+\nfloat DXVec3Length(const DXVector3 &pv) { return ((float)sqrt(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z)); }\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a 3D vector.                 |\n//+------------------------------------------------------------------+\nfloat DXVec3LengthSq(const DXVector3 &pv) { return ((float)(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z)); }\n//+------------------------------------------------------------------+\n//| Performs a linear interpolation between two 3D vectors.          |\n//+------------------------------------------------------------------+\nvoid DXVec3Lerp(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2, float s) {\n  pout.x = (1.0f - s) * pv1.x + s * pv2.x;\n  pout.y = (1.0f - s) * pv1.y + s * pv2.y;\n  pout.z = (1.0f - s) * pv1.z + s * pv2.z;\n}\n//+------------------------------------------------------------------+\n//| Returns a 3D vector that is made up of the largest components    |\n//| of two 3D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec3Maximize(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = (float)fmax(pv1.x, pv2.x);\n  pout.y = (float)fmax(pv1.y, pv2.y);\n  pout.z = (float)fmax(pv1.z, pv2.z);\n}\n//+------------------------------------------------------------------+\n//| Returns a 3D vector that is made up of the smallest components   |\n//| of two 3D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec3Minimize(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = (float)fmin(pv1.x, pv2.x);\n  pout.y = (float)fmin(pv1.y, pv2.y);\n  pout.z = (float)fmin(pv1.z, pv2.z);\n}\n//+------------------------------------------------------------------+\n//| Returns the normalized version of a 3D vector.                   |\n//+------------------------------------------------------------------+\nvoid DXVec3Normalize(DXVector3 &pout, const DXVector3 &pv) {\n  //--- calculate length\n  float norm = DXVec3Length(pv);\n  if (!norm) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n  } else {\n    pout.x = pv.x / norm;\n    pout.y = pv.y / norm;\n    pout.z = pv.z / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Projects a 3D vector from object space into screen space.        |\n//+------------------------------------------------------------------+\nvoid DXVec3Project(DXVector3 &pout, const DXVector3 &pv, const DViewport &pviewport, const DXMatrix &pprojection,\n                   const DXMatrix &pview, const DXMatrix &pworld) {\n  DXMatrix m;\n  DXMatrixIdentity(m);\n  //--- pworld\n  DXMatrixMultiply(m, m, pworld);\n  //--- pview\n  DXMatrixMultiply(m, m, pview);\n  //--- pprojection\n  DXMatrixMultiply(m, m, pprojection);\n  DXVec3TransformCoord(pout, pv, m);\n  //---pviewport\n  pout.x = pviewport.x + (1.0f + pout.x) * pviewport.width / 2.0f;\n  pout.y = pviewport.y + (1.0f - pout.y) * pviewport.height / 2.0f;\n  pout.z = pviewport.minz + pout.z * (pviewport.maxz - pviewport.minz);\n}\n//+------------------------------------------------------------------+\n//| Scales a 3D vector.                                              |\n//+------------------------------------------------------------------+\nvoid DXVec3Scale(DXVector3 &pout, const DXVector3 &pv, float s) {\n  pout.x = s * pv.x;\n  pout.y = s * pv.y;\n  pout.z = s * pv.z;\n}\n//+------------------------------------------------------------------+\n//| Subtracts two 3D vectors.                                        |\n//+------------------------------------------------------------------+\nvoid DXVec3Subtract(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = pv1.x - pv2.x;\n  pout.y = pv1.y - pv2.y;\n  pout.z = pv1.z - pv2.z;\n}\n//+------------------------------------------------------------------+\n//| Transforms vector (x,y,z,1) by a given _matrix.                   |\n//+------------------------------------------------------------------+\nvoid DXVec3Transform(DXVector4 &pout, const DXVector3 &pv, const DXMatrix &pm) {\n  DXVector4 out;\n  //---\n  out.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z + pm.m[3][0];\n  out.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z + pm.m[3][1];\n  out.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z + pm.m[3][2];\n  out.w = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[2][3] * pv.z + pm.m[3][3];\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 3D vector by a given _matrix,                        |\n//| projecting the result back into w = 1.                           |\n//+------------------------------------------------------------------+\nvoid DXVec3TransformCoord(DXVector3 &pout, const DXVector3 &pv, const DXMatrix &pm) {\n  float norm = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[2][3] * pv.z + pm.m[3][3];\n  //---\n  if (norm) {\n    pout.x = (pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z + pm.m[3][0]) / norm;\n    pout.y = (pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z + pm.m[3][1]) / norm;\n    pout.z = (pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z + pm.m[3][2]) / norm;\n  } else {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Transforms the 3D vector normal by the given _matrix.             |\n//+------------------------------------------------------------------+\nvoid DXVec3TransformNormal(DXVector3 &pout, const DXVector3 &pv, const DXMatrix &pm) {\n  pout.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z;\n  pout.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z;\n  pout.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z;\n}\n//+------------------------------------------------------------------+\n//| Projects a vector from screen space into object space.           |\n//+------------------------------------------------------------------+\nvoid DXVec3Unproject(DXVector3 &out, const DXVector3 &v, const DViewport &viewport, const DXMatrix &projection,\n                     const DXMatrix &view, const DXMatrix &world) {\n  DXMatrix m;\n  DXMatrixIdentity(m);\n  //--- world\n  DXMatrixMultiply(m, m, world);\n  //--- view\n  DXMatrixMultiply(m, m, view);\n  //--- projection\n  DXMatrixMultiply(m, m, projection);\n  //--- calculate inverse _matrix\n  float det = 0.0f;\n  DXMatrixInverse(m, det, m);\n  out = v;\n  //--- viewport\n  out.x = 2.0f * (out.x - viewport.x) / viewport.width - 1.0f;\n  out.y = 1.0f - 2.0f * (out.y - viewport.y) / viewport.height;\n  out.z = (out.z - viewport.minz) / (viewport.maxz - viewport.minz);\n  //---\n  DXVec3TransformCoord(out, out, m);\n}\n//+------------------------------------------------------------------+\n//| Adds two 4D vectors.                                             |\n//+------------------------------------------------------------------+\nvoid DXVec4Add(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = pv1.x + pv2.x;\n  pout.y = pv1.y + pv2.y;\n  pout.z = pv1.z + pv2.z;\n  pout.w = pv1.w + pv2.w;\n}\n//+------------------------------------------------------------------+\n//| Returns a point in Barycentric coordinates,                      |\n//| using the specified 4D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec4BaryCentric(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2, const DXVector4 &pv3, float f,\n                       float g) {\n  pout.x = (1.0f - f - g) * (pv1.x) + f * (pv2.x) + g * (pv3.x);\n  pout.y = (1.0f - f - g) * (pv1.y) + f * (pv2.y) + g * (pv3.y);\n  pout.z = (1.0f - f - g) * (pv1.z) + f * (pv2.z) + g * (pv3.z);\n  pout.w = (1.0f - f - g) * (pv1.w) + f * (pv2.w) + g * (pv3.w);\n}\n//+------------------------------------------------------------------+\n//| Performs a Catmull-Rom interpolation,                            |\n//| using the specified 4D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec4CatmullRom(DXVector4 &pout, const DXVector4 &pv0, const DXVector4 &pv1, const DXVector4 &pv2,\n                      const DXVector4 &pv3, float s) {\n  pout.x = 0.5f * (2.0f * pv1.x + (pv2.x - pv0.x) * s + (2.0f * pv0.x - 5.0f * pv1.x + 4.0f * pv2.x - pv3.x) * s * s +\n                   (pv3.x - 3.0f * pv2.x + 3.0f * pv1.x - pv0.x) * s * s * s);\n  pout.y = 0.5f * (2.0f * pv1.y + (pv2.y - pv0.y) * s + (2.0f * pv0.y - 5.0f * pv1.y + 4.0f * pv2.y - pv3.y) * s * s +\n                   (pv3.y - 3.0f * pv2.y + 3.0f * pv1.y - pv0.y) * s * s * s);\n  pout.z = 0.5f * (2.0f * pv1.z + (pv2.z - pv0.z) * s + (2.0f * pv0.z - 5.0f * pv1.z + 4.0f * pv2.z - pv3.z) * s * s +\n                   (pv3.z - 3.0f * pv2.z + 3.0f * pv1.z - pv0.z) * s * s * s);\n  pout.w = 0.5f * (2.0f * pv1.w + (pv2.w - pv0.w) * s + (2.0f * pv0.w - 5.0f * pv1.w + 4.0f * pv2.w - pv3.w) * s * s +\n                   (pv3.w - 3.0f * pv2.w + 3.0f * pv1.w - pv0.w) * s * s * s);\n}\n//+------------------------------------------------------------------+\n//| Determines the cross-product in four dimensions.                 |\n//+------------------------------------------------------------------+\nvoid DXVec4Cross(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2, const DXVector4 &pv3) {\n  DXVector4 out;\n  out.x = pv1.y * (pv2.z * pv3.w - pv3.z * pv2.w) - pv1.z * (pv2.y * pv3.w - pv3.y * pv2.w) +\n          pv1.w * (pv2.y * pv3.z - pv2.z * pv3.y);\n  out.y = -(pv1.x * (pv2.z * pv3.w - pv3.z * pv2.w) - pv1.z * (pv2.x * pv3.w - pv3.x * pv2.w) +\n            pv1.w * (pv2.x * pv3.z - pv3.x * pv2.z));\n  out.z = pv1.x * (pv2.y * pv3.w - pv3.y * pv2.w) - pv1.y * (pv2.x * pv3.w - pv3.x * pv2.w) +\n          pv1.w * (pv2.x * pv3.y - pv3.x * pv2.y);\n  out.w = -(pv1.x * (pv2.y * pv3.z - pv3.y * pv2.z) - pv1.y * (pv2.x * pv3.z - pv3.x * pv2.z) +\n            pv1.z * (pv2.x * pv3.y - pv3.x * pv2.y));\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Determines the dot product of two 4D vectors.                    |\n//+------------------------------------------------------------------+\nfloat DXVec4Dot(const DXVector4 &pv1, const DXVector4 &pv2) {\n  return (pv1.x * pv2.x + pv1.y * pv2.y + pv1.z * pv2.z + pv1.w * pv2.w);\n}\n//+------------------------------------------------------------------+\n//| Performs a Hermite spline interpolation,                         |\n//| using the specified 4D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec4Hermite(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pt1, const DXVector4 &pv2,\n                   const DXVector4 &pt2, float s) {\n  float h1 = 2.0f * s * s * s - 3.0f * s * s + 1.0f;\n  float h2 = s * s * s - 2.0f * s * s + s;\n  float h3 = -2.0f * s * s * s + 3.0f * s * s;\n  float h4 = s * s * s - s * s;\n  pout.x = h1 * pv1.x + h2 * pt1.x + h3 * pv2.x + h4 * pt2.x;\n  pout.y = h1 * pv1.y + h2 * pt1.y + h3 * pv2.y + h4 * pt2.y;\n  pout.z = h1 * pv1.z + h2 * pt1.z + h3 * pv2.z + h4 * pt2.z;\n  pout.w = h1 * pv1.w + h2 * pt1.w + h3 * pv2.w + h4 * pt2.w;\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a 4D vector.                               |\n//+------------------------------------------------------------------+\nfloat DXVec4Length(const DXVector4 &pv) { return ((float)sqrt(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z + pv.w * pv.w)); }\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a 4D vector.                 |\n//+------------------------------------------------------------------+\nfloat DXVec4LengthSq(const DXVector4 &pv) { return ((float)(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z)); }\n//+------------------------------------------------------------------+\n//| Performs a linear interpolation between two 4D vectors.          |\n//+------------------------------------------------------------------+\nvoid DXVec4Lerp(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2, float s) {\n  pout.x = (1.0f - s) * pv1.x + s * pv2.x;\n  pout.y = (1.0f - s) * pv1.y + s * pv2.y;\n  pout.z = (1.0f - s) * pv1.z + s * pv2.z;\n  pout.w = (1.0f - s) * pv1.w + s * pv2.w;\n}\n//+------------------------------------------------------------------+\n//| Returns a 4D vector that is made up of the largest components    |\n//| of two 4D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec4Maximize(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = (float)fmax(pv1.x, pv2.x);\n  pout.y = (float)fmax(pv1.y, pv2.y);\n  pout.z = (float)fmax(pv1.z, pv2.z);\n  pout.w = (float)fmax(pv1.w, pv2.w);\n}\n//+------------------------------------------------------------------+\n//| Returns a 4D vector that is made up of the smallest components   |\n//| of two 4D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec4Minimize(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = (float)fmin(pv1.x, pv2.x);\n  pout.y = (float)fmin(pv1.y, pv2.y);\n  pout.z = (float)fmin(pv1.z, pv2.z);\n  pout.w = (float)fmin(pv1.w, pv2.w);\n}\n//+------------------------------------------------------------------+\n//| Returns the normalized version of a 4D vector.                   |\n//+------------------------------------------------------------------+\nvoid DXVec4Normalize(DXVector4 &pout, const DXVector4 &pv) {\n  //--- calculate length\n  float norm = DXVec4Length(pv);\n  if (!norm) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n    pout.w = 0.0f;\n  } else {\n    pout.x = pv.x / norm;\n    pout.y = pv.y / norm;\n    pout.z = pv.z / norm;\n    pout.w = pv.w / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Scales a 4D vector.                                              |\n//+------------------------------------------------------------------+\nvoid DXVec4Scale(DXVector4 &pout, const DXVector4 &pv, float s) {\n  pout.x = s * pv.x;\n  pout.y = s * pv.y;\n  pout.z = s * pv.z;\n  pout.w = s * pv.w;\n}\n//+------------------------------------------------------------------+\n//| Subtracts two 4D vectors.                                        |\n//+------------------------------------------------------------------+\nvoid DXVec4Subtract(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = pv1.x - pv2.x;\n  pout.y = pv1.y - pv2.y;\n  pout.z = pv1.z - pv2.z;\n  pout.w = pv1.w - pv2.w;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 4D vector by a given _matrix.                        |\n//+------------------------------------------------------------------+\nvoid DXVec4Transform(DXVector4 &pout, const DXVector4 &pv, const DXMatrix &pm) {\n  DXVector4 temp;\n  temp.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z + pm.m[3][0] * pv.w;\n  temp.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z + pm.m[3][1] * pv.w;\n  temp.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z + pm.m[3][2] * pv.w;\n  temp.w = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[2][3] * pv.z + pm.m[3][3] * pv.w;\n  pout = temp;\n}\n//+------------------------------------------------------------------+\n//| Returns a quaternion in barycentric coordinates.                 |\n//+------------------------------------------------------------------+\nvoid DXQuaternionBaryCentric(DXQuaternion &pout, DXQuaternion &pq1, DXQuaternion &pq2, DXQuaternion &pq3, float f,\n                             float g) {\n  DXQuaternion temp1, temp2;\n  DXQuaternionSlerp(temp1, pq1, pq2, f + g);\n  DXQuaternionSlerp(temp2, pq1, pq3, f + g);\n  DXQuaternionSlerp(pout, temp1, temp2, g / (f + g));\n}\n//+------------------------------------------------------------------+\n//| Returns the conjugate of a quaternion.                           |\n//+------------------------------------------------------------------+\nvoid DXQuaternionConjugate(DXQuaternion &pout, const DXQuaternion &pq) {\n  pout.x = -pq.x;\n  pout.y = -pq.y;\n  pout.z = -pq.z;\n  pout.w = pq.w;\n}\n//+------------------------------------------------------------------+\n//| Returns the dot product of two quaternions.                      |\n//+------------------------------------------------------------------+\nfloat DXQuaternionDot(DXQuaternion &a, DXQuaternion &b) { return (a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w); }\n//+------------------------------------------------------------------+\n//| Calculates the exponential.                                      |\n//| This method converts a pure quaternion to a unit quaternion.     |\n//| DXQuaternionExp expects a pure quaternion, where w is ignored    |\n//| in the calculation (w == 0).                                     |\n//+------------------------------------------------------------------+\nvoid DXQuaternionExp(DXQuaternion &out, const DXQuaternion &q) {\n  float norm = (float)sqrt(q.x * q.x + q.y * q.y + q.z * q.z);\n  if (norm) {\n    out.x = (float)sin(norm) * q.x / norm;\n    out.y = (float)sin(norm) * q.y / norm;\n    out.z = (float)sin(norm) * q.z / norm;\n    out.w = (float)cos(norm);\n  } else {\n    out.x = 0.0f;\n    out.y = 0.0f;\n    out.z = 0.0f;\n    out.w = 1.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Returns the identity quaternion.                                 |\n//+------------------------------------------------------------------+\nvoid DXQuaternionIdentity(DXQuaternion &out) {\n  out.x = 0.0f;\n  out.y = 0.0f;\n  out.z = 0.0f;\n  out.w = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Determines if a quaternion is an identity quaternion.            |\n//+------------------------------------------------------------------+\nbool DXQuaternionIsIdentity(DXQuaternion &pq) {\n  return ((pq.x == 0.0f) && (pq.y == 0.0f) && (pq.z == 0.0f) && (pq.w == 1.0f));\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a quaternion.                              |\n//+------------------------------------------------------------------+\nfloat DXQuaternionLength(const DXQuaternion &pq) {\n  return ((float)sqrt(pq.x * pq.x + pq.y * pq.y + pq.z * pq.z + pq.w * pq.w));\n}\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a quaternion.                |\n//+------------------------------------------------------------------+\nfloat DXQuaternionLengthSq(const DXQuaternion &pq) {\n  return ((float)(pq.x * pq.x + pq.y * pq.y + pq.z * pq.z + pq.w * pq.w));\n}\n//+------------------------------------------------------------------+\n//| Conjugates and renormalizes a quaternion.                        |\n//+------------------------------------------------------------------+\nvoid DXQuaternionInverse(DXQuaternion &pout, const DXQuaternion &pq) {\n  float norm = DXQuaternionLengthSq(pq);\n  pout.x = -pq.x / norm;\n  pout.y = -pq.y / norm;\n  pout.z = -pq.z / norm;\n  pout.w = pq.w / norm;\n}\n//+------------------------------------------------------------------+\n//| Calculates the natural logarithm.                                |\n//| The DXQuaternionLn function works only for unit quaternions.     |\n//+------------------------------------------------------------------+\nvoid DXQuaternionLn(DXQuaternion &out, const DXQuaternion &q) {\n  float t;\n  if ((q.w >= 1.0f) || (q.w == -1.0f))\n    t = 1.0f;\n  else\n    t = (float)(acos(q.w) / sqrt(1.0f - q.w * q.w));\n  out.x = t * q.x;\n  out.y = t * q.y;\n  out.z = t * q.z;\n  out.w = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Multiplies two quaternions.                                      |\n//+------------------------------------------------------------------+\nvoid DXQuaternionMultiply(DXQuaternion &pout, const DXQuaternion &pq1, const DXQuaternion &pq2) {\n  DXQuaternion out;\n  out.x = pq2.w * pq1.x + pq2.x * pq1.w + pq2.y * pq1.z - pq2.z * pq1.y;\n  out.y = pq2.w * pq1.y - pq2.x * pq1.z + pq2.y * pq1.w + pq2.z * pq1.x;\n  out.z = pq2.w * pq1.z + pq2.x * pq1.y - pq2.y * pq1.x + pq2.z * pq1.w;\n  out.w = pq2.w * pq1.w - pq2.x * pq1.x - pq2.y * pq1.y - pq2.z * pq1.z;\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Computes a unit length quaternion.                               |\n//+------------------------------------------------------------------+\nvoid DXQuaternionNormalize(DXQuaternion &out, const DXQuaternion &q) {\n  float norm = DXQuaternionLength(q);\n  if (!norm) {\n    out.x = 0.0f;\n    out.y = 0.0f;\n    out.z = 0.0f;\n    out.w = 0.0f;\n  } else {\n    out.x = q.x / norm;\n    out.y = q.y / norm;\n    out.z = q.z / norm;\n    out.w = q.w / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Rotates a quaternion about an arbitrary axis.                    |\n//+------------------------------------------------------------------+\nvoid DXQuaternionRotationAxis(DXQuaternion &out, const DXVector3 &v, float angle) {\n  DXVector3 temp;\n  DXVec3Normalize(temp, v);\n  out.x = (float)sin(angle / 2.0f) * temp.x;\n  out.y = (float)sin(angle / 2.0f) * temp.y;\n  out.z = (float)sin(angle / 2.0f) * temp.z;\n  out.w = (float)cos(angle / 2.0f);\n}\n//+------------------------------------------------------------------+\n//| Builds a quaternion from a rotation _matrix.                      |\n//+------------------------------------------------------------------+\nvoid DXQuaternionRotationMatrix(DXQuaternion &out, const DXMatrix &m) {\n  float s;\n  float trace = m.m[0][0] + m.m[1][1] + m.m[2][2] + 1.0f;\n  if (trace > 1.0f) {\n    s = 2.0f * (float)sqrt(trace);\n    out.x = (m.m[1][2] - m.m[2][1]) / s;\n    out.y = (m.m[2][0] - m.m[0][2]) / s;\n    out.z = (m.m[0][1] - m.m[1][0]) / s;\n    out.w = 0.25f * s;\n  } else {\n    int maxi = 0;\n    for (int i = 1; i < 3; i++) {\n      if (m.m[i][i] > m.m[maxi][maxi]) maxi = i;\n    }\n    switch (maxi) {\n      case 0:\n        s = 2.0f * (float)sqrt(1.0f + m.m[0][0] - m.m[1][1] - m.m[2][2]);\n        out.x = 0.25f * s;\n        out.y = (m.m[0][1] + m.m[1][0]) / s;\n        out.z = (m.m[0][2] + m.m[2][0]) / s;\n        out.w = (m.m[1][2] - m.m[2][1]) / s;\n        break;\n\n      case 1:\n        s = 2.0f * (float)sqrt(1.0f + m.m[1][1] - m.m[0][0] - m.m[2][2]);\n        out.x = (m.m[0][1] + m.m[1][0]) / s;\n        out.y = 0.25f * s;\n        out.z = (m.m[1][2] + m.m[2][1]) / s;\n        out.w = (m.m[2][0] - m.m[0][2]) / s;\n        break;\n\n      case 2:\n        s = 2.0f * (float)sqrt(1.0f + m.m[2][2] - m.m[0][0] - m.m[1][1]);\n        out.x = (m.m[0][2] + m.m[2][0]) / s;\n        out.y = (m.m[1][2] + m.m[2][1]) / s;\n        out.z = 0.25f * s;\n        out.w = (m.m[0][1] - m.m[1][0]) / s;\n        break;\n    }\n  }\n}\n//+------------------------------------------------------------------+\n//| Builds a quaternion with the given yaw, pitch, and roll.         |\n//+------------------------------------------------------------------+\nvoid DXQuaternionRotationYawPitchRoll(DXQuaternion &out, float yaw, float pitch, float roll) {\n  float syaw = (float)sin(yaw / 2.0f);\n  float cyaw = (float)cos(yaw / 2.0f);\n  float spitch = (float)sin(pitch / 2.0f);\n  float cpitch = (float)cos(pitch / 2.0f);\n  float sroll = (float)sin(roll / 2.0f);\n  float croll = (float)cos(roll / 2.0f);\n  //---\n  out.x = syaw * cpitch * sroll + cyaw * spitch * croll;\n  out.y = syaw * cpitch * croll - cyaw * spitch * sroll;\n  out.z = cyaw * cpitch * sroll - syaw * spitch * croll;\n  out.w = cyaw * cpitch * croll + syaw * spitch * sroll;\n}\n//+------------------------------------------------------------------+\n//| Interpolates between two quaternions, using spherical linear     |\n//| interpolation.                                                   |\n//+------------------------------------------------------------------+\nvoid DXQuaternionSlerp(DXQuaternion &out, DXQuaternion &q1, DXQuaternion &q2, float t) {\n  float temp = 1.0f - t;\n  float dot = DXQuaternionDot(q1, q2);\n  if (dot < 0.0f) {\n    t = -t;\n    dot = -dot;\n  }\n  if (1.0f - dot > 0.001f) {\n    float theta = (float)acos(dot);\n    temp = (float)sin(theta * temp) / (float)sin(theta);\n    t = (float)sin(theta * t) / (float)sin(theta);\n  }\n  out.x = temp * q1.x + t * q2.x;\n  out.y = temp * q1.y + t * q2.y;\n  out.z = temp * q1.z + t * q2.z;\n  out.w = temp * q1.w + t * q2.w;\n}\n//+------------------------------------------------------------------+\n//| Interpolates between quaternions, using spherical quadrangle     |\n//| interpolation.                                                   |\n//+------------------------------------------------------------------+\nvoid DXQuaternionSquad(DXQuaternion &pout, DXQuaternion &pq1, DXQuaternion &pq2, DXQuaternion &pq3, DXQuaternion &pq4,\n                       float t) {\n  DXQuaternion temp1, temp2;\n  DXQuaternionSlerp(temp1, pq1, pq4, t);\n  DXQuaternionSlerp(temp2, pq2, pq3, t);\n  DXQuaternionSlerp(pout, temp1, temp2, 2.0f * t * (1.0f - t));\n}\n//+------------------------------------------------------------------+\n//| add_diff                                                         |\n//+------------------------------------------------------------------+\nDXQuaternion add_diff(const DXQuaternion &q1, const DXQuaternion &q2, const float add) {\n  DXQuaternion temp;\n  temp.x = q1.x + add * q2.x;\n  temp.y = q1.y + add * q2.y;\n  temp.z = q1.z + add * q2.z;\n  temp.w = q1.w + add * q2.w;\n  //---\n  return (temp);\n}\n//+------------------------------------------------------------------+\n//| Sets up control points for spherical quadrangle interpolation.   |\n//+------------------------------------------------------------------+\nvoid DXQuaternionSquadSetup(DXQuaternion &paout, DXQuaternion &pbout, DXQuaternion &pcout, DXQuaternion &pq0,\n                            DXQuaternion &pq1, DXQuaternion &pq2, DXQuaternion &pq3) {\n  DXQuaternion q, temp1, temp2, temp3, zero;\n  DXQuaternion aout, cout;\n  zero.x = 0.0f;\n  zero.y = 0.0f;\n  zero.z = 0.0f;\n  zero.w = 0.0f;\n  //---\n  if (DXQuaternionDot(pq0, pq1) < 0.0f)\n    temp2 = add_diff(zero, pq0, -1.0f);\n  else\n    temp2 = pq0;\n  //---\n  if (DXQuaternionDot(pq1, pq2) < 0.0f)\n    cout = add_diff(zero, pq2, -1.0f);\n  else\n    cout = pq2;\n  //---\n  if (DXQuaternionDot(cout, pq3) < 0.0f)\n    temp3 = add_diff(zero, pq3, -1.0f);\n  else\n    temp3 = pq3;\n  //---\n  DXQuaternionInverse(temp1, pq1);\n  DXQuaternionMultiply(temp2, temp1, temp2);\n  DXQuaternionLn(temp2, temp2);\n  DXQuaternionMultiply(q, temp1, cout);\n  DXQuaternionLn(q, q);\n  temp1 = add_diff(temp2, q, 1.0f);\n  temp1.x *= -0.25f;\n  temp1.y *= -0.25f;\n  temp1.z *= -0.25f;\n  temp1.w *= -0.25f;\n  DXQuaternionExp(temp1, temp1);\n  DXQuaternionMultiply(aout, pq1, temp1);\n  //---\n  DXQuaternionInverse(temp1, cout);\n  DXQuaternionMultiply(temp2, temp1, pq1);\n  DXQuaternionLn(temp2, temp2);\n  DXQuaternionMultiply(q, temp1, temp3);\n  DXQuaternionLn(q, q);\n  temp1 = add_diff(temp2, q, 1.0f);\n  temp1.x *= -0.25f;\n  temp1.y *= -0.25f;\n  temp1.z *= -0.25f;\n  temp1.w *= -0.25f;\n  DXQuaternionExp(temp1, temp1);\n  DXQuaternionMultiply(pbout, cout, temp1);\n  paout = aout;\n  pcout = cout;\n}\n//+------------------------------------------------------------------+\n//| Computes a quaternion's axis and angle of rotation.              |\n//+------------------------------------------------------------------+\nvoid DXQuaternionToAxisAngle(const DXQuaternion &pq, DXVector3 &paxis, float &pangle) {\n  //--- paxis\n  paxis.x = pq.x;\n  paxis.y = pq.y;\n  paxis.z = pq.z;\n  //--- pangle\n  pangle = 2.0f * (float)acos(pq.w);\n}\n//+------------------------------------------------------------------+\n//| DXMatrixIdentity creates an identity _matrix                      |\n//+------------------------------------------------------------------+\nvoid DXMatrixIdentity(DXMatrix &out) {\n  for (int j = 0; j < 4; j++)\n    for (int i = 0; i < 4; i++) {\n      if (i == j)\n        out.m[j, i] = 1.0f;\n      else\n        out.m[j, i] = 0.0f;\n    }\n}\n//+------------------------------------------------------------------+\n//| Determines if a _matrix is an identity _matrix.                    |\n//+------------------------------------------------------------------+\nbool DXMatrixIsIdentity(DXMatrix &pm) {\n  for (int j = 0; j < 4; j++)\n    for (int i = 0; i < 4; i++) {\n      if (i == j) {\n        if (fabs(pm.m[j, i] - 1.0f) > 1e-6f) return (false);\n      } else if (fabs(pm.m[j, i]) > 1e-6f)\n        return (false);\n    }\n  //---\n  return (true);\n}\n//+------------------------------------------------------------------+\n//| Builds a 3D affine transformation _matrix.                        |\n//+------------------------------------------------------------------+\n//| This function calculates the affine transformation _matrix        |\n//| with the following formula, with _matrix concatenation            |\n//| evaluated in left-to-right order:                                |\n//|             Mout = Ms * (Mrc)-1 * Mr * Mrc * Mt                  |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Ms = scaling _matrix (Scaling)                                    |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (pRotation)                                 |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixAffineTransformation(DXMatrix &out, float scaling, const DXVector3 &rotationcenter,\n                                  const DXQuaternion &rotation, const DXVector3 &translation) {\n  DXMatrixIdentity(out);\n  //--- rotation\n  float temp00 = 1.0f - 2.0f * (rotation.y * rotation.y + rotation.z * rotation.z);\n  float temp01 = 2.0f * (rotation.x * rotation.y + rotation.z * rotation.w);\n  float temp02 = 2.0f * (rotation.x * rotation.z - rotation.y * rotation.w);\n  float temp10 = 2.0f * (rotation.x * rotation.y - rotation.z * rotation.w);\n  float temp11 = 1.0f - 2.0f * (rotation.x * rotation.x + rotation.z * rotation.z);\n  float temp12 = 2.0f * (rotation.y * rotation.z + rotation.x * rotation.w);\n  float temp20 = 2.0f * (rotation.x * rotation.z + rotation.y * rotation.w);\n  float temp21 = 2.0f * (rotation.y * rotation.z - rotation.x * rotation.w);\n  float temp22 = 1.0f - 2.0f * (rotation.x * rotation.x + rotation.y * rotation.y);\n  //--- scaling\n  out.m[0][0] = scaling * temp00;\n  out.m[0][1] = scaling * temp01;\n  out.m[0][2] = scaling * temp02;\n  out.m[1][0] = scaling * temp10;\n  out.m[1][1] = scaling * temp11;\n  out.m[1][2] = scaling * temp12;\n  out.m[2][0] = scaling * temp20;\n  out.m[2][1] = scaling * temp21;\n  out.m[2][2] = scaling * temp22;\n  //--- rotationcenter\n  out.m[3][0] = rotationcenter.x * (1.0f - temp00) - rotationcenter.y * temp10 - rotationcenter.z * temp20;\n  out.m[3][1] = rotationcenter.y * (1.0f - temp11) - rotationcenter.x * temp01 - rotationcenter.z * temp21;\n  out.m[3][2] = rotationcenter.z * (1.0f - temp22) - rotationcenter.x * temp02 - rotationcenter.y * temp12;\n  //--- translation\n  out.m[3][0] += translation.x;\n  out.m[3][1] += translation.y;\n  out.m[3][2] += translation.z;\n}\n//+------------------------------------------------------------------+\n//| Builds a 2D affine transformation _matrix in the xy plane.        |\n//+------------------------------------------------------------------+\n//| This function calculates the affine transformation _matrix        |\n//| with the following formula, with _matrix concatenation evaluated  |\n//| in left-to-right order:                                          |\n//|             Mout = Ms * (Mrc)^(-1) * Mr * Mrc * Mt               |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Ms = scaling _matrix (Scaling)                                    |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (Rotation)                                  |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixAffineTransformation2D(DXMatrix &out, float scaling, const DXVector2 &rotationcenter, float rotation,\n                                    const DXVector2 &translation) {\n  float s = (float)sin(rotation / 2.0f);\n  float tmp1 = 1.0f - 2.0f * s * s;\n  float tmp2 = 2.0f * s * (float)cos(rotation / 2.0f);\n  //---\n  DXMatrixIdentity(out);\n  out.m[0][0] = scaling * tmp1;\n  out.m[0][1] = scaling * tmp2;\n  out.m[1][0] = -scaling * tmp2;\n  out.m[1][1] = scaling * tmp1;\n  //--- rotationcenter\n  float x = rotationcenter.x;\n  float y = rotationcenter.y;\n  out.m[3][0] = y * tmp2 - x * tmp1 + x;\n  out.m[3][1] = -x * tmp2 - y * tmp1 + y;\n  //--- translation\n  out.m[3][0] += translation.x;\n  out.m[3][1] += translation.y;\n}\n#define D3DERR_INVALIDCALL -2005530516\n//#define S_OK                 0;\n//+------------------------------------------------------------------+\n//| Breaks down a general 3D transformation _matrix into its scalar,  |\n//| rotational, and translational components.                        |\n//+------------------------------------------------------------------+\nint DXMatrixDecompose(DXVector3 &poutscale, DXQuaternion &poutrotation, DXVector3 &pouttranslation,\n                      const DXMatrix &pm) {\n  DXMatrix normalized;\n  DXVector3 vec;\n  //--- Compute the scaling part\n  vec.x = pm.m[0][0];\n  vec.y = pm.m[0][1];\n  vec.z = pm.m[0][2];\n  poutscale.x = DXVec3Length(vec);\n  vec.x = pm.m[1][0];\n  vec.y = pm.m[1][1];\n  vec.z = pm.m[1][2];\n  poutscale.y = DXVec3Length(vec);\n  vec.x = pm.m[2][0];\n  vec.y = pm.m[2][1];\n  vec.z = pm.m[2][2];\n  poutscale.z = DXVec3Length(vec);\n  //--- compute the translation part\n  pouttranslation.x = pm.m[3][0];\n  pouttranslation.y = pm.m[3][1];\n  pouttranslation.z = pm.m[3][2];\n  //--- let's calculate the rotation now\n  if ((poutscale.x == 0.0f) || (poutscale.y == 0.0f) || (poutscale.z == 0.0f)) return (D3DERR_INVALIDCALL);\n  //---\n  normalized.m[0][0] = pm.m[0][0] / poutscale.x;\n  normalized.m[0][1] = pm.m[0][1] / poutscale.x;\n  normalized.m[0][2] = pm.m[0][2] / poutscale.x;\n  normalized.m[1][0] = pm.m[1][0] / poutscale.y;\n  normalized.m[1][1] = pm.m[1][1] / poutscale.y;\n  normalized.m[1][2] = pm.m[1][2] / poutscale.y;\n  normalized.m[2][0] = pm.m[2][0] / poutscale.z;\n  normalized.m[2][1] = pm.m[2][1] / poutscale.z;\n  normalized.m[2][2] = pm.m[2][2] / poutscale.z;\n  DXQuaternionRotationMatrix(poutrotation, normalized);\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Returns the determinant of a _matrix.                             |\n//+------------------------------------------------------------------+\nfloat DXMatrixDeterminant(const DXMatrix &pm) {\n  float t[3], v[4];\n  t[0] = pm.m[2][2] * pm.m[3][3] - pm.m[2][3] * pm.m[3][2];\n  t[1] = pm.m[1][2] * pm.m[3][3] - pm.m[1][3] * pm.m[3][2];\n  t[2] = pm.m[1][2] * pm.m[2][3] - pm.m[1][3] * pm.m[2][2];\n  v[0] = pm.m[1][1] * t[0] - pm.m[2][1] * t[1] + pm.m[3][1] * t[2];\n  v[1] = -pm.m[1][0] * t[0] + pm.m[2][0] * t[1] - pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[1][0] * pm.m[2][1] - pm.m[2][0] * pm.m[1][1];\n  t[1] = pm.m[1][0] * pm.m[3][1] - pm.m[3][0] * pm.m[1][1];\n  t[2] = pm.m[2][0] * pm.m[3][1] - pm.m[3][0] * pm.m[2][1];\n  v[2] = pm.m[3][3] * t[0] - pm.m[2][3] * t[1] + pm.m[1][3] * t[2];\n  v[3] = -pm.m[3][2] * t[0] + pm.m[2][2] * t[1] - pm.m[1][2] * t[2];\n  //---\n  return (pm.m[0][0] * v[0] + pm.m[0][1] * v[1] + pm.m[0][2] * v[2] + pm.m[0][3] * v[3]);\n}\n//+------------------------------------------------------------------+\n//| Calculates the inverse of a _matrix.                              |\n//+------------------------------------------------------------------+\nvoid DXMatrixInverse(DXMatrix &pout, float &pdeterminant, const DXMatrix &pm) {\n  float t[3], v[16];\n  t[0] = pm.m[2][2] * pm.m[3][3] - pm.m[2][3] * pm.m[3][2];\n  t[1] = pm.m[1][2] * pm.m[3][3] - pm.m[1][3] * pm.m[3][2];\n  t[2] = pm.m[1][2] * pm.m[2][3] - pm.m[1][3] * pm.m[2][2];\n  v[0] = pm.m[1][1] * t[0] - pm.m[2][1] * t[1] + pm.m[3][1] * t[2];\n  v[4] = -pm.m[1][0] * t[0] + pm.m[2][0] * t[1] - pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[1][0] * pm.m[2][1] - pm.m[2][0] * pm.m[1][1];\n  t[1] = pm.m[1][0] * pm.m[3][1] - pm.m[3][0] * pm.m[1][1];\n  t[2] = pm.m[2][0] * pm.m[3][1] - pm.m[3][0] * pm.m[2][1];\n  v[8] = pm.m[3][3] * t[0] - pm.m[2][3] * t[1] + pm.m[1][3] * t[2];\n  v[12] = -pm.m[3][2] * t[0] + pm.m[2][2] * t[1] - pm.m[1][2] * t[2];\n  //---\n  float det = pm.m[0][0] * v[0] + pm.m[0][1] * v[4] + pm.m[0][2] * v[8] + pm.m[0][3] * v[12];\n  if (det == 0.0f) {\n    for (int j = 0; j < 4; j++)\n      for (int i = 0; i < 4; i++) {\n        pout.m[j, i] = 0.0;\n      }\n    //---\n    return;\n  }\n  if (pdeterminant) pdeterminant = det;\n  //---\n  t[0] = pm.m[2][2] * pm.m[3][3] - pm.m[2][3] * pm.m[3][2];\n  t[1] = pm.m[0][2] * pm.m[3][3] - pm.m[0][3] * pm.m[3][2];\n  t[2] = pm.m[0][2] * pm.m[2][3] - pm.m[0][3] * pm.m[2][2];\n  v[1] = -pm.m[0][1] * t[0] + pm.m[2][1] * t[1] - pm.m[3][1] * t[2];\n  v[5] = pm.m[0][0] * t[0] - pm.m[2][0] * t[1] + pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[0][0] * pm.m[2][1] - pm.m[2][0] * pm.m[0][1];\n  t[1] = pm.m[3][0] * pm.m[0][1] - pm.m[0][0] * pm.m[3][1];\n  t[2] = pm.m[2][0] * pm.m[3][1] - pm.m[3][0] * pm.m[2][1];\n  v[9] = -pm.m[3][3] * t[0] - pm.m[2][3] * t[1] - pm.m[0][3] * t[2];\n  v[13] = pm.m[3][2] * t[0] + pm.m[2][2] * t[1] + pm.m[0][2] * t[2];\n  //---\n  t[0] = pm.m[1][2] * pm.m[3][3] - pm.m[1][3] * pm.m[3][2];\n  t[1] = pm.m[0][2] * pm.m[3][3] - pm.m[0][3] * pm.m[3][2];\n  t[2] = pm.m[0][2] * pm.m[1][3] - pm.m[0][3] * pm.m[1][2];\n  v[2] = pm.m[0][1] * t[0] - pm.m[1][1] * t[1] + pm.m[3][1] * t[2];\n  v[6] = -pm.m[0][0] * t[0] + pm.m[1][0] * t[1] - pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[0][0] * pm.m[1][1] - pm.m[1][0] * pm.m[0][1];\n  t[1] = pm.m[3][0] * pm.m[0][1] - pm.m[0][0] * pm.m[3][1];\n  t[2] = pm.m[1][0] * pm.m[3][1] - pm.m[3][0] * pm.m[1][1];\n  v[10] = pm.m[3][3] * t[0] + pm.m[1][3] * t[1] + pm.m[0][3] * t[2];\n  v[14] = -pm.m[3][2] * t[0] - pm.m[1][2] * t[1] - pm.m[0][2] * t[2];\n  //---\n  t[0] = pm.m[1][2] * pm.m[2][3] - pm.m[1][3] * pm.m[2][2];\n  t[1] = pm.m[0][2] * pm.m[2][3] - pm.m[0][3] * pm.m[2][2];\n  t[2] = pm.m[0][2] * pm.m[1][3] - pm.m[0][3] * pm.m[1][2];\n  v[3] = -pm.m[0][1] * t[0] + pm.m[1][1] * t[1] - pm.m[2][1] * t[2];\n  v[7] = pm.m[0][0] * t[0] - pm.m[1][0] * t[1] + pm.m[2][0] * t[2];\n  //---\n  v[11] = -pm.m[0][0] * (pm.m[1][1] * pm.m[2][3] - pm.m[1][3] * pm.m[2][1]) +\n          pm.m[1][0] * (pm.m[0][1] * pm.m[2][3] - pm.m[0][3] * pm.m[2][1]) -\n          pm.m[2][0] * (pm.m[0][1] * pm.m[1][3] - pm.m[0][3] * pm.m[1][1]);\n  //---\n  v[15] = pm.m[0][0] * (pm.m[1][1] * pm.m[2][2] - pm.m[1][2] * pm.m[2][1]) -\n          pm.m[1][0] * (pm.m[0][1] * pm.m[2][2] - pm.m[0][2] * pm.m[2][1]) +\n          pm.m[2][0] * (pm.m[0][1] * pm.m[1][2] - pm.m[0][2] * pm.m[1][1]);\n  //---\n  det = 1.0f / det;\n  for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++) pout.m[i][j] = v[4 * i + j] * det;\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed,look-at _matrix.                             |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//|                                                                  |\n//| zaxis = normal(At - Eye)                                         |\n//| xaxis = normal(cross(Up,zaxis))                                  |\n//| yaxis = cross(zaxis,xaxis)                                       |\n//|                                                                  |\n//| xaxis.x           yaxis.x           zaxis.x          0           |\n//| xaxis.y           yaxis.y           zaxis.y          0           |\n//| xaxis.z           yaxis.z           zaxis.z          0           |\n//| -dot(xaxis,eye)  -dot(yaxis,eye)  -dot(zaxis,eye)  1             |\n//+------------------------------------------------------------------+\nvoid DXMatrixLookAtLH(DXMatrix &out, const DXVector3 &eye, const DXVector3 &at, const DXVector3 &up) {\n  DXVector3 right, upn, vec;\n  DXVec3Subtract(vec, at, eye);\n  DXVec3Normalize(vec, vec);\n  DXVec3Cross(right, up, vec);\n  DXVec3Cross(upn, vec, right);\n  DXVec3Normalize(right, right);\n  DXVec3Normalize(upn, upn);\n  //---\n  out.m[0][0] = right.x;\n  out.m[1][0] = right.y;\n  out.m[2][0] = right.z;\n  out.m[3][0] = -DXVec3Dot(right, eye);\n  out.m[0][1] = upn.x;\n  out.m[1][1] = upn.y;\n  out.m[2][1] = upn.z;\n  out.m[3][1] = -DXVec3Dot(upn, eye);\n  out.m[0][2] = vec.x;\n  out.m[1][2] = vec.y;\n  out.m[2][2] = vec.z;\n  out.m[3][2] = -DXVec3Dot(vec, eye);\n  out.m[0][3] = 0.0f;\n  out.m[1][3] = 0.0f;\n  out.m[2][3] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed, look-at _matrix.                           |\n//+------------------------------------------------------------------+\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//|                                                                  |\n//| zaxis = normal(Eye - At)                                         |\n//| xaxis = normal(cross(Up,zaxis))                                  |\n//| yaxis = cross(zaxis,xaxis)                                       |\n//|                                                                  |\n//|  xaxis.x           yaxis.x           zaxis.x          0          |\n//|  xaxis.y           yaxis.y           zaxis.y          0          |\n//|  xaxis.z           yaxis.z           zaxis.z          0          |\n//|  dot(xaxis,eye)   dot(yaxis,eye)   dot(zaxis,eye)     1          |\n//+------------------------------------------------------------------+\nvoid DXMatrixLookAtRH(DXMatrix &out, const DXVector3 &eye, const DXVector3 &at, const DXVector3 &up) {\n  DXVector3 right, upn, vec;\n  DXVec3Subtract(vec, at, eye);\n  DXVec3Normalize(vec, vec);\n  DXVec3Cross(right, up, vec);\n  DXVec3Cross(upn, vec, right);\n  DXVec3Normalize(right, right);\n  DXVec3Normalize(upn, upn);\n  //---\n  out.m[0][0] = -right.x;\n  out.m[1][0] = -right.y;\n  out.m[2][0] = -right.z;\n  out.m[3][0] = DXVec3Dot(right, eye);\n  out.m[0][1] = upn.x;\n  out.m[1][1] = upn.y;\n  out.m[2][1] = upn.z;\n  out.m[3][1] = -DXVec3Dot(upn, eye);\n  out.m[0][2] = -vec.x;\n  out.m[1][2] = -vec.y;\n  out.m[2][2] = -vec.z;\n  out.m[3][2] = DXVec3Dot(vec, eye);\n  out.m[0][3] = 0.0f;\n  out.m[1][3] = 0.0f;\n  out.m[2][3] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Determines the product of two matrices.                          |\n//+------------------------------------------------------------------+\nvoid DXMatrixMultiply(DXMatrix &pout, const DXMatrix &pm1, const DXMatrix &pm2) {\n  DXMatrix out = {};\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 4; j++) {\n      out.m[i][j] =\n          pm1.m[i][0] * pm2.m[0][j] + pm1.m[i][1] * pm2.m[1][j] + pm1.m[i][2] * pm2.m[2][j] + pm1.m[i][3] * pm2.m[3][j];\n    }\n  }\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Calculates the transposed product of two matrices.               |\n//+------------------------------------------------------------------+\nvoid DXMatrixMultiplyTranspose(DXMatrix &pout, const DXMatrix &pm1, const DXMatrix &pm2) {\n  DXMatrix temp = {};\n  for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++)\n      temp.m[j][i] =\n          pm1.m[i][0] * pm2.m[0][j] + pm1.m[i][1] * pm2.m[1][j] + pm1.m[i][2] * pm2.m[2][j] + pm1.m[i][3] * pm2.m[3][j];\n  pout = temp;\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed orthographic projection _matrix.             |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoLH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f / w;\n  pout.m[1][1] = 2.0f / h;\n  pout.m[2][2] = 1.0f / (zf - zn);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a customized,left-handed orthographic projection _matrix.  |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoOffCenterLH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f / (r - l);\n  pout.m[1][1] = 2.0f / (t - b);\n  pout.m[2][2] = 1.0f / (zf - zn);\n  pout.m[3][0] = -1.0f - 2.0f * l / (r - l);\n  pout.m[3][1] = 1.0f + 2.0f * t / (b - t);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a customized,right-handed orthographic projection _matrix. |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoOffCenterRH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f / (r - l);\n  pout.m[1][1] = 2.0f / (t - b);\n  pout.m[2][2] = 1.0f / (zn - zf);\n  pout.m[3][0] = -1.0f - 2.0f * l / (r - l);\n  pout.m[3][1] = 1.0f + 2.0f * t / (b - t);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed orthographic projection _matrix.            |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixOrthoRH function               |\n//| are distances in camera space. The parameters describe           |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix:                                             |\n//| 2/w  0    0           0                                          |\n//| 0    2/h  0           0                                          |\n//| 0    0    1/(zn-zf)   0                                          |\n//| 0    0    zn/(zn-zf)  1                                          |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoRH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  pout.m[0][0] = 2.0f / w;\n  pout.m[1][1] = 2.0f / h;\n  pout.m[2][2] = 1.0f / (zn - zf);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed perspective projection _matrix               |\n//| based on a field of view.                                        |\n//+------------------------------------------------------------------+\n//| This function computes the returned _matrix as shown:             |\n//| xScale     0          0               0                          |\n//| 0        yScale       0               0                          |\n//| 0          0       zf/(zf-zn)         1                          |\n//| 0          0       -zn*zf/(zf-zn)     0                          |\n//| where:                                                           |\n//| yScale = cot(fovY/2)                                             |\n//| xScale = yScale / aspect ratio                                   |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveFovLH(DXMatrix &pout, float fovy, float aspect, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f / (aspect * (float)tan(fovy / 2.0f));\n  pout.m[1][1] = 1.0f / (float)tan(fovy / 2.0f);\n  pout.m[2][2] = zf / (zf - zn);\n  pout.m[2][3] = 1.0f;\n  pout.m[3][2] = (zf * zn) / (zn - zf);\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed perspective projection _matrix              |\n//| based on a field of view.                                        |\n//+------------------------------------------------------------------+\n//| This function computes the returned _matrix as shown.             |\n//| xScale     0          0              0                           |\n//| 0        yScale       0              0                           |\n//| 0        0        zf/(zn-zf)        -1                           |\n//| 0        0        zn*zf/(zn-zf)      0                           |\n//| where:                                                           |\n//| yScale = cot(fovY/2)                                             |\n//| xScale = yScale / aspect ratio                                   |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveFovRH(DXMatrix &pout, float fovy, float aspect, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f / (aspect * (float)tan(fovy / 2.0f));\n  pout.m[1][1] = 1.0f / (float)tan(fovy / 2.0f);\n  pout.m[2][2] = zf / (zn - zf);\n  pout.m[2][3] = -1.0f;\n  pout.m[3][2] = (zf * zn) / (zn - zf);\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed perspective projection _matrix               |\n//+------------------------------------------------------------------+\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/w  0       0              0                                 |\n//| 0       2*zn/h  0              0                                 |\n//| 0       0       zf/(zf-zn)     1                                 |\n//| 0       0       zn*zf/(zn-zf)  0                                 |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveLH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  pout.m[0][0] = 2.0f * zn / w;\n  pout.m[1][1] = 2.0f * zn / h;\n  pout.m[2][2] = zf / (zf - zn);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = 1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a customized, left-handed perspective projection _matrix.  |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixPerspectiveOffCenterLH         |\n//| function are distances in camera space. The parameters describe  |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/(r-l)   0            0              0                       |\n//| 0            2*zn/(t-b)   0              0                       |\n//| (l+r)/(l-r)  (t+b)/(b-t)  zf/(zf-zn)     1                       |\n//| 0            0            zn*zf/(zn-zf)  0                       |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveOffCenterLH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f * zn / (r - l);\n  pout.m[1][1] = -2.0f * zn / (b - t);\n  pout.m[2][0] = -1.0f - 2.0f * l / (r - l);\n  pout.m[2][1] = 1.0f + 2.0f * t / (b - t);\n  pout.m[2][2] = -zf / (zn - zf);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = 1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a customized, right-handed perspective projection _matrix. |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixPerspectiveOffCenterRH         |\n//| function are distances in camera space. The parameters describe  |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/(r-l)   0            0                0                     |\n//| 0            2*zn/(t-b)   0                0                     |\n//| (l+r)/(r-l)  (t+b)/(t-b)  zf/(zn-zf)      -1                     |\n//| 0            0            zn*zf/(zn-zf)    0                     |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveOffCenterRH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f * zn / (r - l);\n  pout.m[1][1] = -2.0f * zn / (b - t);\n  pout.m[2][0] = 1.0f + 2.0f * l / (r - l);\n  pout.m[2][1] = -1.0f - 2.0f * t / (b - t);\n  pout.m[2][2] = zf / (zn - zf);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = -1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed perspective projection _matrix.             |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixPerspectiveRH function         |\n//| are distances in camera space. The parameters describe           |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/w  0       0              0                                 |\n//| 0       2*zn/h  0              0                                 |\n//| 0       0       zf/(zn-zf)    -1                                 |\n//| 0       0       zn*zf/(zn-zf)  0                                 |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveRH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f * zn / w;\n  pout.m[1][1] = 2.0f * zn / h;\n  pout.m[2][2] = zf / (zn - zf);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = -1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that reflects the coordinate system about a plane|\n//| This function normalizes the plane equation before it creates    |\n//| the reflected _matrix.                                            |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| P = normalize(Plane);                                            |\n//| -2 * P.a * P.a + 1  -2 * P.b * P.a      -2 * P.c * P.a        0  |\n//| -2 * P.a * P.b      -2 * P.b * P.b + 1  -2 * P.c * P.b        0  |\n//| -2 * P.a * P.c      -2 * P.b * P.c      -2 * P.c * P.c + 1    0  |\n//| -2 * P.a * P.d      -2 * P.b * P.d      -2 * P.c * P.d        1  |\n//+------------------------------------------------------------------+\nvoid DXMatrixReflect(DXMatrix &pout, const DXPlane &pplane) {\n  DXPlane Nplane;\n  DXPlaneNormalize(Nplane, pplane);\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f - 2.0f * Nplane.a * Nplane.a;\n  pout.m[0][1] = -2.0f * Nplane.a * Nplane.b;\n  pout.m[0][2] = -2.0f * Nplane.a * Nplane.c;\n  pout.m[1][0] = -2.0f * Nplane.a * Nplane.b;\n  pout.m[1][1] = 1.0f - 2.0f * Nplane.b * Nplane.b;\n  pout.m[1][2] = -2.0f * Nplane.b * Nplane.c;\n  pout.m[2][0] = -2.0f * Nplane.c * Nplane.a;\n  pout.m[2][1] = -2.0f * Nplane.c * Nplane.b;\n  pout.m[2][2] = 1.0f - 2.0f * Nplane.c * Nplane.c;\n  pout.m[3][0] = -2.0f * Nplane.d * Nplane.a;\n  pout.m[3][1] = -2.0f * Nplane.d * Nplane.b;\n  pout.m[3][2] = -2.0f * Nplane.d * Nplane.c;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around an arbitrary axis.           |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationAxis(DXMatrix &out, const DXVector3 &v, float angle) {\n  DXVector3 nv;\n  DXVec3Normalize(nv, v);\n  //---\n  float sangle = (float)sin(angle);\n  float cangle = (float)cos(angle);\n  float cdiff = 1.0f - cangle;\n  //---\n  out.m[0][0] = cdiff * nv.x * nv.x + cangle;\n  out.m[1][0] = cdiff * nv.x * nv.y - sangle * nv.z;\n  out.m[2][0] = cdiff * nv.x * nv.z + sangle * nv.y;\n  out.m[3][0] = 0.0f;\n  out.m[0][1] = cdiff * nv.y * nv.x + sangle * nv.z;\n  out.m[1][1] = cdiff * nv.y * nv.y + cangle;\n  out.m[2][1] = cdiff * nv.y * nv.z - sangle * nv.x;\n  out.m[3][1] = 0.0f;\n  out.m[0][2] = cdiff * nv.z * nv.x - sangle * nv.y;\n  out.m[1][2] = cdiff * nv.z * nv.y + sangle * nv.x;\n  out.m[2][2] = cdiff * nv.z * nv.z + cangle;\n  out.m[3][2] = 0.0f;\n  out.m[0][3] = 0.0f;\n  out.m[1][3] = 0.0f;\n  out.m[2][3] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a rotation _matrix from a quaternion.                      |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationQuaternion(DXMatrix &pout, const DXQuaternion &pq) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f - 2.0f * (pq.y * pq.y + pq.z * pq.z);\n  pout.m[0][1] = 2.0f * (pq.x * pq.y + pq.z * pq.w);\n  pout.m[0][2] = 2.0f * (pq.x * pq.z - pq.y * pq.w);\n  pout.m[1][0] = 2.0f * (pq.x * pq.y - pq.z * pq.w);\n  pout.m[1][1] = 1.0f - 2.0f * (pq.x * pq.x + pq.z * pq.z);\n  pout.m[1][2] = 2.0f * (pq.y * pq.z + pq.x * pq.w);\n  pout.m[2][0] = 2.0f * (pq.x * pq.z + pq.y * pq.w);\n  pout.m[2][1] = 2.0f * (pq.y * pq.z - pq.x * pq.w);\n  pout.m[2][2] = 1.0f - 2.0f * (pq.x * pq.x + pq.y * pq.y);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around the x-axis.                  |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationX(DXMatrix &pout, float angle) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[1][1] = (float)cos(angle);\n  pout.m[2][2] = (float)cos(angle);\n  pout.m[1][2] = (float)sin(angle);\n  pout.m[2][1] = -(float)sin(angle);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around the y-axis.                  |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationY(DXMatrix &pout, float angle) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = (float)cos(angle);\n  pout.m[2][2] = (float)cos(angle);\n  pout.m[0][2] = -(float)sin(angle);\n  pout.m[2][0] = (float)sin(angle);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix with a specified yaw, pitch, and roll.           |\n//+------------------------------------------------------------------+\n//| The order of transformations is roll first, then pitch, then yaw.|\n//| Relative to the object's local coordinate axis, this is          |\n//| equivalent to rotation around the z-axis, followed by rotation   |\n//| around the x-axis, followed by rotation around the y-axis.       |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationYawPitchRoll(DXMatrix &out, float yaw, float pitch, float roll) {\n  float sroll = (float)sin(roll);\n  float croll = (float)cos(roll);\n  float spitch = (float)sin(pitch);\n  float cpitch = (float)cos(pitch);\n  float syaw = (float)sin(yaw);\n  float cyaw = (float)cos(yaw);\n  //---\n  out.m[0][0] = sroll * spitch * syaw + croll * cyaw;\n  out.m[0][1] = sroll * cpitch;\n  out.m[0][2] = sroll * spitch * cyaw - croll * syaw;\n  out.m[0][3] = 0.0f;\n  out.m[1][0] = croll * spitch * syaw - sroll * cyaw;\n  out.m[1][1] = croll * cpitch;\n  out.m[1][2] = croll * spitch * cyaw + sroll * syaw;\n  out.m[1][3] = 0.0f;\n  out.m[2][0] = cpitch * syaw;\n  out.m[2][1] = -spitch;\n  out.m[2][2] = cpitch * cyaw;\n  out.m[2][3] = 0.0f;\n  out.m[3][0] = 0.0f;\n  out.m[3][1] = 0.0f;\n  out.m[3][2] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around the z-axis.                  |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationZ(DXMatrix &pout, float angle) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = (float)cos(angle);\n  pout.m[1][1] = (float)cos(angle);\n  pout.m[0][1] = (float)sin(angle);\n  pout.m[1][0] = -(float)sin(angle);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that scales along the x-axis,                    |\n//| the y-axis,and the z-axis.                                       |\n//+------------------------------------------------------------------+\nvoid DXMatrixScaling(DXMatrix &pout, float sx, float sy, float sz) {\n  DXMatrixIdentity(pout);\n  pout.m[0][0] = sx;\n  pout.m[1][1] = sy;\n  pout.m[2][2] = sz;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that flattens geometry into a plane.             |\n//+------------------------------------------------------------------+\n//| The DXMatrixShadow function flattens geometry into a plane, as   |\n//| if casting a shadow from a light.                                |\n//| This function uses the following formula to compute the returned |\n//| _matrix.                                                          |\n//|                                                                  |\n//| P = normalize(Plane);                                            |\n//| L = Light;                                                       |\n//| d = -dot(P,L)                                                    |\n//|                                                                  |\n//| P.a * L.x + d  P.a * L.y      P.a * L.z      P.a * L.w           |\n//| P.b * L.x      P.b * L.y + d  P.b * L.z      P.b * L.w           |\n//| P.c * L.x      P.c * L.y      P.c * L.z + d  P.c * L.w           |\n//| P.d * L.x      P.d * L.y      P.d * L.z      P.d * L.w + d       |\n//|                                                                  |\n//| If the light's w-component is 0, the ray from the origin to the  |\n//| light represents a directional light. If it is 1,the light is    |\n//| a point light.                                                   |\n//+------------------------------------------------------------------+\nvoid DXMatrixShadow(DXMatrix &pout, const DXVector4 &plight, const DXPlane &pplane) {\n  DXPlane Nplane;\n  DXPlaneNormalize(Nplane, pplane);\n  float dot = DXPlaneDot(Nplane, plight);\n  //---\n  pout.m[0][0] = dot - Nplane.a * plight.x;\n  pout.m[0][1] = -Nplane.a * plight.y;\n  pout.m[0][2] = -Nplane.a * plight.z;\n  pout.m[0][3] = -Nplane.a * plight.w;\n  pout.m[1][0] = -Nplane.b * plight.x;\n  pout.m[1][1] = dot - Nplane.b * plight.y;\n  pout.m[1][2] = -Nplane.b * plight.z;\n  pout.m[1][3] = -Nplane.b * plight.w;\n  pout.m[2][0] = -Nplane.c * plight.x;\n  pout.m[2][1] = -Nplane.c * plight.y;\n  pout.m[2][2] = dot - Nplane.c * plight.z;\n  pout.m[2][3] = -Nplane.c * plight.w;\n  pout.m[3][0] = -Nplane.d * plight.x;\n  pout.m[3][1] = -Nplane.d * plight.y;\n  pout.m[3][2] = -Nplane.d * plight.z;\n  pout.m[3][3] = dot - Nplane.d * plight.w;\n}\n//+------------------------------------------------------------------+\n//| Builds a transformation _matrix.                                  |\n//+------------------------------------------------------------------+\n//| This function calculates the transformation _matrix with the      |\n//| following formula, with _matrix concatenation evaluated           |\n//| in left-to-right order:                                          |\n//|                                                                  |\n//| Mout = (Msc)^(-1)*(Msr)^(-1)*Ms*Msr*Msc*(Mrc)^(-1)*Mr*Mrc*Mt     |\n//|                                                                  |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Msc = scaling center _matrix (pScalingCenter)                     |\n//| Msr = scaling rotation _matrix (pScalingRotation)                 |\n//| Ms = scaling _matrix (pScaling)                                   |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (pRotation)                                 |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixTransformation(DXMatrix &pout, const DXVector3 &pscalingcenter, const DXQuaternion &pscalingrotation,\n                            const DXVector3 &pscaling, const DXVector3 &protationcenter, const DXQuaternion &protation,\n                            const DXVector3 &ptranslation) {\n  DXMatrix m1, m2, m3, m4, m5, m6, m7;\n  DXQuaternion prc;\n  DXVector3 psc, pt;\n  //--- pscalingcenter\n  psc.x = pscalingcenter.x;\n  psc.y = pscalingcenter.y;\n  psc.z = pscalingcenter.z;\n  //--- protationcenter\n  prc.x = protationcenter.x;\n  prc.y = protationcenter.y;\n  prc.z = protationcenter.z;\n  //--- ptranslation\n  pt.x = ptranslation.x;\n  pt.y = ptranslation.y;\n  pt.z = ptranslation.z;\n  DXMatrixTranslation(m1, -psc.x, -psc.y, -psc.z);\n  //---\n  DXQuaternion temp;\n  DXMatrixRotationQuaternion(m4, pscalingrotation);\n  temp.w = pscalingrotation.w;\n  temp.x = -pscalingrotation.x;\n  temp.y = -pscalingrotation.y;\n  temp.z = -pscalingrotation.z;\n  DXMatrixRotationQuaternion(m2, temp);\n  //--- pscaling\n  DXMatrixScaling(m3, pscaling.x, pscaling.y, pscaling.z);\n  //--- protation\n  DXMatrixRotationQuaternion(m6, protation);\n  //---\n  DXMatrixTranslation(m5, psc.x - prc.x, psc.y - prc.y, psc.z - prc.z);\n  DXMatrixTranslation(m7, prc.x + pt.x, prc.y + pt.y, prc.z + pt.z);\n  DXMatrixMultiply(m1, m1, m2);\n  DXMatrixMultiply(m1, m1, m3);\n  DXMatrixMultiply(m1, m1, m4);\n  DXMatrixMultiply(m1, m1, m5);\n  DXMatrixMultiply(m1, m1, m6);\n  DXMatrixMultiply(pout, m1, m7);\n}\n//+------------------------------------------------------------------+\n//| Builds a 2D transformation _matrix that represents                |\n//| transformations in the xy plane.                                 |\n//+------------------------------------------------------------------+\n//| This function calculates the transformation _matrix with the      |\n//| following formula, with _matrix concatenation evaluated           |\n//| in left-to-right order:                                          |\n//|                                                                  |\n//| Mout = (Msc)^(-1)*(Msr)^(-1)*Ms*Msr*Msc*(Mrc)^(-1)*Mr*Mrc*Mt     |\n//|                                                                  |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Msc = scaling center _matrix (pScalingCenter)                     |\n//| Msr = scaling rotation _matrix (pScalingRotation)                 |\n//| Ms = scaling _matrix (pScaling)                                   |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (Rotation)                                  |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixTransformation2D(DXMatrix &pout, const DXVector2 &pscalingcenter, float scalingrotation,\n                              const DXVector2 &pscaling, const DXVector2 &protationcenter, float rotation,\n                              const DXVector2 &ptranslation) {\n  DXQuaternion rot, sca_rot;\n  DXVector3 rot_center, sca, sca_center, trans;\n  //--- pscalingcenter\n  sca_center.x = pscalingcenter.x;\n  sca_center.y = pscalingcenter.y;\n  sca_center.z = 0.0f;\n  //--- pscaling\n  sca.x = pscaling.x;\n  sca.y = pscaling.y;\n  sca.z = 1.0f;\n  //--- protationcenter\n  rot_center.x = protationcenter.x;\n  rot_center.y = protationcenter.y;\n  rot_center.z = 0.0f;\n  //--- ptranslation\n  trans.x = ptranslation.x;\n  trans.y = ptranslation.y;\n  trans.z = 0.0f;\n  //---\n  rot.w = (float)cos(rotation / 2.0f);\n  rot.x = 0.0f;\n  rot.y = 0.0f;\n  rot.z = (float)sin(rotation / 2.0f);\n  //---\n  sca_rot.w = (float)cos(scalingrotation / 2.0f);\n  sca_rot.x = 0.0f;\n  sca_rot.y = 0.0f;\n  sca_rot.z = (float)sin(scalingrotation / 2.0f);\n  DXMatrixTransformation(pout, sca_center, sca_rot, sca, rot_center, rot, trans);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix using the specified offsets.                     |\n//+------------------------------------------------------------------+\nvoid DXMatrixTranslation(DXMatrix &pout, float x, float y, float z) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[3][0] = x;\n  pout.m[3][1] = y;\n  pout.m[3][2] = z;\n}\n//+------------------------------------------------------------------+\n//| Returns the _matrix transpose of a _matrix.                        |\n//+------------------------------------------------------------------+\nvoid DXMatrixTranspose(DXMatrix &pout, const DXMatrix &pm) {\n  const DXMatrix m = pm;\n  for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++) pout.m[i][j] = m.m[j][i];\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of a plane and a 4D vector.             |\n//+------------------------------------------------------------------+\nfloat DXPlaneDot(const DXPlane &p1, const DXVector4 &p2) {\n  return (p1.a * p2.x + p1.b * p2.y + p1.c * p2.z + p1.d * p2.w);\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of a plane and a 3D vector.             |\n//| The w parameter of the vector is assumed to be 1.                |\n//+------------------------------------------------------------------+\nfloat DXPlaneDotCoord(const DXPlane &pp, const DXVector4 &pv) {\n  return (pp.a * pv.x + pp.b * pv.y + pp.c * pv.z + pp.d);\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of a plane and a 3D vector.             |\n//| The w parameter of the vector is assumed to be 0.                |\n//+------------------------------------------------------------------+\nfloat DXPlaneDotNormal(const DXPlane &pp, const DXVector4 &pv) { return (pp.a * pv.x + pp.b * pv.y + pp.c * pv.z); }\n//+------------------------------------------------------------------+\n//| Constructs a plane from a point and a normal.                    |\n//+------------------------------------------------------------------+\nvoid DXPlaneFromPointNormal(DXPlane &pout, const DXVector3 &pvpoint, const DXVector3 &pvnormal) {\n  pout.a = pvnormal.x;\n  pout.b = pvnormal.y;\n  pout.c = pvnormal.z;\n  pout.d = -DXVec3Dot(pvpoint, pvnormal);\n}\n//+------------------------------------------------------------------+\n//| Constructs a plane from three points.                            |\n//+------------------------------------------------------------------+\nvoid DXPlaneFromPoints(DXPlane &pout, const DXVector3 &pv1, const DXVector3 &pv2, const DXVector3 &pv3) {\n  DXVector3 edge1, edge2, normal, Nnormal;\n  //---\n  edge1.x = 0.0f;\n  edge1.y = 0.0f;\n  edge1.z = 0.0f;\n  edge2.x = 0.0f;\n  edge2.y = 0.0f;\n  edge2.z = 0.0f;\n  //---\n  DXVec3Subtract(edge1, pv2, pv1);\n  DXVec3Subtract(edge2, pv3, pv1);\n  DXVec3Cross(normal, edge1, edge2);\n  DXVec3Normalize(Nnormal, normal);\n  DXPlaneFromPointNormal(pout, pv1, Nnormal);\n}\n//+------------------------------------------------------------------+\n//| Finds the intersection between a plane and a line.               |\n//| If the line is parallel to the plane, null vector is returned.   |\n//+------------------------------------------------------------------+\nvoid DXPlaneIntersectLine(DXVector3 &pout, const DXPlane &pp, const DXVector3 &pv1, const DXVector3 &pv2) {\n  DXVector3 direction, normal;\n  normal.x = pp.a;\n  normal.y = pp.b;\n  normal.z = pp.c;\n  direction.x = pv2.x - pv1.x;\n  direction.y = pv2.y - pv1.y;\n  direction.z = pv2.z - pv1.z;\n  //---\n  float dot = DXVec3Dot(normal, direction);\n  if (!dot) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n  }\n  float temp = (pp.d + DXVec3Dot(normal, pv1)) / dot;\n  pout.x = pv1.x - temp * direction.x;\n  pout.y = pv1.y - temp * direction.y;\n  pout.z = pv1.z - temp * direction.z;\n}\n//+------------------------------------------------------------------+\n//| Normalizes the plane coefficients so that the plane normal       |\n//| has unit length.                                                 |\n//| This function normalizes a plane so that |a,b,c| == 1.           |\n//+------------------------------------------------------------------+\nvoid DXPlaneNormalize(DXPlane &out, const DXPlane &p) {\n  float norm = (float)sqrt(p.a * p.a + p.b * p.b + p.c * p.c);\n  if (norm) {\n    out.a = p.a / norm;\n    out.b = p.b / norm;\n    out.c = p.c / norm;\n    out.d = p.d / norm;\n  } else {\n    out.a = 0.0f;\n    out.b = 0.0f;\n    out.c = 0.0f;\n    out.d = 0.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Scale the plane with the given scaling factor.                   |\n//+------------------------------------------------------------------+\nvoid DXPlaneScale(DXPlane &pout, const DXPlane &p, float s) {\n  pout.a = p.a * s;\n  pout.b = p.b * s;\n  pout.c = p.c * s;\n  pout.d = p.d * s;\n};\n//+------------------------------------------------------------------+\n//| Transforms a plane by a _matrix.                                  |\n//| The input _matrix is the inverse transpose of the actual          |\n//| transformation.                                                  |\n//+------------------------------------------------------------------+\nvoid DXPlaneTransform(DXPlane &pout, const DXPlane &pplane, const DXMatrix &pm) {\n  DXPlane plane = pplane;\n  //---\n  pout.a = pm.m[0][0] * plane.a + pm.m[1][0] * plane.b + pm.m[2][0] * plane.c + pm.m[3][0] * plane.d;\n  pout.b = pm.m[0][1] * plane.a + pm.m[1][1] * plane.b + pm.m[2][1] * plane.c + pm.m[3][1] * plane.d;\n  pout.c = pm.m[0][2] * plane.a + pm.m[1][2] * plane.b + pm.m[2][2] * plane.c + pm.m[3][2] * plane.d;\n  pout.d = pm.m[0][3] * plane.a + pm.m[1][3] * plane.b + pm.m[2][3] * plane.c + pm.m[3][3] * plane.d;\n}\n//+------------------------------------------------------------------+\n//| Adds two spherical harmonic (SH) vectors; in other words,        |\n//| out[i] = a[i] + b[i].                                            |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m) is stored          |\n//| at memory location l^2 + m + l,where:                            |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHAdd(float &out[], int order, const float &a[], const float &b[]) {\n  for (int i = 0; i < order * order; i++) out[i] = a[i] + b[i];\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of two spherical harmonic (SH) vectors. |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m) is stored          |\n//| at memory location l^2 + m + l,where:                            |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l,inclusive.                             |\n//+------------------------------------------------------------------+\nfloat DXSHDot(int order, const float &a[], const float &b[]) {\n  float s = a[0] * b[0];\n  for (int i = 1; i < order * order; i++) s += a[i] * b[i];\n  //---\n  return (s);\n}\n//+------------------------------------------------------------------+\n//| weightedcapintegrale                                             |\n//+------------------------------------------------------------------+\nvoid weightedcapintegrale(float &out[], unsigned int order, float angle) {\n  float coeff[3];\n  coeff[0] = (float)cos(angle);\n\n  out[0] = 2.0f * DX_PI * (1.0f - coeff[0]);\n  out[1] = DX_PI * (float)sin(angle) * (float)sin(angle);\n  if (order <= 2) return;\n\n  out[2] = coeff[0] * out[1];\n  if (order == 3) return;\n\n  coeff[1] = coeff[0] * coeff[0];\n  coeff[2] = coeff[1] * coeff[1];\n\n  out[3] = DX_PI * (-1.25f * coeff[2] + 1.5f * coeff[1] - 0.25f);\n  if (order == 4) return;\n\n  out[4] = -0.25f * DX_PI * coeff[0] * (7.0f * coeff[2] - 10.0f * coeff[1] + 3.0f);\n  if (order == 5) return;\n\n  out[5] = DX_PI * (-2.625f * coeff[2] * coeff[1] + 4.375f * coeff[2] - 1.875f * coeff[1] + 0.125f);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a light that is a cone of constant intensity           |\n//| and returns spectral spherical harmonic (SH) data.               |\n//+------------------------------------------------------------------+\n//| Evaluates a light that is a cone of constant intensity and       |\n//| returns spectral SH data.                                        |\n//| The output vector is computed so that if the intensity ratio     |\n//| R/G/B is equal to 1, the exit radiance of a point                |\n//| directly under the light (oriented in the cone direction         |\n//| on a diffuse object with an albedo of 1) would be 1.0.           |\n//| This will compute three spectral samples;                        |\n//| rout[], gout[] and bout[] will be computed.                      |\n//+------------------------------------------------------------------+\nint DXSHEvalConeLight(int order, const DXVector3 &dir, float radius, float Rintensity, float Gintensity,\n                      float Bintensity, float &rout[], float &gout[], float &bout[]) {\n  float cap[6];\n  //---\n  if (radius <= 0.0f)\n    return (DXSHEvalDirectionalLight(order, dir, Rintensity, Gintensity, Bintensity, rout, gout, bout));\n  //---\n  float clamped_angle = (radius > DX_PI / 2.0f) ? (DX_PI / 2.0f) : radius;\n  float norm = (float)sin(clamped_angle) * (float)sin(clamped_angle);\n  if (order > DXSH_MAXORDER) {\n    //--- order clamped at DXSH_MAXORDER\n    order = DXSH_MAXORDER;\n  }\n  //---\n  weightedcapintegrale(cap, order, radius);\n  DXSHEvalDirection(rout, order, dir);\n  //---\n  for (int i = 0; i < order; i++) {\n    float scale = cap[i] / norm;\n    for (int j = 0; j < 2 * i + 1; j++) {\n      int index = i * i + j;\n      float temp = rout[index] * scale;\n      rout[index] = temp * Rintensity;\n      gout[index] = temp * Gintensity;\n      bout[index] = temp * Bintensity;\n    }\n  }\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Evaluates the spherical harmonic (SH) basis functions            |\n//| from an input direction vector.                                  |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m) is stored          |\n//| at memory location l^2 + m + l, where:                           |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHEvalDirection(float &out[], int order, const DXVector3 &dir) {\n  const float dirxx = dir.x * dir.x;\n  const float dirxy = dir.x * dir.y;\n  const float dirxz = dir.x * dir.z;\n  const float diryy = dir.y * dir.y;\n  const float diryz = dir.y * dir.z;\n  const float dirzz = dir.z * dir.z;\n  const float dirxxxx = dirxx * dirxx;\n  const float diryyyy = diryy * diryy;\n  const float dirzzzz = dirzz * dirzz;\n  const float dirxyxy = dirxy * dirxy;\n  //---\n  if ((order < DXSH_MINORDER) || (order > DXSH_MAXORDER)) return;\n\n  out[0] = 0.5f / (float)sqrt(DX_PI);\n  out[1] = -0.5f / (float)sqrt(DX_PI / 3.0f) * dir.y;\n  out[2] = 0.5f / (float)sqrt(DX_PI / 3.0f) * dir.z;\n  out[3] = -0.5f / (float)sqrt(DX_PI / 3.0f) * dir.x;\n  if (order == 2) return;\n\n  out[4] = 0.5f / (float)sqrt(DX_PI / 15.0f) * dirxy;\n  out[5] = -0.5f / (float)sqrt(DX_PI / 15.0f) * diryz;\n  out[6] = 0.25f / (float)sqrt(DX_PI / 5.0f) * (3.0f * dirzz - 1.0f);\n  out[7] = -0.5f / (float)sqrt(DX_PI / 15.0f) * dirxz;\n  out[8] = 0.25f / (float)sqrt(DX_PI / 15.0f) * (dirxx - diryy);\n  if (order == 3) return;\n\n  out[9] = -(float)sqrt(70.0f / DX_PI) / 8.0f * dir.y * (3.0f * dirxx - diryy);\n  out[10] = (float)sqrt(105.0f / DX_PI) / 2.0f * dirxy * dir.z;\n  out[11] = -(float)sqrt(42.0f / DX_PI) / 8.0f * dir.y * (-1.0f + 5.0f * dirzz);\n  out[12] = (float)sqrt(7.0f / DX_PI) / 4.0f * dir.z * (5.0f * dirzz - 3.0f);\n  out[13] = (float)sqrt(42.0f / DX_PI) / 8.0f * dir.x * (1.0f - 5.0f * dirzz);\n  out[14] = (float)sqrt(105.0f / DX_PI) / 4.0f * dir.z * (dirxx - diryy);\n  out[15] = -(float)sqrt(70.0f / DX_PI) / 8.0f * dir.x * (dirxx - 3.0f * diryy);\n  if (order == 4) return;\n\n  out[16] = 0.75f * float(sqrt(35.0f / DX_PI)) * dirxy * (dirxx - diryy);\n  out[17] = 3.0f * dir.z * out[9];\n  out[18] = 0.75f * (float)sqrt(5.0f / DX_PI) * dirxy * (7.0f * dirzz - 1.0f);\n  out[19] = 0.375f * (float)sqrt(10.0f / DX_PI) * diryz * (3.0f - 7.0f * dirzz);\n  out[20] = 3.0f / (16.0f * (float)sqrt(DX_PI)) * (35.0f * dirzzzz - 30.f * dirzz + 3.0f);\n  out[21] = 0.375f * (float)sqrt(10.0f / DX_PI) * dirxz * (3.0f - 7.0f * dirzz);\n  out[22] = 0.375f * (float)sqrt(5.0f / DX_PI) * (dirxx - diryy) * (7.0f * dirzz - 1.0f);\n  out[23] = 3.0f * dir.z * out[15];\n  out[24] = 3.0f / 16.0f * float(sqrt(35.0f / DX_PI)) * (dirxxxx - 6.0f * dirxyxy + diryyyy);\n  if (order == 5) return;\n\n  out[25] = -3.0f / 32.0f * (float)sqrt(154.0f / DX_PI) * dir.y * (5.0f * dirxxxx - 10.0f * dirxyxy + diryyyy);\n  out[26] = 0.75f * (float)sqrt(385.0f / DX_PI) * dirxy * dir.z * (dirxx - diryy);\n  out[27] = (float)sqrt(770.0f / DX_PI) / 32.0f * dir.y * (3.0f * dirxx - diryy) * (1.0f - 9.0f * dirzz);\n  out[28] = (float)sqrt(1155.0f / DX_PI) / 4.0f * dirxy * dir.z * (3.0f * dirzz - 1.0f);\n  out[29] = (float)sqrt(165.0f / DX_PI) / 16.0f * dir.y * (14.0f * dirzz - 21.0f * dirzzzz - 1.0f);\n  out[30] = (float)sqrt(11.0f / DX_PI) / 16.0f * dir.z * (63.0f * dirzzzz - 70.0f * dirzz + 15.0f);\n  out[31] = (float)sqrt(165.0f / DX_PI) / 16.0f * dir.x * (14.0f * dirzz - 21.0f * dirzzzz - 1.0f);\n  out[32] = (float)sqrt(1155.0f / DX_PI) / 8.0f * dir.z * (dirxx - diryy) * (3.0f * dirzz - 1.0f);\n  out[33] = (float)sqrt(770.0f / DX_PI) / 32.0f * dir.x * (dirxx - 3.0f * diryy) * (1.0f - 9.0f * dirzz);\n  out[34] = 3.0f / 16.0f * (float)sqrt(385.0f / DX_PI) * dir.z * (dirxxxx - 6.0f * dirxyxy + diryyyy);\n  out[35] = -3.0f / 32.0f * (float)sqrt(154.0f / DX_PI) * dir.x * (dirxxxx - 10.0f * dirxyxy + 5.0f * diryyyy);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a directional light and                                |\n//| returns spectral spherical harmonic (SH) data.                   |\n//+------------------------------------------------------------------+\n//| The output vector is computed so that if the intensity ratio     |\n//| R/G/B is equal to 1 ,the resulting exit radiance of a point      |\n//| directly under the light on a diffuse object with an albedo      |\n//| of 1 would be 1.0. This will compute three spectral samples;     |\n//| rout[], gout[] and bout[] will be returned.                      |\n//+------------------------------------------------------------------+\nint DXSHEvalDirectionalLight(int order, const DXVector3 &dir, float Rintensity, float Gintensity, float Bintensity,\n                             float &rout[], float &gout[], float &bout[]) {\n  float s = 0.75f;\n  if (order > 2) s += 5.0f / 16.0f;\n  if (order > 4) s -= 3.0f / 32.0f;\n  s /= DX_PI;\n\n  DXSHEvalDirection(rout, order, dir);\n  for (int j = 0; j < order * order; j++) {\n    float temp = rout[j] / s;\n    rout[j] = Rintensity * temp;\n    gout[j] = Gintensity * temp;\n    bout[j] = Bintensity * temp;\n  }\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a light that is a linear interpolation                 |\n//| between two colors over the sphere.                              |\n//+------------------------------------------------------------------+\n//| The interpolation is done linearly between the two points,       |\n//| not over the surface of the sphere (that is, if the axis was     |\n//| (0,0,1) it is linear in Z, not in the azimuthal angle).          |\n//| The resulting spherical lighting function is normalized so that  |\n//| a point on a perfectly diffuse surface with no shadowing         |\n//| and a normal pointed in the direction pDir would result in exit  |\n//| radiance with a value of 1 (if the top color was white           |\n//| and the bottom color was black). This is a very simple model     |\n//| where Top represents the intensity of the \"sky\"                  |\n//| and Bottom represents the intensity of the \"ground\".             |\n//+------------------------------------------------------------------+\nint DXSHEvalHemisphereLight(int order, const DXVector3 &dir, DXColor &top, DXColor &bottom, float &rout[],\n                            float &gout[], float &bout[]) {\n  float a[2], temp[4];\n  DXSHEvalDirection(temp, 2, dir);\n  //--- rout\n  a[0] = (top.r + bottom.r) * 3.0f * DX_PI;\n  a[1] = (top.r - bottom.r) * DX_PI;\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++)\n      if (i < 2)\n        rout[i * i + j] = temp[i * i + j] * a[i];\n      else\n        rout[i * i + j] = 0.0f;\n  //--- gout\n  a[0] = (top.g + bottom.g) * 3.0f * DX_PI;\n  a[1] = (top.g - bottom.g) * DX_PI;\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++)\n      if (i < 2)\n        gout[i * i + j] = temp[i * i + j] * a[i];\n      else\n        gout[i * i + j] = 0.0f;\n  //--- bout\n  a[0] = (top.b + bottom.b) * 3.0f * DX_PI;\n  a[1] = (top.b - bottom.b) * DX_PI;\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++)\n      if (i < 2)\n        bout[i * i + j] = temp[i * i + j] * a[i];\n      else\n        bout[i * i + j] = 0.0f;\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a spherical light and returns                          |\n//| spectral spherical harmonic (SH) data.                           |\n//+------------------------------------------------------------------+\n//| There is no normalization of the intensity of the light like     |\n//| there is for directional lights, so care has to be taken when    |\n//| specifying the intensities.                                      |\n//| This will compute three spectral samples;                        |\n//| rout[], gout[], bout[] will be returned.                         |\n//+------------------------------------------------------------------+\nint DXSHEvalSphericalLight(int order, const DXVector3 &dir, float radius, float Rintensity, float Gintensity,\n                           float Bintensity, float &rout[], float &gout[], float &bout[]) {\n  DXVector3 normal;\n  float cap[6];\n  //--- check order\n  if (order > DXSH_MAXORDER) order = DXSH_MAXORDER;\n  //--- check radius\n  if (radius < 0.0f) radius = -radius;\n\n  float dist = DXVec3Length(dir);\n  float clamped_angle = (dist <= radius) ? DX_PI / 2.0f : (float)asin(radius / dist);\n\n  weightedcapintegrale(cap, order, clamped_angle);\n  DXVec3Normalize(normal, dir);\n  DXSHEvalDirection(rout, order, normal);\n\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++) {\n      int index = i * i + j;\n      float temp = rout[index] * cap[i];\n      rout[index] = temp * Rintensity;\n      gout[index] = temp * Gintensity;\n      bout[index] = temp * Bintensity;\n    }\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Computes the product of two functions represented                |\n//| using Spherical Harmonics (f and g).                             |\n//+------------------------------------------------------------------+\n//| The order is a number between 2 and 6 inclusive.                 |\n//| So it's the same for the several functions:                      |\n//| DXSHMultiply2, DXSHMultiply3, ... DXSHMultiply6.                 |\n//|                                                                  |\n//| Computes the product of two functions represented                |\n//| using SH (f and g),where                                         |\n//|               out[i] = int(y_i(s) * f(s) * g(s)),                |\n//| where                                                            |\n//|       y_i(s) is the ith SH basis function,                       |\n//|       f(s) and g(s) are SH functions (sum_i(y_i(s)*c_i)).        |\n//| The order determines the lengths of the arrays, where there      |\n//| should always be l^2 coefficients.                               |\n//|                                                                  |\n//| In general the product of two SH functions of order l generates  |\n//| an SH function of order 2*l - 1, but the results are truncated.  |\n//|                                                                  |\n//| This means that the product commutes (f*g == g*f)                |\n//| but doesn't associate (f*(g*h) != (f*g)*h.                       |\n//+------------------------------------------------------------------+\nvoid DXSHMultiply2(float &out[], const float &a[], const float &b[]) {\n  float ta = 0.28209479f * a[0];\n  float tb = 0.28209479f * b[0];\n  out[0] = 0.28209479f * DXSHDot(2, a, b);\n  out[1] = ta * b[1] + tb * a[1];\n  out[2] = ta * b[2] + tb * a[2];\n  out[3] = ta * b[3] + tb * a[3];\n}\n//+------------------------------------------------------------------+\n//| Computes the product of two functions represented using          |\n//| Spherical Harmonics (f and g). Both functions are of order N=3.  |\n//+------------------------------------------------------------------+\n//| The order is a number between 2 and 6 inclusive.                 |\n//| So it's the same for the several functions:                      |\n//| DXSHMultiply2, DXSHMultiply3, ... DXSHMultiply6.                 |\n//|                                                                  |\n//| Computes the product of two functions represented                |\n//| using SH (f and g),where                                         |\n//|               out[i] = int(y_i(s) * f(s) * g(s)),                |\n//| where                                                            |\n//|       y_i(s) is the ith SH basis function,                       |\n//|       f(s) and g(s) are SH functions (sum_i(y_i(s)*c_i)).        |\n//| The order determines the lengths of the arrays,where there       |\n//| should always be l^2 coefficients.                               |\n//|                                                                  |\n//| In general the product of two SH functions of order l generates  |\n//| an SH function of order 2*l - 1, but the results are truncated.  |\n//|                                                                  |\n//| This means that the product commutes (f*g == g*f)                |\n//| but doesn't associate (f*(g*h) != (f*g)*h.                       |\n//+------------------------------------------------------------------+\nvoid DXSHMultiply3(float &out[], const float &a[], const float &b[]) {\n  out[0] = 0.28209479f * a[0] * b[0];\n  float ta = 0.28209479f * a[0] - 0.12615663f * a[6] - 0.21850969f * a[8];\n  float tb = 0.28209479f * b[0] - 0.12615663f * b[6] - 0.21850969f * b[8];\n  out[1] = ta * b[1] + tb * a[1];\n  float t = a[1] * b[1];\n  out[0] += 0.28209479f * t;\n  out[6] = -0.12615663f * t;\n  out[8] = -0.21850969f * t;\n\n  ta = 0.21850969f * a[5];\n  tb = 0.21850969f * b[5];\n  out[1] += ta * b[2] + tb * a[2];\n  out[2] = ta * b[1] + tb * a[1];\n  t = a[1] * b[2] + a[2] * b[1];\n  out[5] = 0.21850969f * t;\n\n  ta = 0.21850969f * a[4];\n  tb = 0.21850969f * b[4];\n  out[1] += ta * b[3] + tb * a[3];\n  out[3] = ta * b[1] + tb * a[1];\n  t = a[1] * b[3] + a[3] * b[1];\n  out[4] = 0.21850969f * t;\n\n  ta = 0.28209480f * a[0] + 0.25231326f * a[6];\n  tb = 0.28209480f * b[0] + 0.25231326f * b[6];\n  out[2] += ta * b[2] + tb * a[2];\n  t = a[2] * b[2];\n  out[0] += 0.28209480f * t;\n  out[6] += 0.25231326f * t;\n\n  ta = 0.21850969f * a[7];\n  tb = 0.21850969f * b[7];\n  out[2] += ta * b[3] + tb * a[3];\n  out[3] += ta * b[2] + tb * a[2];\n  t = a[2] * b[3] + a[3] * b[2];\n  out[7] = 0.21850969f * t;\n\n  ta = 0.28209479f * a[0] - 0.12615663f * a[6] + 0.21850969f * a[8];\n  tb = 0.28209479f * b[0] - 0.12615663f * b[6] + 0.21850969f * b[8];\n  out[3] += ta * b[3] + tb * a[3];\n  t = a[3] * b[3];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.12615663f * t;\n  out[8] += 0.21850969f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[4] += ta * b[4] + tb * a[4];\n  t = a[4] * b[4];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n\n  ta = 0.15607835f * a[7];\n  tb = 0.15607835f * b[7];\n  out[4] += ta * b[5] + tb * a[5];\n  out[5] += ta * b[4] + tb * a[4];\n  t = a[4] * b[5] + a[5] * b[4];\n  out[7] += 0.15607835f * t;\n\n  ta = 0.28209479f * a[0] + 0.09011188f * a[6] - 0.15607835f * a[8];\n  tb = 0.28209479f * b[0] + 0.09011188f * b[6] - 0.15607835f * b[8];\n  out[5] += ta * b[5] + tb * a[5];\n  t = a[5] * b[5];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.09011188f * t;\n  out[8] -= 0.15607835f * t;\n\n  ta = 0.28209480f * a[0];\n  tb = 0.28209480f * b[0];\n  out[6] += ta * b[6] + tb * a[6];\n  t = a[6] * b[6];\n  out[0] += 0.28209480f * t;\n  out[6] += 0.18022376f * t;\n\n  ta = 0.28209479f * a[0] + 0.09011188f * a[6] + 0.15607835f * a[8];\n  tb = 0.28209479f * b[0] + 0.09011188f * b[6] + 0.15607835f * b[8];\n  out[7] += ta * b[7] + tb * a[7];\n  t = a[7] * b[7];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.09011188f * t;\n  out[8] += 0.15607835f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[8] += ta * b[8] + tb * a[8];\n  t = a[8] * b[8];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n}\n//+------------------------------------------------------------------+\n//| Computes the product of two functions represented using          |\n//| Spherical Harmonics (f and g). Both functions are of order N=4.  |\n//+------------------------------------------------------------------+\n//| The order is a number between 2 and 6 inclusive.                 |\n//| So it's the same for the several functions:                      |\n//| DXSHMultiply2, DXSHMultiply3, ... DXSHMultiply6.                 |\n//|                                                                  |\n//| Computes the product of two functions represented                |\n//| using SH (f and g), where                                        |\n//|               out[i] = int(y_i(s) * f(s) * g(s)),                |\n//| where                                                            |\n//|       y_i(s) is the ith SH basis function,                       |\n//|       f(s) and g(s) are SH functions (sum_i(y_i(s)*c_i)).        |\n//| The order determines the lengths of the arrays,where there       |\n//| should always be l^2 coefficients.                               |\n//|                                                                  |\n//| In general the product of two SH functions of order l generates  |\n//| an SH function of order 2*l - 1, but the results are truncated.  |\n//|                                                                  |\n//| This means that the product commutes (f*g == g*f)                |\n//| but doesn't associate (f*(g*h) != (f*g)*h.                       |\n//+------------------------------------------------------------------+\nvoid DXSHMultiply4(float &out[], const float &a[], const float &b[]) {\n  out[0] = 0.28209479f * a[0] * b[0];\n  float ta = 0.28209479f * a[0] - 0.12615663f * a[6] - 0.21850969f * a[8];\n  float tb = 0.28209479f * b[0] - 0.12615663f * b[6] - 0.21850969f * b[8];\n  out[1] = ta * b[1] + tb * a[1];\n  float t = a[1] * b[1];\n  out[0] += 0.28209479f * t;\n  out[6] = -0.12615663f * t;\n  out[8] = -0.21850969f * t;\n\n  ta = 0.21850969f * a[3] - 0.05839917f * a[13] - 0.22617901f * a[15];\n  tb = 0.21850969f * b[3] - 0.05839917f * b[13] - 0.22617901f * b[15];\n  out[1] += ta * b[4] + tb * a[4];\n  out[4] = ta * b[1] + tb * a[1];\n  t = a[1] * b[4] + a[4] * b[1];\n  out[3] = 0.21850969f * t;\n  out[13] = -0.05839917f * t;\n  out[15] = -0.22617901f * t;\n\n  ta = 0.21850969f * a[2] - 0.14304817f * a[12] - 0.18467439f * a[14];\n  tb = 0.21850969f * b[2] - 0.14304817f * b[12] - 0.18467439f * b[14];\n  out[1] += ta * b[5] + tb * a[5];\n  out[5] = ta * b[1] + tb * a[1];\n  t = a[1] * b[5] + a[5] * b[1];\n  out[2] = 0.21850969f * t;\n  out[12] = -0.14304817f * t;\n  out[14] = -0.18467439f * t;\n\n  ta = 0.20230066f * a[11];\n  tb = 0.20230066f * b[11];\n  out[1] += ta * b[6] + tb * a[6];\n  out[6] += ta * b[1] + tb * a[1];\n  t = a[1] * b[6] + a[6] * b[1];\n  out[11] = 0.20230066f * t;\n\n  ta = 0.22617901f * a[9] + 0.05839917f * a[11];\n  tb = 0.22617901f * b[9] + 0.05839917f * b[11];\n  out[1] += ta * b[8] + tb * a[8];\n  out[8] += ta * b[1] + tb * a[1];\n  t = a[1] * b[8] + a[8] * b[1];\n  out[9] = 0.22617901f * t;\n  out[11] += 0.05839917f * t;\n\n  ta = 0.28209480f * a[0] + 0.25231326f * a[6];\n  tb = 0.28209480f * b[0] + 0.25231326f * b[6];\n  out[2] += ta * b[2] + tb * a[2];\n  t = a[2] * b[2];\n  out[0] += 0.28209480f * t;\n  out[6] += 0.25231326f * t;\n\n  ta = 0.24776671f * a[12];\n  tb = 0.24776671f * b[12];\n  out[2] += ta * b[6] + tb * a[6];\n  out[6] += ta * b[2] + tb * a[2];\n  t = a[2] * b[6] + a[6] * b[2];\n  out[12] += 0.24776671f * t;\n\n  ta = 0.28209480f * a[0] - 0.12615663f * a[6] + 0.21850969f * a[8];\n  tb = 0.28209480f * b[0] - 0.12615663f * b[6] + 0.21850969f * b[8];\n  out[3] += ta * b[3] + tb * a[3];\n  t = a[3] * b[3];\n  out[0] += 0.28209480f * t;\n  out[6] -= 0.12615663f * t;\n  out[8] += 0.21850969f * t;\n\n  ta = 0.20230066f * a[13];\n  tb = 0.20230066f * b[13];\n  out[3] += ta * b[6] + tb * a[6];\n  out[6] += ta * b[3] + tb * a[3];\n  t = a[3] * b[6] + a[6] * b[3];\n  out[13] += 0.20230066f * t;\n\n  ta = 0.21850969f * a[2] - 0.14304817f * a[12] + 0.18467439f * a[14];\n  tb = 0.21850969f * b[2] - 0.14304817f * b[12] + 0.18467439f * b[14];\n  out[3] += ta * b[7] + tb * a[7];\n  out[7] = ta * b[3] + tb * a[3];\n  t = a[3] * b[7] + a[7] * b[3];\n  out[2] += 0.21850969f * t;\n  out[12] -= 0.14304817f * t;\n  out[14] += 0.18467439f * t;\n\n  ta = -0.05839917f * a[13] + 0.22617901f * a[15];\n  tb = -0.05839917f * b[13] + 0.22617901f * b[15];\n  out[3] += ta * b[8] + tb * a[8];\n  out[8] += ta * b[3] + tb * a[3];\n  t = a[3] * b[8] + a[8] * b[3];\n  out[13] -= 0.05839917f * t;\n  out[15] += 0.22617901f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[4] += ta * b[4] + tb * a[4];\n  t = a[4] * b[4];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n\n  ta = 0.15607835f * a[7];\n  tb = 0.15607835f * b[7];\n  out[4] += ta * b[5] + tb * a[5];\n  out[5] += ta * b[4] + tb * a[4];\n  t = a[4] * b[5] + a[5] * b[4];\n  out[7] += 0.15607835f * t;\n\n  ta = 0.22617901f * a[3] - 0.09403160f * a[13];\n  tb = 0.22617901f * b[3] - 0.09403160f * b[13];\n  out[4] += ta * b[9] + tb * a[9];\n  out[9] += ta * b[4] + tb * a[4];\n  t = a[4] * b[9] + a[9] * b[4];\n  out[3] += 0.22617901f * t;\n  out[13] -= 0.09403160f * t;\n\n  ta = 0.18467439f * a[2] - 0.18806319f * a[12];\n  tb = 0.18467439f * b[2] - 0.18806319f * b[12];\n  out[4] += ta * b[10] + tb * a[10];\n  out[10] = ta * b[4] + tb * a[4];\n  t = a[4] * b[10] + a[10] * b[4];\n  out[2] += 0.18467439f * t;\n  out[12] -= 0.18806319f * t;\n\n  ta = -0.05839917f * a[3] + 0.14567312f * a[13] + 0.09403160f * a[15];\n  tb = -0.05839917f * b[3] + 0.14567312f * b[13] + 0.09403160f * b[15];\n  out[4] += ta * b[11] + tb * a[11];\n  out[11] += ta * b[4] + tb * a[4];\n  t = a[4] * b[11] + a[11] * b[4];\n  out[3] -= 0.05839917f * t;\n  out[13] += 0.14567312f * t;\n  out[15] += 0.09403160f * t;\n\n  ta = 0.28209479f * a[0] + 0.09011186f * a[6] - 0.15607835f * a[8];\n  tb = 0.28209479f * b[0] + 0.09011186f * b[6] - 0.15607835f * b[8];\n  out[5] += ta * b[5] + tb * a[5];\n  t = a[5] * b[5];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.09011186f * t;\n  out[8] -= 0.15607835f * t;\n\n  ta = 0.14867701f * a[14];\n  tb = 0.14867701f * b[14];\n  out[5] += ta * b[9] + tb * a[9];\n  out[9] += ta * b[5] + tb * a[5];\n  t = a[5] * b[9] + a[9] * b[5];\n  out[14] += 0.14867701f * t;\n\n  ta = 0.18467439f * a[3] + 0.11516472f * a[13] - 0.14867701f * a[15];\n  tb = 0.18467439f * b[3] + 0.11516472f * b[13] - 0.14867701f * b[15];\n  out[5] += ta * b[10] + tb * a[10];\n  out[10] += ta * b[5] + tb * a[5];\n  t = a[5] * b[10] + a[10] * b[5];\n  out[3] += 0.18467439f * t;\n  out[13] += 0.11516472f * t;\n  out[15] -= 0.14867701f * t;\n\n  ta = 0.23359668f * a[2] + 0.05947080f * a[12] - 0.11516472f * a[14];\n  tb = 0.23359668f * b[2] + 0.05947080f * b[12] - 0.11516472f * b[14];\n  out[5] += ta * b[11] + tb * a[11];\n  out[11] += ta * b[5] + tb * a[5];\n  t = a[5] * b[11] + a[11] * b[5];\n  out[2] += 0.23359668f * t;\n  out[12] += 0.05947080f * t;\n  out[14] -= 0.11516472f * t;\n\n  ta = 0.28209479f * a[0];\n  tb = 0.28209479f * b[0];\n  out[6] += ta * b[6] + tb * a[6];\n  t = a[6] * b[6];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.18022376f * t;\n\n  ta = 0.09011186f * a[6] + 0.28209479f * a[0] + 0.15607835f * a[8];\n  tb = 0.09011186f * b[6] + 0.28209479f * b[0] + 0.15607835f * b[8];\n  out[7] += ta * b[7] + tb * a[7];\n  t = a[7] * b[7];\n  out[6] += 0.09011186f * t;\n  out[0] += 0.28209479f * t;\n  out[8] += 0.15607835f * t;\n\n  ta = 0.14867701f * a[9] + 0.18467439f * a[1] + 0.11516472f * a[11];\n  tb = 0.14867701f * b[9] + 0.18467439f * b[1] + 0.11516472f * b[11];\n  out[7] += ta * b[10] + tb * a[10];\n  out[10] += ta * b[7] + tb * a[7];\n  t = a[7] * b[10] + a[10] * b[7];\n  out[9] += 0.14867701f * t;\n  out[1] += 0.18467439f * t;\n  out[11] += 0.11516472f * t;\n\n  ta = 0.05947080f * a[12] + 0.23359668f * a[2] + 0.11516472f * a[14];\n  tb = 0.05947080f * b[12] + 0.23359668f * b[2] + 0.11516472f * b[14];\n  out[7] += ta * b[13] + tb * a[13];\n  out[13] += ta * b[7] + tb * a[7];\n  t = a[7] * b[13] + a[13] * b[7];\n  out[12] += 0.05947080f * t;\n  out[2] += 0.23359668f * t;\n  out[14] += 0.11516472f * t;\n\n  ta = 0.14867701f * a[15];\n  tb = 0.14867701f * b[15];\n  out[7] += ta * b[14] + tb * a[14];\n  out[14] += ta * b[7] + tb * a[7];\n  t = a[7] * b[14] + a[14] * b[7];\n  out[15] += 0.14867701f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[8] += ta * b[8] + tb * a[8];\n  t = a[8] * b[8];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n\n  ta = -0.09403160f * a[11];\n  tb = -0.09403160f * b[11];\n  out[8] += ta * b[9] + tb * a[9];\n  out[9] += ta * b[8] + tb * a[8];\n  t = a[8] * b[9] + a[9] * b[8];\n  out[11] -= 0.09403160f * t;\n\n  ta = -0.09403160f * a[15];\n  tb = -0.09403160f * b[15];\n  out[8] += ta * b[13] + tb * a[13];\n  out[13] += ta * b[8] + tb * a[8];\n  t = a[8] * b[13] + a[13] * b[8];\n  out[15] -= 0.09403160f * t;\n\n  ta = 0.18467439f * a[2] - 0.18806319f * a[12];\n  tb = 0.18467439f * b[2] - 0.18806319f * b[12];\n  out[8] += ta * b[14] + tb * a[14];\n  out[14] += ta * b[8] + tb * a[8];\n  t = a[8] * b[14] + a[14] * b[8];\n  out[2] += 0.18467439f * t;\n  out[12] -= 0.18806319f * t;\n\n  ta = -0.21026104f * a[6] + 0.28209479f * a[0];\n  tb = -0.21026104f * b[6] + 0.28209479f * b[0];\n  out[9] += ta * b[9] + tb * a[9];\n  t = a[9] * b[9];\n  out[6] -= 0.21026104f * t;\n  out[0] += 0.28209479f * t;\n\n  ta = 0.28209479f * a[0];\n  tb = 0.28209479f * b[0];\n  out[10] += ta * b[10] + tb * a[10];\n  t = a[10] * b[10];\n  out[0] += 0.28209479f * t;\n\n  ta = 0.28209479f * a[0] + 0.12615663f * a[6] - 0.14567312f * a[8];\n  tb = 0.28209479f * b[0] + 0.12615663f * b[6] - 0.14567312f * b[8];\n  out[11] += ta * b[11] + tb * a[11];\n  t = a[11] * b[11];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.12615663f * t;\n  out[8] -= 0.14567312f * t;\n\n  ta = 0.28209479f * a[0] + 0.16820885f * a[6];\n  tb = 0.28209479f * b[0] + 0.16820885f * b[6];\n  out[12] += ta * b[12] + tb * a[12];\n  t = a[12] * b[12];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.16820885f * t;\n\n  ta = 0.28209479f * a[0] + 0.14567312f * a[8] + 0.12615663f * a[6];\n  tb = 0.28209479f * b[0] + 0.14567312f * b[8] + 0.12615663f * b[6];\n  out[13] += ta * b[13] + tb * a[13];\n  t = a[13] * b[13];\n  out[0] += 0.28209479f * t;\n  out[8] += 0.14567312f * t;\n  out[6] += 0.12615663f * t;\n\n  ta = 0.28209479f * a[0];\n  tb = 0.28209479f * b[0];\n  out[14] += ta * b[14] + tb * a[14];\n  t = a[14] * b[14];\n  out[0] += 0.28209479f * t;\n\n  ta = 0.28209479f * a[0] - 0.21026104f * a[6];\n  tb = 0.28209479f * b[0] - 0.21026104f * b[6];\n  out[15] += ta * b[15] + tb * a[15];\n  t = a[15] * b[15];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.21026104f * t;\n}\n//+------------------------------------------------------------------+\n//| rotate_X                                                         |\n//+------------------------------------------------------------------+\nvoid rotate_X(float &out[], unsigned int order, float a, float &in[]) {\n  out[0] = in[0];\n  out[1] = a * in[2];\n  out[2] = -a * in[1];\n  out[3] = in[3];\n  out[4] = a * in[7];\n  out[5] = -in[5];\n  out[6] = -0.5f * in[6] - 0.8660253882f * in[8];\n  out[7] = -a * in[4];\n  out[8] = -0.8660253882f * in[6] + 0.5f * in[8];\n  out[9] = -a * 0.7905694842f * in[12] + a * 0.6123724580f * in[14];\n  out[10] = -in[10];\n  out[11] = -a * 0.6123724580f * in[12] - a * 0.7905694842f * in[14];\n  out[12] = a * 0.7905694842f * in[9] + a * 0.6123724580f * in[11];\n  out[13] = -0.25f * in[13] - 0.9682458639f * in[15];\n  out[14] = -a * 0.6123724580f * in[9] + a * 0.7905694842f * in[11];\n  out[15] = -0.9682458639f * in[13] + 0.25f * in[15];\n  if (order == 4) return;\n\n  out[16] = -a * 0.9354143739f * in[21] + a * 0.3535533845f * in[23];\n  out[17] = -0.75f * in[17] + 0.6614378095f * in[19];\n  out[18] = -a * 0.3535533845f * in[21] - a * 0.9354143739f * in[23];\n  out[19] = 0.6614378095f * in[17] + 0.75f * in[19];\n  out[20] = 0.375f * in[20] + 0.5590170026f * in[22] + 0.7395099998f * in[24];\n  out[21] = a * 0.9354143739f * in[16] + a * 0.3535533845f * in[18];\n  out[22] = 0.5590170026f * in[20] + 0.5f * in[22] - 0.6614378691f * in[24];\n  out[23] = -a * 0.3535533845f * in[16] + a * 0.9354143739f * in[18];\n  out[24] = 0.7395099998f * in[20] - 0.6614378691f * in[22] + 0.125f * in[24];\n  if (order == 5) return;\n\n  out[25] = a * 0.7015607357f * in[30] - a * 0.6846531630f * in[32] + a * 0.1976423711f * in[34];\n  out[26] = -0.5f * in[26] + 0.8660253882f * in[28];\n  out[27] = a * 0.5229125023f * in[30] + a * 0.3061861992f * in[32] - a * 0.7954951525f * in[34];\n  out[28] = 0.8660253882f * in[26] + 0.5f * in[28];\n  out[29] = a * 0.4841229022f * in[30] + a * 0.6614378691f * in[32] + a * 0.5728219748f * in[34];\n  out[30] = -a * 0.7015607357f * in[25] - a * 0.5229125023f * in[27] - a * 0.4841229022f * in[29];\n  out[31] = 0.125f * in[31] + 0.4050463140f * in[33] + 0.9057110548f * in[35];\n  out[32] = a * 0.6846531630f * in[25] - a * 0.3061861992f * in[27] - a * 0.6614378691f * in[29];\n  out[33] = 0.4050463140f * in[31] + 0.8125f * in[33] - 0.4192627370f * in[35];\n  out[34] = -a * 0.1976423711f * in[25] + a * 0.7954951525f * in[27] - a * 0.5728219748f * in[29];\n  out[35] = 0.9057110548f * in[31] - 0.4192627370f * in[33] + 0.0624999329f * in[35];\n}\n//+------------------------------------------------------------------+\n//| Rotates the spherical harmonic (SH) vector by the given _matrix.  |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m)                    |\n//| is stored at memory location l^2 + m + l, where:                 |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHRotate(float &out[], int order, const DXMatrix &_matrix, const float &in[]) {\n  float alpha, beta, gamma, sinb, temp[36], temp1[36];\n  out[0] = in[0];\n\n  if ((order > DXSH_MAXORDER) || (order < DXSH_MINORDER)) return;\n\n  if (order <= 3) {\n    out[1] = _matrix.m[1][1] * in[1] - _matrix.m[2][1] * in[2] + _matrix.m[0][1] * in[3];\n    out[2] = -_matrix.m[1][2] * in[1] + _matrix.m[2][2] * in[2] - _matrix.m[0][2] * in[3];\n    out[3] = _matrix.m[1][0] * in[1] - _matrix.m[2][0] * in[2] + _matrix.m[0][0] * in[3];\n\n    if (order == 3) {\n      float coeff[12] = {};\n      coeff[0] = _matrix.m[1][0] * _matrix.m[0][0];\n      coeff[1] = _matrix.m[1][1] * _matrix.m[0][1];\n      coeff[2] = _matrix.m[1][1] * _matrix.m[2][1];\n      coeff[3] = _matrix.m[1][0] * _matrix.m[2][0];\n      coeff[4] = _matrix.m[2][0] * _matrix.m[2][0];\n      coeff[5] = _matrix.m[2][1] * _matrix.m[2][1];\n      coeff[6] = _matrix.m[0][0] * _matrix.m[2][0];\n      coeff[7] = _matrix.m[0][1] * _matrix.m[2][1];\n      coeff[8] = _matrix.m[0][1] * _matrix.m[0][1];\n      coeff[9] = _matrix.m[1][0] * _matrix.m[1][0];\n      coeff[10] = _matrix.m[1][1] * _matrix.m[1][1];\n      coeff[11] = _matrix.m[0][0] * _matrix.m[0][0];\n\n      out[4] = (_matrix.m[1][1] * _matrix.m[0][0] + _matrix.m[0][1] * _matrix.m[1][0]) * in[4];\n      out[4] -= (_matrix.m[1][0] * _matrix.m[2][1] + _matrix.m[1][1] * _matrix.m[2][0]) * in[5];\n      out[4] += 1.7320508076f * _matrix.m[2][0] * _matrix.m[2][1] * in[6];\n      out[4] -= (_matrix.m[0][1] * _matrix.m[2][0] + _matrix.m[0][0] * _matrix.m[2][1]) * in[7];\n      out[4] += (_matrix.m[0][0] * _matrix.m[0][1] - _matrix.m[1][0] * _matrix.m[1][1]) * in[8];\n\n      out[5] = (_matrix.m[1][1] * _matrix.m[2][2] + _matrix.m[1][2] * _matrix.m[2][1]) * in[5];\n      out[5] -= (_matrix.m[1][1] * _matrix.m[0][2] + _matrix.m[1][2] * _matrix.m[0][1]) * in[4];\n      out[5] -= 1.7320508076f * _matrix.m[2][2] * _matrix.m[2][1] * in[6];\n      out[5] += (_matrix.m[0][2] * _matrix.m[2][1] + _matrix.m[0][1] * _matrix.m[2][2]) * in[7];\n      out[5] -= (_matrix.m[0][1] * _matrix.m[0][2] - _matrix.m[1][1] * _matrix.m[1][2]) * in[8];\n\n      out[6] = (_matrix.m[2][2] * _matrix.m[2][2] - 0.5f * (coeff[4] + coeff[5])) * in[6];\n      out[6] -= (0.5773502692f * (coeff[0] + coeff[1]) - 1.1547005384f * _matrix.m[1][2] * _matrix.m[0][2]) * in[4];\n      out[6] += (0.5773502692f * (coeff[2] + coeff[3]) - 1.1547005384f * _matrix.m[1][2] * _matrix.m[2][2]) * in[5];\n      out[6] += (0.5773502692f * (coeff[6] + coeff[7]) - 1.1547005384f * _matrix.m[0][2] * _matrix.m[2][2]) * in[7];\n      out[6] += (0.2886751347f * (coeff[9] - coeff[8] + coeff[10] - coeff[11]) -\n                 0.5773502692f * (_matrix.m[1][2] * _matrix.m[1][2] - _matrix.m[0][2] * _matrix.m[0][2])) *\n                in[8];\n\n      out[7] = (_matrix.m[0][0] * _matrix.m[2][2] + _matrix.m[0][2] * _matrix.m[2][0]) * in[7];\n      out[7] -= (_matrix.m[1][0] * _matrix.m[0][2] + _matrix.m[1][2] * _matrix.m[0][0]) * in[4];\n      out[7] += (_matrix.m[1][0] * _matrix.m[2][2] + _matrix.m[1][2] * _matrix.m[2][0]) * in[5];\n      out[7] -= 1.7320508076f * _matrix.m[2][2] * _matrix.m[2][0] * in[6];\n      out[7] -= (_matrix.m[0][0] * _matrix.m[0][2] - _matrix.m[1][0] * _matrix.m[1][2]) * in[8];\n\n      out[8] = 0.5f * (coeff[11] - coeff[8] - coeff[9] + coeff[10]) * in[8];\n      out[8] += (coeff[0] - coeff[1]) * in[4];\n      out[8] += (coeff[2] - coeff[3]) * in[5];\n      out[8] += 0.86602540f * (coeff[4] - coeff[5]) * in[6];\n      out[8] += (coeff[7] - coeff[6]) * in[7];\n    }\n    return;\n  }\n\n#ifdef __MQL5__\n  if ((float)fabs(_matrix.m[2][2]) != 1.0f) {\n    sinb = (float)sqrt(1.0f - _matrix.m[2][2] * _matrix.m[2][2]);\n    alpha = (float)atan2(_matrix.m[2][1] / sinb, _matrix.m[2][0] / sinb);\n    beta = (float)atan2(sinb, _matrix.m[2][2]);\n    gamma = (float)atan2(_matrix.m[1][2] / sinb, -_matrix.m[0][2] / sinb);\n  } else {\n    alpha = (float)atan2(_matrix.m[0][1], _matrix.m[0][0]);\n    beta = 0.0f;\n    gamma = 0.0f;\n  }\n#else\n  alpha = 0.0f;\n  beta = 0.0f;\n  gamma = 0.0f;\n  sinb = 0.0f;\n#endif\n\n  //---\n  DXSHRotateZ(temp, order, gamma, in);\n  rotate_X(temp1, order, 1.0f, temp);\n  DXSHRotateZ(temp, order, beta, temp1);\n  rotate_X(temp1, order, -1.0f, temp);\n  DXSHRotateZ(out, order, alpha, temp1);\n}\n//+------------------------------------------------------------------+\n//| Rotates the spherical harmonic (SH) vector                       |\n//| in the z-axis by the given angle.                                |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m)                    |\n//| is stored at memory location l^2 + m + l, where:                 |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHRotateZ(float &out[], int order, float angle, const float &in[]) {\n  int sum = 0;\n  float c[5], s[5];\n  order = (int)fmin(fmax(order, DXSH_MINORDER), DXSH_MAXORDER);\n  out[0] = in[0];\n  //---\n  for (int i = 1; i < order; i++) {\n    c[i - 1] = (float)cos(i * angle);\n    s[i - 1] = (float)sin(i * angle);\n    sum += i * 2;\n    //---\n    out[sum - i] = c[i - 1] * in[sum - i];\n    out[sum - i] += s[i - 1] * in[sum + i];\n    for (int j = i - 1; j > 0; j--) {\n      out[sum - j] = 0.0f;\n      out[sum - j] = c[j - 1] * in[sum - j];\n      out[sum - j] += s[j - 1] * in[sum + j];\n    }\n    out[sum] = in[sum];\n    //---\n    for (int j = 1; j < i; j++) {\n      out[sum + j] = 0.0f;\n      out[sum + j] = -s[j - 1] * in[sum - j];\n      out[sum + j] += c[j - 1] * in[sum + j];\n    }\n    out[sum + i] = -s[i - 1] * in[sum - i];\n    out[sum + i] += c[i - 1] * in[sum + i];\n  }\n}\n//+------------------------------------------------------------------+\n//| Scales a spherical harmonic (SH) vector;                         |\n//| in other words, out[i] = a[i]*scale.                             |\n//+------------------------------------------------------------------+\nvoid DXSHScale(float &out[], int order, const float &a[], const float scale) {\n  for (int i = 0; i < order * order; i++) out[i] = a[i] * scale;\n}\n//+---------------------------------------------------------------------+\n//| Interpolates y0 to y1 according to value from 0.0 to 1.0            |\n//+---------------------------------------------------------------------+\nfloat DXScalarLerp(const float val1, const float val2, float s) { return ((1 - s) * val1 + s * val2); }\n//+---------------------------------------------------------------------+\n//| Interpolates y0 to y1 according to value from 0.0 to 1.0            |\n//+---------------------------------------------------------------------+\nfloat DXScalarBiasScale(const float val, const float bias, const float scale) { return ((val + bias) * scale); }\n//+------------------------------------------------------------------+\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                       DXMath.mqh |\n//|                        Copyright 2019,MetaQuotes Software Corp. |\n//|                                             https://www.mql5.com |\n//+------------------------------------------------------------------+\n#property copyright \"Copyright 2019,MetaQuotes Software Corp.\"\n#property link \"https://www.mql5.com\"\n//+------------------------------------------------------------------+\n//| DirectX Math Routines                                            |\n//+------------------------------------------------------------------+\n//| Ported from C++ code of ReactOS, written by David Adam           |\n//| and Tony Wasserka                                                |\n//|                                                                  |\n//| https://doxygen.reactos.org/de/d57/                              |\n//| dll_2directx_2wine_2d3dx9__36_2math_8c_source.html               |\n//|                                                                  |\n//| Copyright (C) 2007 David Adam                                    |\n//| Copyright (C) 2007 Tony Wasserka                                 |\n//+------------------------------------------------------------------+\n#define DX_PI 3.1415926535897932384626f\n#define DX_PI_DIV2 1.5707963267948966192313f\n#define DX_PI_DIV3 1.0471975511965977461542f\n#define DX_PI_DIV4 0.7853981633974483096156f\n#define DX_PI_DIV6 0.5235987755982988730771f\n#define DX_PI_MUL2 6.2831853071795864769253f\n#define DXSH_MINORDER 2\n#define DXSH_MAXORDER 6\n//+------------------------------------------------------------------+\n//| Preliminary declarations                                         |\n//+------------------------------------------------------------------+\n//+------------------------------------------------------------------+\n//| DXColor                                                          |\n//+------------------------------------------------------------------+\nstruct DXColor;\nstruct DXPlane;\nstruct DXVector2;\nstruct DXVector3;\nstruct DXVector4;\nstruct DXMatrix;\nstruct DXQuaternion;\nstruct DViewport;\n//+------------------------------------------------------------------+\n//| DXColor                                                          |\n//+------------------------------------------------------------------+\nstruct DXColor {\n  float r;\n  float g;\n  float b;\n  float a;\n  //--- constructors\n  DXColor(void) {\n    r = 0.0;\n    g = 0.0;\n    b = 0.0;\n    a = 1.0;\n  }\n  DXColor(float red, float green, float blue, float alpha) {\n    r = red;\n    g = green;\n    b = blue;\n    a = alpha;\n  }\n  DXColor(const DXVector4 &v) {\n    r = v.x;\n    g = v.y;\n    b = v.z;\n    a = v.w;\n  }\n  DXColor(const DXVector3 &v) {\n    r = v.x;\n    g = v.y;\n    b = v.z;\n    a = 1.0;\n  }\n  DXColor(unsigned int _color) {\n    a = 1.0f / 255.0f * ((_color & 0xFF000000) >> 24);\n    r = 1.0f / 255.0f * ((_color & 0x00FF0000) >> 16);\n    g = 1.0f / 255.0f * ((_color & 0x0000FF00) >> 8);\n    b = 1.0f / 255.0f * ((_color & 0x000000FF) >> 0);\n  }\n};\n//+------------------------------------------------------------------+\n//| DXPlane                                                          |\n//+------------------------------------------------------------------+\nstruct DXPlane {\n  float a;\n  float b;\n  float c;\n  float d;\n};\n//+------------------------------------------------------------------+\n//| DXVector2                                                        |\n//+------------------------------------------------------------------+\nstruct DXVector2 {\n  float x;\n  float y;\n  //--- constructors\n  DXVector2(void) {\n    x = 0.0;\n    y = 0.0;\n  }\n  DXVector2(float v) {\n    x = v;\n    y = v;\n  }\n  DXVector2(float vx, float vy) {\n    x = vx;\n    y = vy;\n  }\n  DXVector2(const DXVector3 &v) {\n    x = v.x;\n    y = v.y;\n  }\n  DXVector2(const DXVector4 &v) {\n    x = v.x;\n    y = v.y;\n  }\n};\n//+------------------------------------------------------------------+\n//| DXVector3                                                        |\n//+------------------------------------------------------------------+\nstruct DXVector3 {\n  float x;\n  float y;\n  float z;\n  //--- constructors\n  DXVector3(void) {\n    x = 0.0;\n    y = 0.0;\n    z = 0.0;\n  }\n  DXVector3(float v) {\n    x = v;\n    y = v;\n    z = v;\n  }\n  DXVector3(float vx, float vy, float vz) {\n    x = vx;\n    y = vy;\n    z = vz;\n  }\n  DXVector3(const DXVector2 &v) {\n    x = v.x;\n    y = v.y;\n    z = 0.0;\n  }\n  DXVector3(const DXVector4 &v) {\n    x = v.x;\n    y = v.y;\n    z = v.z;\n  }\n};\n//+------------------------------------------------------------------+\n//| DXVector4                                                        |\n//+------------------------------------------------------------------+\nstruct DXVector4 {\n  float x;\n  float y;\n  float z;\n  float w;\n  //--- constructors\n  DXVector4(void) {\n    x = 0.0;\n    y = 0.0;\n    z = 0.0;\n    w = 1.0;\n  }\n  DXVector4(float v) {\n    x = v;\n    y = v;\n    z = v;\n    w = v;\n  }\n  DXVector4(float vx, float vy, float vz, float vw) {\n    x = vx;\n    y = vy;\n    z = vz;\n    w = vw;\n  }\n  DXVector4(const DXVector2 &v) {\n    x = v.x;\n    y = v.y;\n    z = 0.0;\n    w = 1.0;\n  }\n  DXVector4(const DXVector3 &v) {\n    x = v.x;\n    y = v.y;\n    z = v.z;\n    w = 1.0;\n  }\n};\n//+------------------------------------------------------------------+\n//| DXMatrix                                                         |\n//+------------------------------------------------------------------+\nstruct DXMatrix {\n  float m[4][4];\n};\n//+------------------------------------------------------------------+\n//| DXQuaternion                                                     |\n//+------------------------------------------------------------------+\nstruct DXQuaternion {\n  float x;\n  float y;\n  float z;\n  float w;\n};\n//+------------------------------------------------------------------+\n//| DViewport                                                        |\n//+------------------------------------------------------------------+\nstruct DViewport {\n  unsigned long x;\n  unsigned long y;\n  unsigned long width;\n  unsigned long height;\n  float minz;\n  float maxz;\n};\n\n/*\n//--- DXColor functions\nvoid  DXColorAdd(DXColor &pout,const DXColor &pc1,const DXColor &pc2);\nvoid  DXColorAdjustContrast(DXColor &pout,const DXColor &pc,float s);\nvoid  DXColorAdjustSaturation(DXColor &pout,const DXColor &pc,float s);\nvoid  DXColorLerp(DXColor &pout,const DXColor &pc1,const DXColor &pc2,float s);\nvoid  DXColorModulate(DXColor &pout,const DXColor &pc1,const DXColor &pc2);\nvoid  DXColorNegative(DXColor &pout,const DXColor &pc);\nvoid  DXColorScale(DXColor &pout,const DXColor &pc,float s);\nvoid  DXColorSubtract(DXColor &pout,const DXColor &pc1,const DXColor &pc2);\nfloat DXFresnelTerm(float costheta,float refractionindex);\n\n//--- DXVector2 functions\nvoid  DXVec2Add(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2BaryCentric(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2,const DXVector2 &pv3,float f,float g);\nvoid  DXVec2CatmullRom(DXVector2 &pout,const DXVector2 &pv0,const DXVector2 &pv1,const DXVector2 &pv2,const DXVector2\n&pv3,float s); float DXVec2CCW(const DXVector2 &pv1,const DXVector2 &pv2); float DXVec2Dot(const DXVector2 &pv1,const\nDXVector2 &pv2); void  DXVec2Hermite(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pt1,const DXVector2\n&pv2,const DXVector2 &pt2,float s); float DXVec2Length(const DXVector2 &v); float DXVec2LengthSq(const DXVector2 &v);\nvoid  DXVec2Lerp(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2,float s);\nvoid  DXVec2Maximize(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2Minimize(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2Normalize(DXVector2 &pout,const DXVector2 &pv);\nvoid  DXVec2Scale(DXVector2 &pout,const DXVector2 &pv,float s);\nvoid  DXVec2Subtract(DXVector2 &pout,const DXVector2 &pv1,const DXVector2 &pv2);\nvoid  DXVec2Transform(DXVector4 &pout,const DXVector2 &pv,const DXMatrix &pm);\nvoid  DXVec2TransformCoord(DXVector2 &pout,const DXVector2 &pv,const DXMatrix &pm);\nvoid  DXVec2TransformNormal(DXVector2 &pout,const DXVector2 &pv,const DXMatrix &pm);\n\n//--- DXVector3 functions\nvoid  DXVec3Add(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2);\nvoid  DXVec3BaryCentric(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2,const DXVector3 &pv3,float f,float g);\nvoid  DXVec3CatmullRom(DXVector3 &pout,const DXVector3 &pv0,const DXVector3 &pv1,const DXVector3 &pv2,const DXVector3\n&pv3,float s); void  DXVec3Cross(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2); float DXVec3Dot(const\nDXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Hermite(DXVector3 &pout,const DXVector3 &pv1,const DXVector3\n&pt1,const DXVector3 &pv2,const DXVector3 &pt2,float s); float DXVec3Length(const DXVector3 &pv); float\nDXVec3LengthSq(const DXVector3 &pv); void  DXVec3Lerp(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2,float\ns); void  DXVec3Maximize(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Minimize(DXVector3\n&pout,const DXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Normalize(DXVector3 &pout,const DXVector3 &pv); void\nDXVec3Project(DXVector3 &pout,const DXVector3 &pv,const DViewport &pviewport,const DXMatrix &pprojection,const DXMatrix\n&pview,const DXMatrix &pworld); void  DXVec3Scale(DXVector3 &pout,const DXVector3 &pv,float s); void\nDXVec3Subtract(DXVector3 &pout,const DXVector3 &pv1,const DXVector3 &pv2); void  DXVec3Transform(DXVector4 &pout,const\nDXVector3 &pv,const DXMatrix &pm); void  DXVec3TransformCoord(DXVector3 &pout,const DXVector3 &pv,const DXMatrix &pm);\nvoid  DXVec3TransformNormal(DXVector3 &pout,const DXVector3 &pv,const DXMatrix &pm);\nvoid  DXVec3Unproject(DXVector3 &out,const DXVector3 &v,const DViewport &viewport,const DXMatrix &projection,const\nDXMatrix &view,const DXMatrix &world);\n\n//--- DXVector4 vector functions\nvoid  DXVec4Add(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2);\nvoid  DXVec4BaryCentric(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2,const DXVector4 &pv3,float f,float g);\nvoid  DXVec4CatmullRom(DXVector4 &pout,const DXVector4 &pv0,const DXVector4 &pv1,const DXVector4 &pv2,const DXVector4\n&pv3,float s); void  DXVec4Cross(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2,const DXVector4 &pv3); float\nDXVec4Dot(const DXVector4 &pv1,const DXVector4 &pv2); void  DXVec4Hermite(DXVector4 &pout,const DXVector4 &pv1,const\nDXVector4 &pt1,const DXVector4 &pv2,const DXVector4 &pt2,float s); float DXVec4Length(const DXVector4 &pv); float\nDXVec4LengthSq(const DXVector4 &pv); void  DXVec4Lerp(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2,float\ns); void  DXVec4Maximize(DXVector4 &pout,const DXVector4 &pv1,const DXVector4 &pv2); void  DXVec4Minimize(DXVector4\n&pout,const DXVector4 &pv1,const DXVector4 &pv2); void  DXVec4Normalize(DXVector4 &pout,const DXVector4 &pv); void\nDXVec4Scale(DXVector4 &pout,const DXVector4 &pv,float s); void  DXVec4Subtract(DXVector4 &pout,const DXVector4\n&pv1,const DXVector4 &pv2); void  DXVec4Transform(DXVector4 &pout,const DXVector4 &pv,const DXMatrix &pm);\n\n//---DXQuaternion functions\nvoid  DXQuaternionBaryCentric(DXQuaternion &pout,DXQuaternion &pq1,DXQuaternion &pq2,DXQuaternion &pq3,float f,float g);\nvoid  DXQuaternionConjugate(DXQuaternion &pout,const DXQuaternion &pq);\nfloat DXQuaternionDot(DXQuaternion &a,DXQuaternion &b);\nvoid  DXQuaternionExp(DXQuaternion &out,const DXQuaternion &q);\nvoid  DXQuaternionIdentity(DXQuaternion &out);\nbool  DXQuaternionIsIdentity(DXQuaternion &pq);\nfloat DXQuaternionLength(const DXQuaternion &pq);\nfloat DXQuaternionLengthSq(const DXQuaternion &pq);\nvoid  DXQuaternionInverse(DXQuaternion &pout,const DXQuaternion &pq);\nvoid  DXQuaternionLn(DXQuaternion &out,const DXQuaternion &q);\nvoid  DXQuaternionMultiply(DXQuaternion &pout,const DXQuaternion &pq1,const DXQuaternion &pq2);\nvoid  DXQuaternionNormalize(DXQuaternion &out,const DXQuaternion &q);\nvoid  DXQuaternionRotationAxis(DXQuaternion &out,const DXVector3 &v,float angle);\nvoid  DXQuaternionRotationMatrix(DXQuaternion &out,const DXMatrix &m);\nvoid  DXQuaternionRotationYawPitchRoll(DXQuaternion &out,float yaw,float pitch,float roll);\nvoid  DXQuaternionSlerp(DXQuaternion &out,DXQuaternion &q1,DXQuaternion &q2,float t);\nvoid  DXQuaternionSquad(DXQuaternion &pout,DXQuaternion &pq1,DXQuaternion &pq2,DXQuaternion &pq3,DXQuaternion &pq4,float\nt); void  DXQuaternionSquadSetup(DXQuaternion &paout,DXQuaternion &pbout,DXQuaternion &pcout,DXQuaternion\n&pq0,DXQuaternion &pq1,DXQuaternion &pq2,DXQuaternion &pq3); void  DXQuaternionToAxisAngle(const DXQuaternion\n&pq,DXVector3 &paxis,float &pangle); DXQuaternion add_diff(const DXQuaternion &q1,const DXQuaternion &q2,const float\nadd);\n\n//--- DXMatrix functions\nvoid  DXMatrixIdentity(DXMatrix &out);\nbool  DXMatrixIsIdentity(DXMatrix &pm);\nvoid  DXMatrixAffineTransformation(DXMatrix &out,float scaling,const DXVector3 &rotationcenter,const DXQuaternion\n&rotation,const DXVector3 &translation); void  DXMatrixAffineTransformation2D(DXMatrix &out,float scaling,const\nDXVector2 &rotationcenter,float rotation,const DXVector2 &translation); int   DXMatrixDecompose(DXVector3\n&poutscale,DXQuaternion &poutrotation,DXVector3 &pouttranslation,const DXMatrix &pm); float DXMatrixDeterminant(const\nDXMatrix &pm); void  DXMatrixInverse(DXMatrix &pout,float &pdeterminant,const DXMatrix &pm); void\nDXMatrixLookAtLH(DXMatrix &out,const DXVector3 &eye,const DXVector3 &at,const DXVector3 &up); void\nDXMatrixLookAtRH(DXMatrix &out,const DXVector3 &eye,const DXVector3 &at,const DXVector3 &up); void\nDXMatrixMultiply(DXMatrix &pout,const DXMatrix &pm1,const DXMatrix &pm2); void  DXMatrixMultiplyTranspose(DXMatrix\n&pout,const DXMatrix &pm1,const DXMatrix &pm2); void  DXMatrixOrthoLH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixOrthoOffCenterLH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixOrthoOffCenterRH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixOrthoRH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixPerspectiveFovLH(DXMatrix &pout,float fovy,float aspect,float zn,float zf);\nvoid  DXMatrixPerspectiveFovRH(DXMatrix &pout,float fovy,float aspect,float zn,float zf);\nvoid  DXMatrixPerspectiveLH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixPerspectiveOffCenterLH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixPerspectiveOffCenterRH(DXMatrix &pout,float l,float r,float b,float t,float zn,float zf);\nvoid  DXMatrixPerspectiveRH(DXMatrix &pout,float w,float h,float zn,float zf);\nvoid  DXMatrixReflect(DXMatrix &pout,const DXPlane &pplane);\nvoid  DXMatrixRotationAxis(DXMatrix &out,const DXVector3 &v,float angle);\nvoid  DXMatrixRotationQuaternion(DXMatrix &pout,const DXQuaternion &pq);\nvoid  DXMatrixRotationX(DXMatrix &pout,float angle);\nvoid  DXMatrixRotationY(DXMatrix &pout,float angle);\nvoid  DXMatrixRotationYawPitchRoll(DXMatrix &out,float yaw,float pitch,float roll);\nvoid  DXMatrixRotationZ(DXMatrix &pout,float angle);\nvoid  DXMatrixScaling(DXMatrix &pout,float sx,float sy,float sz);\nvoid  DXMatrixShadow(DXMatrix &pout,const DXVector4 &plight,const DXPlane &pplane);\nvoid  DXMatrixTransformation(DXMatrix &pout,const DXVector3 &pscalingcenter,const DXQuaternion &pscalingrotation,const\nDXVector3 &pscaling,const DXVector3 &protationcenter,const DXQuaternion &protation,const DXVector3 &ptranslation); void\nDXMatrixTransformation2D(DXMatrix &pout,const DXVector2 &pscalingcenter,float scalingrotation,const DXVector2\n&pscaling,const DXVector2 &protationcenter,float rotation,const DXVector2 &ptranslation); void\nDXMatrixTranslation(DXMatrix &pout,float x,float y,float z); void  DXMatrixTranspose(DXMatrix &pout,const DXMatrix &pm);\n\n//--- DXPlane functions                                              |\nfloat DXPlaneDot(const DXPlane &p1,const DXVector4 &p2);\nfloat DXPlaneDotCoord(const DXPlane &pp,const DXVector4 &pv);\nfloat DXPlaneDotNormal(const DXPlane &pp,const DXVector4 &pv);\nvoid  DXPlaneFromPointNormal(DXPlane &pout,const DXVector3 &pvpoint,const DXVector3 &pvnormal);\nvoid  DXPlaneFromPoints(DXPlane &pout,const DXVector3 &pv1,const DXVector3 &pv2,const DXVector3 &pv3);\nvoid  DXPlaneIntersectLine(DXVector3 &pout,const DXPlane &pp,const DXVector3 &pv1,const DXVector3 &pv2);\nvoid  DXPlaneNormalize(DXPlane &out,const DXPlane &p);\nvoid  DXPlaneScale(DXPlane &pout,const DXPlane &p,float s);\nvoid  DXPlaneTransform(DXPlane &pout,const DXPlane &pplane,const DXMatrix &pm);\n\n//---- spherical harmonic functions\nvoid  DXSHAdd(float &out[],int order,const float &a[],const float &b[]);\nfloat DXSHDot(int order,const float &a[],const float &b[]);\nint   DXSHEvalConeLight(int order,const DXVector3 &dir,float radius,float Rintensity,float Gintensity,float\nBintensity,float &rout[],float &gout[],float &bout[]); void  DXSHEvalDirection(float &out[],int order,const DXVector3\n&dir); int   DXSHEvalDirectionalLight(int order,const DXVector3 &dir,float Rintensity,float Gintensity,float\nBintensity,float &rout[],float &gout[],float &bout[]); int   DXSHEvalHemisphereLight(int order,const DXVector3\n&dir,DXColor &top,DXColor &bottom,float &rout[],float &gout[],float &bout[]); int   DXSHEvalSphericalLight(int\norder,const DXVector3 &dir,float radius,float Rintensity,float Gintensity,float Bintensity,float &rout[],float\n&gout[],float &bout[]); void  DXSHMultiply2(float &out[],const float &a[],const float &b[]); void  DXSHMultiply3(float\n&out[],const float &a[],const float &b[]); void  DXSHMultiply4(float &out[],const float &a[],const float &b[]); void\nDXSHRotate(float &out[],int order,const DXMatrix &_matrix,const float &in[]); void  DXSHRotateZ(float &out[],int\norder,float angle,const float &in[]); void  DXSHScale(float &out[],int order,const float &a[],const float scale);\n\n//--- scalar functions\nfloat DXScalarLerp(const float val1,const float val2,float s)\nfloat DXScalarBiasScale(const float val,const float bias,const float scale)\n*/\n\n//+------------------------------------------------------------------+\n//| Adds two color values together to create a new color value.      |\n//+------------------------------------------------------------------+\nvoid DXColorAdd(DXColor &pout, const DXColor &pc1, const DXColor &pc2) {\n  pout.r = pc1.r + pc2.r;\n  pout.g = pc1.g + pc2.g;\n  pout.b = pc1.b + pc2.b;\n  pout.a = pc1.a + pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Adjusts the contrast value of a color.                           |\n//+------------------------------------------------------------------+\n//| The input alpha channel is copied, unmodified,                   |\n//| to the output alpha channel.                                     |\n//|                                                                  |\n//| This function interpolates the red,green,and blue color          |\n//| components of a DXColor structure between fifty percent gray     |\n//| and a specified contrast value,as shown in the following example.|\n//|                                                                  |\n//| pout.r = 0.5f + s*(pc.r - 0.5f);                                 |\n//|                                                                  |\n//| If s is greater than 0 and less than 1,the contrast is decreased.|\n//| If s is greater than 1, the contrast is increased.               |\n//+------------------------------------------------------------------+\nvoid DXColorAdjustContrast(DXColor &pout, const DXColor &pc, float s) {\n  pout.r = 0.5f + s * (pc.r - 0.5f);\n  pout.g = 0.5f + s * (pc.g - 0.5f);\n  pout.b = 0.5f + s * (pc.b - 0.5f);\n  pout.a = pc.a;\n}\n//+------------------------------------------------------------------+\n//| Adjusts the saturation value of a color.                         |\n//+------------------------------------------------------------------+\n//| The input alpha channel is copied, unmodified,                   |\n//| to the output alpha channel.                                     |\n//|                                                                  |\n//| This function interpolates the red, green, and blue color        |\n//| components of a DXColor structure between an unsaturated color   |\n//| and a color, as shown in the following example.                  |\n//|                                                                  |\n//| Approximate values for each component's contribution to          |\n//| luminance. Based upon the NTSC standard described in             |\n//| ITU-R Recommendation BT.709.                                     |\n//| float grey = pc.r*0.2125f + pc.g*0.7154f + pc.b*0.0721f;         |\n//|                                                                  |\n//| pout.r = grey + s*(pc.r - grey);                                 |\n//| If s is greater than 0 and less than 1, the saturation is        |\n//| decreased. If s is greater than 1, the saturation is increased.  |\n//|                                                                  |\n//| The grayscale color is computed as:                              |\n//| r = g = b = 0.2125*r + 0.7154*g + 0.0721*b                       |\n//+------------------------------------------------------------------+\nvoid DXColorAdjustSaturation(DXColor &pout, const DXColor &pc, float s) {\n  float grey = pc.r * 0.2125f + pc.g * 0.7154f + pc.b * 0.0721f;\n  pout.r = grey + s * (pc.r - grey);\n  pout.g = grey + s * (pc.g - grey);\n  pout.b = grey + s * (pc.b - grey);\n  pout.a = pc.a;\n}\n//+------------------------------------------------------------------+\n//| Uses linear interpolation to create a color value.               |\n//+------------------------------------------------------------------+\n//| This function interpolates the red, green, blue, and alpha       |\n//| components of a DXColor structure between two colors, as shown   |\n//| in the following example.                                        |\n//|                                                                  |\n//| pout.r = pC1.r + s * (pC2.r - pC1.r);                            |\n//|                                                                  |\n//| If you are linearly interpolating between the colors A and B,    |\n//| and s is 0, the resulting color is A.                            |\n//| If s is 1, the resulting color is color B.                       |\n//+------------------------------------------------------------------+\nvoid DXColorLerp(DXColor &pout, const DXColor &pc1, const DXColor &pc2, float s) {\n  pout.r = (1 - s) * pc1.r + s * pc2.r;\n  pout.g = (1 - s) * pc1.g + s * pc2.g;\n  pout.b = (1 - s) * pc1.b + s * pc2.b;\n  pout.a = (1 - s) * pc1.a + s * pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Blends two colors.                                               |\n//+------------------------------------------------------------------+\n//| This function blends together two colors by multiplying matching |\n//| color components, as shown in the following example.             |\n//| pout.r = pC1.r * pC2.r;                                          |\n//+------------------------------------------------------------------+\nvoid DXColorModulate(DXColor &pout, const DXColor &pc1, const DXColor &pc2) {\n  pout.r = pc1.r * pc2.r;\n  pout.g = pc1.g * pc2.g;\n  pout.b = pc1.b * pc2.b;\n  pout.a = pc1.a * pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Creates the negative color value of a color value.               |\n//+------------------------------------------------------------------+\n//| The input alpha channel is copied, unmodified, to the output     |\n//| alpha channel.                                                   |\n//| This function returns the negative color value by subtracting 1.0|\n//| from the color components of the DXColor structure,              |\n//| as shown in the following example.                               |\n//|  pout.r = 1.0f - pc.r;                                           |\n//+------------------------------------------------------------------+\nvoid DXColorNegative(DXColor &pout, const DXColor &pc) {\n  pout.r = 1.0f - pc.r;\n  pout.g = 1.0f - pc.g;\n  pout.b = 1.0f - pc.b;\n  pout.a = pc.a;\n}\n//+------------------------------------------------------------------+\n//| Scales a color value.                                            |\n//+------------------------------------------------------------------+\n//| This function computes the scaled color value by multiplying     |\n//| the color components of the DXColor structure by the specified   |\n//| scale factor, as shown in the following example.                 |\n//| pOut.r = pC.r*s;                                                 |\n//+------------------------------------------------------------------+\nvoid DXColorScale(DXColor &pout, const DXColor &pc, float s) {\n  pout.r = s * pc.r;\n  pout.g = s * pc.g;\n  pout.b = s * pc.b;\n  pout.a = s * pc.a;\n}\n//+------------------------------------------------------------------+\n//| Subtracts two color values to create a new color value.          |\n//+------------------------------------------------------------------+\nvoid DXColorSubtract(DXColor &pout, const DXColor &pc1, const DXColor &pc2) {\n  pout.r = pc1.r - pc2.r;\n  pout.g = pc1.g - pc2.g;\n  pout.b = pc1.b - pc2.b;\n  pout.a = pc1.a - pc2.a;\n}\n//+------------------------------------------------------------------+\n//| Calculate the Fresnel term.                                      |\n//+------------------------------------------------------------------+\n//| To find the Fresnel term (F):                                    |\n//| If A is angle of incidence and B is the angle of refraction,     |\n//| then                                                             |\n//| F = 0.5*[tan2(A - B)/tan2(A + B) + sin2(A - B)/sin2(A + B)]      |\n//|   = 0.5*sin2(A - B)/sin2(A + B)*[cos2(A + B)/cos2(A - B) + 1]    |\n//|                                                                  |\n//|  Let r = sina(A)/sin(B)      (the relative refractive index)     |\n//|  Let c = cos(A)                                                  |\n//|  Let g = (r2 + c2 - 1)1/2                                        |\n//|                                                                  |\n//| Then,expanding using the trig identities and simplifying,        |\n//| you get:                                                         |\n//| F = 0.5*(g + c)2/(g - c)2*([c(g + c)-1]2/[c(g - c) + 1]2 + 1)    |\n//+------------------------------------------------------------------+\nfloat DXFresnelTerm(float costheta, float refractionindex) {\n  float g = (float)sqrt(refractionindex * refractionindex + costheta * costheta - 1.0f);\n  float a = g + costheta;\n  float d = g - costheta;\n  float result = (costheta * a - 1.0f) * (costheta * a - 1.0f) / ((costheta * d + 1.0f) * (costheta * d + 1.0f)) + 1.0f;\n  result *= 0.5f * d * d / (a * a);\n  //---\n  return (result);\n}\n//+------------------------------------------------------------------+\n//| Adds two 2D vectors.                                             |\n//+------------------------------------------------------------------+\nvoid DXVec2Add(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = pv1.x + pv2.x;\n  pout.y = pv1.y + pv2.y;\n}\n//+------------------------------------------------------------------+\n//| Returns a point in Barycentric coordinates,                      |\n//| using the specified 2D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec2BaryCentric(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2, const DXVector2 &pv3, float f,\n                       float g) {\n  pout.x = (1.0f - f - g) * (pv1.x) + f * (pv2.x) + g * (pv3.x);\n  pout.y = (1.0f - f - g) * (pv1.y) + f * (pv2.y) + g * (pv3.y);\n}\n//+------------------------------------------------------------------+\n//| Performs a Catmull-Rom interpolation,                            |\n//| using the specified 2D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec2CatmullRom(DXVector2 &pout, const DXVector2 &pv0, const DXVector2 &pv1, const DXVector2 &pv2,\n                      const DXVector2 &pv3, float s) {\n  pout.x = 0.5f * (2.0f * pv1.x + (pv2.x - pv0.x) * s + (2.0f * pv0.x - 5.0f * pv1.x + 4.0f * pv2.x - pv3.x) * s * s +\n                   (pv3.x - 3.0f * pv2.x + 3.0f * pv1.x - pv0.x) * s * s * s);\n  pout.y = 0.5f * (2.0f * pv1.y + (pv2.y - pv0.y) * s + (2.0f * pv0.y - 5.0f * pv1.y + 4.0f * pv2.y - pv3.y) * s * s +\n                   (pv3.y - 3.0f * pv2.y + 3.0f * pv1.y - pv0.y) * s * s * s);\n}\n//+------------------------------------------------------------------+\n//| Returns the z-component by taking the cross product              |\n//| of two 2D vectors.                                               |\n//+------------------------------------------------------------------+\nfloat DXVec2CCW(const DXVector2 &pv1, const DXVector2 &pv2) { return (pv1.x * pv2.y - pv1.y * pv2.x); }\n//+------------------------------------------------------------------+\n//| Determines the dot product of two 2D vectors.                    |\n//+------------------------------------------------------------------+\nfloat DXVec2Dot(const DXVector2 &pv1, const DXVector2 &pv2) { return (pv1.x * pv2.x + pv1.y * pv2.y); }\n//+------------------------------------------------------------------+\n//| Performs a Hermite spline interpolation,                         |\n//| using the specified 2D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec2Hermite(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pt1, const DXVector2 &pv2,\n                   const DXVector2 &pt2, float s) {\n  //--- prepare coefficients\n  float h1 = 2.0f * s * s * s - 3.0f * s * s + 1.0f;\n  float h2 = s * s * s - 2.0f * s * s + s;\n  float h3 = -2.0f * s * s * s + 3.0f * s * s;\n  float h4 = s * s * s - s * s;\n  //--- calculate interpolated point\n  pout.x = h1 * pv1.x + h2 * pt1.x + h3 * pv2.x + h4 * pt2.x;\n  pout.y = h1 * pv1.y + h2 * pt1.y + h3 * pv2.y + h4 * pt2.y;\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a 2D vector.                               |\n//+------------------------------------------------------------------+\nfloat DXVec2Length(const DXVector2 &v) { return ((float)sqrt(v.x * v.x + v.y * v.y)); }\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a 2D vector.                 |\n//+------------------------------------------------------------------+\nfloat DXVec2LengthSq(const DXVector2 &v) { return ((float)(v.x * v.x + v.y * v.y)); }\n//+------------------------------------------------------------------+\n//| Performs a linear interpolation between two 2D vectors.          |\n//+------------------------------------------------------------------+\nvoid DXVec2Lerp(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2, float s) {\n  pout.x = (1.0f - s) * pv1.x + s * pv2.x;\n  pout.y = (1.0f - s) * pv1.y + s * pv2.y;\n}\n//+------------------------------------------------------------------+\n//| Returns a 2D vector that is made up of the largest components    |\n//| of two 2D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec2Maximize(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = (float)fmax(pv1.x, pv2.x);\n  pout.y = (float)fmax(pv1.y, pv2.y);\n}\n//+------------------------------------------------------------------+\n//| Returns a 2D vector that is made up of the smallest components   |\n//| of two 2D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec2Minimize(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = (float)fmin(pv1.x, pv2.x);\n  pout.y = (float)fmin(pv1.y, pv2.y);\n}\n//+------------------------------------------------------------------+\n//| Returns the normalized version of a 2D vector.                   |\n//+------------------------------------------------------------------+\nvoid DXVec2Normalize(DXVector2 &pout, const DXVector2 &pv) {\n  //--- calculate length\n  float norm = DXVec2Length(pv);\n  if (!norm) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n  } else {\n    pout.x = pv.x / norm;\n    pout.y = pv.y / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Scales a 2D vector.                                              |\n//+------------------------------------------------------------------+\nvoid DXVec2Scale(DXVector2 &pout, const DXVector2 &pv, float s) {\n  pout.x = s * pv.x;\n  pout.y = s * pv.y;\n}\n//+------------------------------------------------------------------+\n//| DXVec3Subtract                                                   |\n//+------------------------------------------------------------------+\nvoid DXVec2Subtract(DXVector2 &pout, const DXVector2 &pv1, const DXVector2 &pv2) {\n  pout.x = pv1.x - pv2.x;\n  pout.y = pv1.y - pv2.y;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 2D vector by a given _matrix.                        |\n//| This function transforms the vector pv(x,y,0,1) by the _matrix pm.|\n//+------------------------------------------------------------------+\nvoid DXVec2Transform(DXVector4 &pout, const DXVector2 &pv, const DXMatrix &pm) {\n  DXVector4 out;\n  out.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[3][0];\n  out.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[3][1];\n  out.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[3][2];\n  out.w = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[3][3];\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 2D vector by a given _matrix,                        |\n//| projecting the result back into w = 1.                           |\n//| This function transforms the vector pv(x,y,0,1) by the _matrix pm.|\n//+------------------------------------------------------------------+\nvoid DXVec2TransformCoord(DXVector2 &pout, const DXVector2 &pv, const DXMatrix &pm) {\n  float norm = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[3][3];\n  if (norm) {\n    pout.x = (pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[3][0]) / norm;\n    pout.y = (pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[3][1]) / norm;\n  } else {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Transforms the 2D vector normal by the given _matrix.             |\n//+------------------------------------------------------------------+\nvoid DXVec2TransformNormal(DXVector2 &pout, const DXVector2 &pv, const DXMatrix &pm) {\n  pout.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y;\n  pout.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y;\n}\n//+------------------------------------------------------------------+\n//| Adds two 3D vectors.                                             |\n//+------------------------------------------------------------------+\nvoid DXVec3Add(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = pv1.x + pv2.x;\n  pout.y = pv1.y + pv2.y;\n  pout.z = pv1.z + pv2.z;\n}\n//+------------------------------------------------------------------+\n//| Returns a point in Barycentric coordinates,                      |\n//| using the specified 3D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec3BaryCentric(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2, const DXVector3 &pv3, float f,\n                       float g) {\n  pout.x = (1.0f - f - g) * pv1.x + f * pv2.x + g * pv3.x;\n  pout.y = (1.0f - f - g) * pv1.y + f * pv2.y + g * pv3.y;\n  pout.z = (1.0f - f - g) * pv1.z + f * pv2.z + g * pv3.z;\n}\n//+------------------------------------------------------------------+\n//| Performs a Catmull-Rom interpolation,                            |\n//| using the specified 3D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec3CatmullRom(DXVector3 &pout, const DXVector3 &pv0, const DXVector3 &pv1, const DXVector3 &pv2,\n                      const DXVector3 &pv3, float s) {\n  pout.x = 0.5f * (2.0f * pv1.x + (pv2.x - pv0.x) * s + (2.0f * pv0.x - 5.0f * pv1.x + 4.0f * pv2.x - pv3.x) * s * s +\n                   (pv3.x - 3.0f * pv2.x + 3.0f * pv1.x - pv0.x) * s * s * s);\n  pout.y = 0.5f * (2.0f * pv1.y + (pv2.y - pv0.y) * s + (2.0f * pv0.y - 5.0f * pv1.y + 4.0f * pv2.y - pv3.y) * s * s +\n                   (pv3.y - 3.0f * pv2.y + 3.0f * pv1.y - pv0.y) * s * s * s);\n  pout.z = 0.5f * (2.0f * pv1.z + (pv2.z - pv0.z) * s + (2.0f * pv0.z - 5.0f * pv1.z + 4.0f * pv2.z - pv3.z) * s * s +\n                   (pv3.z - 3.0f * pv2.z + 3.0f * pv1.z - pv0.z) * s * s * s);\n}\n//+------------------------------------------------------------------+\n//| Determines the cross-product of two 3D vectors.                  |\n//+------------------------------------------------------------------+\nvoid DXVec3Cross(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = pv1.y * pv2.z - pv1.z * pv2.y;\n  pout.y = pv1.z * pv2.x - pv1.x * pv2.z;\n  pout.z = pv1.x * pv2.y - pv1.y * pv2.x;\n}\n//+------------------------------------------------------------------+\n//| Determines the dot product of two 3D vectors.                    |\n//+------------------------------------------------------------------+\nfloat DXVec3Dot(const DXVector3 &pv1, const DXVector3 &pv2) { return (pv1.x * pv2.x + pv1.y * pv2.y + pv1.z * pv2.z); }\n//+------------------------------------------------------------------+\n//| Performs a Hermite spline interpolation,                         |\n//| using the specified 3D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec3Hermite(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pt1, const DXVector3 &pv2,\n                   const DXVector3 &pt2, float s) {\n  float h1 = 2.0f * s * s * s - 3.0f * s * s + 1.0f;\n  float h2 = s * s * s - 2.0f * s * s + s;\n  float h3 = -2.0f * s * s * s + 3.0f * s * s;\n  float h4 = s * s * s - s * s;\n  //--- calculate interpolated coordinates\n  pout.x = h1 * pv1.x + h2 * pt1.x + h3 * pv2.x + h4 * pt2.x;\n  pout.y = h1 * pv1.y + h2 * pt1.y + h3 * pv2.y + h4 * pt2.y;\n  pout.z = h1 * pv1.z + h2 * pt1.z + h3 * pv2.z + h4 * pt2.z;\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a 3D vector.                               |\n//+------------------------------------------------------------------+\nfloat DXVec3Length(const DXVector3 &pv) { return ((float)sqrt(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z)); }\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a 3D vector.                 |\n//+------------------------------------------------------------------+\nfloat DXVec3LengthSq(const DXVector3 &pv) { return ((float)(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z)); }\n//+------------------------------------------------------------------+\n//| Performs a linear interpolation between two 3D vectors.          |\n//+------------------------------------------------------------------+\nvoid DXVec3Lerp(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2, float s) {\n  pout.x = (1.0f - s) * pv1.x + s * pv2.x;\n  pout.y = (1.0f - s) * pv1.y + s * pv2.y;\n  pout.z = (1.0f - s) * pv1.z + s * pv2.z;\n}\n//+------------------------------------------------------------------+\n//| Returns a 3D vector that is made up of the largest components    |\n//| of two 3D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec3Maximize(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = (float)fmax(pv1.x, pv2.x);\n  pout.y = (float)fmax(pv1.y, pv2.y);\n  pout.z = (float)fmax(pv1.z, pv2.z);\n}\n//+------------------------------------------------------------------+\n//| Returns a 3D vector that is made up of the smallest components   |\n//| of two 3D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec3Minimize(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = (float)fmin(pv1.x, pv2.x);\n  pout.y = (float)fmin(pv1.y, pv2.y);\n  pout.z = (float)fmin(pv1.z, pv2.z);\n}\n//+------------------------------------------------------------------+\n//| Returns the normalized version of a 3D vector.                   |\n//+------------------------------------------------------------------+\nvoid DXVec3Normalize(DXVector3 &pout, const DXVector3 &pv) {\n  //--- calculate length\n  float norm = DXVec3Length(pv);\n  if (!norm) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n  } else {\n    pout.x = pv.x / norm;\n    pout.y = pv.y / norm;\n    pout.z = pv.z / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Projects a 3D vector from object space into screen space.        |\n//+------------------------------------------------------------------+\nvoid DXVec3Project(DXVector3 &pout, const DXVector3 &pv, const DViewport &pviewport, const DXMatrix &pprojection,\n                   const DXMatrix &pview, const DXMatrix &pworld) {\n  DXMatrix m;\n  DXMatrixIdentity(m);\n  //--- pworld\n  DXMatrixMultiply(m, m, pworld);\n  //--- pview\n  DXMatrixMultiply(m, m, pview);\n  //--- pprojection\n  DXMatrixMultiply(m, m, pprojection);\n  DXVec3TransformCoord(pout, pv, m);\n  //---pviewport\n  pout.x = pviewport.x + (1.0f + pout.x) * pviewport.width / 2.0f;\n  pout.y = pviewport.y + (1.0f - pout.y) * pviewport.height / 2.0f;\n  pout.z = pviewport.minz + pout.z * (pviewport.maxz - pviewport.minz);\n}\n//+------------------------------------------------------------------+\n//| Scales a 3D vector.                                              |\n//+------------------------------------------------------------------+\nvoid DXVec3Scale(DXVector3 &pout, const DXVector3 &pv, float s) {\n  pout.x = s * pv.x;\n  pout.y = s * pv.y;\n  pout.z = s * pv.z;\n}\n//+------------------------------------------------------------------+\n//| Subtracts two 3D vectors.                                        |\n//+------------------------------------------------------------------+\nvoid DXVec3Subtract(DXVector3 &pout, const DXVector3 &pv1, const DXVector3 &pv2) {\n  pout.x = pv1.x - pv2.x;\n  pout.y = pv1.y - pv2.y;\n  pout.z = pv1.z - pv2.z;\n}\n//+------------------------------------------------------------------+\n//| Transforms vector (x,y,z,1) by a given _matrix.                   |\n//+------------------------------------------------------------------+\nvoid DXVec3Transform(DXVector4 &pout, const DXVector3 &pv, const DXMatrix &pm) {\n  DXVector4 out;\n  //---\n  out.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z + pm.m[3][0];\n  out.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z + pm.m[3][1];\n  out.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z + pm.m[3][2];\n  out.w = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[2][3] * pv.z + pm.m[3][3];\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 3D vector by a given _matrix,                        |\n//| projecting the result back into w = 1.                           |\n//+------------------------------------------------------------------+\nvoid DXVec3TransformCoord(DXVector3 &pout, const DXVector3 &pv, const DXMatrix &pm) {\n  float norm = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[2][3] * pv.z + pm.m[3][3];\n  //---\n  if (norm) {\n    pout.x = (pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z + pm.m[3][0]) / norm;\n    pout.y = (pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z + pm.m[3][1]) / norm;\n    pout.z = (pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z + pm.m[3][2]) / norm;\n  } else {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Transforms the 3D vector normal by the given _matrix.             |\n//+------------------------------------------------------------------+\nvoid DXVec3TransformNormal(DXVector3 &pout, const DXVector3 &pv, const DXMatrix &pm) {\n  pout.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z;\n  pout.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z;\n  pout.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z;\n}\n//+------------------------------------------------------------------+\n//| Projects a vector from screen space into object space.           |\n//+------------------------------------------------------------------+\nvoid DXVec3Unproject(DXVector3 &out, const DXVector3 &v, const DViewport &viewport, const DXMatrix &projection,\n                     const DXMatrix &view, const DXMatrix &world) {\n  DXMatrix m;\n  DXMatrixIdentity(m);\n  //--- world\n  DXMatrixMultiply(m, m, world);\n  //--- view\n  DXMatrixMultiply(m, m, view);\n  //--- projection\n  DXMatrixMultiply(m, m, projection);\n  //--- calculate inverse _matrix\n  float det = 0.0f;\n  DXMatrixInverse(m, det, m);\n  out = v;\n  //--- viewport\n  out.x = 2.0f * (out.x - viewport.x) / viewport.width - 1.0f;\n  out.y = 1.0f - 2.0f * (out.y - viewport.y) / viewport.height;\n  out.z = (out.z - viewport.minz) / (viewport.maxz - viewport.minz);\n  //---\n  DXVec3TransformCoord(out, out, m);\n}\n//+------------------------------------------------------------------+\n//| Adds two 4D vectors.                                             |\n//+------------------------------------------------------------------+\nvoid DXVec4Add(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = pv1.x + pv2.x;\n  pout.y = pv1.y + pv2.y;\n  pout.z = pv1.z + pv2.z;\n  pout.w = pv1.w + pv2.w;\n}\n//+------------------------------------------------------------------+\n//| Returns a point in Barycentric coordinates,                      |\n//| using the specified 4D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec4BaryCentric(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2, const DXVector4 &pv3, float f,\n                       float g) {\n  pout.x = (1.0f - f - g) * (pv1.x) + f * (pv2.x) + g * (pv3.x);\n  pout.y = (1.0f - f - g) * (pv1.y) + f * (pv2.y) + g * (pv3.y);\n  pout.z = (1.0f - f - g) * (pv1.z) + f * (pv2.z) + g * (pv3.z);\n  pout.w = (1.0f - f - g) * (pv1.w) + f * (pv2.w) + g * (pv3.w);\n}\n//+------------------------------------------------------------------+\n//| Performs a Catmull-Rom interpolation,                            |\n//| using the specified 4D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec4CatmullRom(DXVector4 &pout, const DXVector4 &pv0, const DXVector4 &pv1, const DXVector4 &pv2,\n                      const DXVector4 &pv3, float s) {\n  pout.x = 0.5f * (2.0f * pv1.x + (pv2.x - pv0.x) * s + (2.0f * pv0.x - 5.0f * pv1.x + 4.0f * pv2.x - pv3.x) * s * s +\n                   (pv3.x - 3.0f * pv2.x + 3.0f * pv1.x - pv0.x) * s * s * s);\n  pout.y = 0.5f * (2.0f * pv1.y + (pv2.y - pv0.y) * s + (2.0f * pv0.y - 5.0f * pv1.y + 4.0f * pv2.y - pv3.y) * s * s +\n                   (pv3.y - 3.0f * pv2.y + 3.0f * pv1.y - pv0.y) * s * s * s);\n  pout.z = 0.5f * (2.0f * pv1.z + (pv2.z - pv0.z) * s + (2.0f * pv0.z - 5.0f * pv1.z + 4.0f * pv2.z - pv3.z) * s * s +\n                   (pv3.z - 3.0f * pv2.z + 3.0f * pv1.z - pv0.z) * s * s * s);\n  pout.w = 0.5f * (2.0f * pv1.w + (pv2.w - pv0.w) * s + (2.0f * pv0.w - 5.0f * pv1.w + 4.0f * pv2.w - pv3.w) * s * s +\n                   (pv3.w - 3.0f * pv2.w + 3.0f * pv1.w - pv0.w) * s * s * s);\n}\n//+------------------------------------------------------------------+\n//| Determines the cross-product in four dimensions.                 |\n//+------------------------------------------------------------------+\nvoid DXVec4Cross(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2, const DXVector4 &pv3) {\n  DXVector4 out;\n  out.x = pv1.y * (pv2.z * pv3.w - pv3.z * pv2.w) - pv1.z * (pv2.y * pv3.w - pv3.y * pv2.w) +\n          pv1.w * (pv2.y * pv3.z - pv2.z * pv3.y);\n  out.y = -(pv1.x * (pv2.z * pv3.w - pv3.z * pv2.w) - pv1.z * (pv2.x * pv3.w - pv3.x * pv2.w) +\n            pv1.w * (pv2.x * pv3.z - pv3.x * pv2.z));\n  out.z = pv1.x * (pv2.y * pv3.w - pv3.y * pv2.w) - pv1.y * (pv2.x * pv3.w - pv3.x * pv2.w) +\n          pv1.w * (pv2.x * pv3.y - pv3.x * pv2.y);\n  out.w = -(pv1.x * (pv2.y * pv3.z - pv3.y * pv2.z) - pv1.y * (pv2.x * pv3.z - pv3.x * pv2.z) +\n            pv1.z * (pv2.x * pv3.y - pv3.x * pv2.y));\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Determines the dot product of two 4D vectors.                    |\n//+------------------------------------------------------------------+\nfloat DXVec4Dot(const DXVector4 &pv1, const DXVector4 &pv2) {\n  return (pv1.x * pv2.x + pv1.y * pv2.y + pv1.z * pv2.z + pv1.w * pv2.w);\n}\n//+------------------------------------------------------------------+\n//| Performs a Hermite spline interpolation,                         |\n//| using the specified 4D vectors.                                  |\n//+------------------------------------------------------------------+\nvoid DXVec4Hermite(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pt1, const DXVector4 &pv2,\n                   const DXVector4 &pt2, float s) {\n  float h1 = 2.0f * s * s * s - 3.0f * s * s + 1.0f;\n  float h2 = s * s * s - 2.0f * s * s + s;\n  float h3 = -2.0f * s * s * s + 3.0f * s * s;\n  float h4 = s * s * s - s * s;\n  pout.x = h1 * pv1.x + h2 * pt1.x + h3 * pv2.x + h4 * pt2.x;\n  pout.y = h1 * pv1.y + h2 * pt1.y + h3 * pv2.y + h4 * pt2.y;\n  pout.z = h1 * pv1.z + h2 * pt1.z + h3 * pv2.z + h4 * pt2.z;\n  pout.w = h1 * pv1.w + h2 * pt1.w + h3 * pv2.w + h4 * pt2.w;\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a 4D vector.                               |\n//+------------------------------------------------------------------+\nfloat DXVec4Length(const DXVector4 &pv) { return ((float)sqrt(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z + pv.w * pv.w)); }\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a 4D vector.                 |\n//+------------------------------------------------------------------+\nfloat DXVec4LengthSq(const DXVector4 &pv) { return ((float)(pv.x * pv.x + pv.y * pv.y + pv.z * pv.z)); }\n//+------------------------------------------------------------------+\n//| Performs a linear interpolation between two 4D vectors.          |\n//+------------------------------------------------------------------+\nvoid DXVec4Lerp(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2, float s) {\n  pout.x = (1.0f - s) * pv1.x + s * pv2.x;\n  pout.y = (1.0f - s) * pv1.y + s * pv2.y;\n  pout.z = (1.0f - s) * pv1.z + s * pv2.z;\n  pout.w = (1.0f - s) * pv1.w + s * pv2.w;\n}\n//+------------------------------------------------------------------+\n//| Returns a 4D vector that is made up of the largest components    |\n//| of two 4D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec4Maximize(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = (float)fmax(pv1.x, pv2.x);\n  pout.y = (float)fmax(pv1.y, pv2.y);\n  pout.z = (float)fmax(pv1.z, pv2.z);\n  pout.w = (float)fmax(pv1.w, pv2.w);\n}\n//+------------------------------------------------------------------+\n//| Returns a 4D vector that is made up of the smallest components   |\n//| of two 4D vectors.                                               |\n//+------------------------------------------------------------------+\nvoid DXVec4Minimize(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = (float)fmin(pv1.x, pv2.x);\n  pout.y = (float)fmin(pv1.y, pv2.y);\n  pout.z = (float)fmin(pv1.z, pv2.z);\n  pout.w = (float)fmin(pv1.w, pv2.w);\n}\n//+------------------------------------------------------------------+\n//| Returns the normalized version of a 4D vector.                   |\n//+------------------------------------------------------------------+\nvoid DXVec4Normalize(DXVector4 &pout, const DXVector4 &pv) {\n  //--- calculate length\n  float norm = DXVec4Length(pv);\n  if (!norm) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n    pout.w = 0.0f;\n  } else {\n    pout.x = pv.x / norm;\n    pout.y = pv.y / norm;\n    pout.z = pv.z / norm;\n    pout.w = pv.w / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Scales a 4D vector.                                              |\n//+------------------------------------------------------------------+\nvoid DXVec4Scale(DXVector4 &pout, const DXVector4 &pv, float s) {\n  pout.x = s * pv.x;\n  pout.y = s * pv.y;\n  pout.z = s * pv.z;\n  pout.w = s * pv.w;\n}\n//+------------------------------------------------------------------+\n//| Subtracts two 4D vectors.                                        |\n//+------------------------------------------------------------------+\nvoid DXVec4Subtract(DXVector4 &pout, const DXVector4 &pv1, const DXVector4 &pv2) {\n  pout.x = pv1.x - pv2.x;\n  pout.y = pv1.y - pv2.y;\n  pout.z = pv1.z - pv2.z;\n  pout.w = pv1.w - pv2.w;\n}\n//+------------------------------------------------------------------+\n//| Transforms a 4D vector by a given _matrix.                        |\n//+------------------------------------------------------------------+\nvoid DXVec4Transform(DXVector4 &pout, const DXVector4 &pv, const DXMatrix &pm) {\n  DXVector4 temp;\n  temp.x = pm.m[0][0] * pv.x + pm.m[1][0] * pv.y + pm.m[2][0] * pv.z + pm.m[3][0] * pv.w;\n  temp.y = pm.m[0][1] * pv.x + pm.m[1][1] * pv.y + pm.m[2][1] * pv.z + pm.m[3][1] * pv.w;\n  temp.z = pm.m[0][2] * pv.x + pm.m[1][2] * pv.y + pm.m[2][2] * pv.z + pm.m[3][2] * pv.w;\n  temp.w = pm.m[0][3] * pv.x + pm.m[1][3] * pv.y + pm.m[2][3] * pv.z + pm.m[3][3] * pv.w;\n  pout = temp;\n}\n//+------------------------------------------------------------------+\n//| Returns a quaternion in barycentric coordinates.                 |\n//+------------------------------------------------------------------+\nvoid DXQuaternionBaryCentric(DXQuaternion &pout, DXQuaternion &pq1, DXQuaternion &pq2, DXQuaternion &pq3, float f,\n                             float g) {\n  DXQuaternion temp1, temp2;\n  DXQuaternionSlerp(temp1, pq1, pq2, f + g);\n  DXQuaternionSlerp(temp2, pq1, pq3, f + g);\n  DXQuaternionSlerp(pout, temp1, temp2, g / (f + g));\n}\n//+------------------------------------------------------------------+\n//| Returns the conjugate of a quaternion.                           |\n//+------------------------------------------------------------------+\nvoid DXQuaternionConjugate(DXQuaternion &pout, const DXQuaternion &pq) {\n  pout.x = -pq.x;\n  pout.y = -pq.y;\n  pout.z = -pq.z;\n  pout.w = pq.w;\n}\n//+------------------------------------------------------------------+\n//| Returns the dot product of two quaternions.                      |\n//+------------------------------------------------------------------+\nfloat DXQuaternionDot(DXQuaternion &a, DXQuaternion &b) { return (a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w); }\n//+------------------------------------------------------------------+\n//| Calculates the exponential.                                      |\n//| This method converts a pure quaternion to a unit quaternion.     |\n//| DXQuaternionExp expects a pure quaternion, where w is ignored    |\n//| in the calculation (w == 0).                                     |\n//+------------------------------------------------------------------+\nvoid DXQuaternionExp(DXQuaternion &out, const DXQuaternion &q) {\n  float norm = (float)sqrt(q.x * q.x + q.y * q.y + q.z * q.z);\n  if (norm) {\n    out.x = (float)sin(norm) * q.x / norm;\n    out.y = (float)sin(norm) * q.y / norm;\n    out.z = (float)sin(norm) * q.z / norm;\n    out.w = (float)cos(norm);\n  } else {\n    out.x = 0.0f;\n    out.y = 0.0f;\n    out.z = 0.0f;\n    out.w = 1.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Returns the identity quaternion.                                 |\n//+------------------------------------------------------------------+\nvoid DXQuaternionIdentity(DXQuaternion &out) {\n  out.x = 0.0f;\n  out.y = 0.0f;\n  out.z = 0.0f;\n  out.w = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Determines if a quaternion is an identity quaternion.            |\n//+------------------------------------------------------------------+\nbool DXQuaternionIsIdentity(DXQuaternion &pq) {\n  return ((pq.x == 0.0f) && (pq.y == 0.0f) && (pq.z == 0.0f) && (pq.w == 1.0f));\n}\n//+------------------------------------------------------------------+\n//| Returns the length of a quaternion.                              |\n//+------------------------------------------------------------------+\nfloat DXQuaternionLength(const DXQuaternion &pq) {\n  return ((float)sqrt(pq.x * pq.x + pq.y * pq.y + pq.z * pq.z + pq.w * pq.w));\n}\n//+------------------------------------------------------------------+\n//| Returns the square of the length of a quaternion.                |\n//+------------------------------------------------------------------+\nfloat DXQuaternionLengthSq(const DXQuaternion &pq) {\n  return ((float)(pq.x * pq.x + pq.y * pq.y + pq.z * pq.z + pq.w * pq.w));\n}\n//+------------------------------------------------------------------+\n//| Conjugates and renormalizes a quaternion.                        |\n//+------------------------------------------------------------------+\nvoid DXQuaternionInverse(DXQuaternion &pout, const DXQuaternion &pq) {\n  float norm = DXQuaternionLengthSq(pq);\n  pout.x = -pq.x / norm;\n  pout.y = -pq.y / norm;\n  pout.z = -pq.z / norm;\n  pout.w = pq.w / norm;\n}\n//+------------------------------------------------------------------+\n//| Calculates the natural logarithm.                                |\n//| The DXQuaternionLn function works only for unit quaternions.     |\n//+------------------------------------------------------------------+\nvoid DXQuaternionLn(DXQuaternion &out, const DXQuaternion &q) {\n  float t;\n  if ((q.w >= 1.0f) || (q.w == -1.0f))\n    t = 1.0f;\n  else\n    t = (float)(acos(q.w) / sqrt(1.0f - q.w * q.w));\n  out.x = t * q.x;\n  out.y = t * q.y;\n  out.z = t * q.z;\n  out.w = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Multiplies two quaternions.                                      |\n//+------------------------------------------------------------------+\nvoid DXQuaternionMultiply(DXQuaternion &pout, const DXQuaternion &pq1, const DXQuaternion &pq2) {\n  DXQuaternion out;\n  out.x = pq2.w * pq1.x + pq2.x * pq1.w + pq2.y * pq1.z - pq2.z * pq1.y;\n  out.y = pq2.w * pq1.y - pq2.x * pq1.z + pq2.y * pq1.w + pq2.z * pq1.x;\n  out.z = pq2.w * pq1.z + pq2.x * pq1.y - pq2.y * pq1.x + pq2.z * pq1.w;\n  out.w = pq2.w * pq1.w - pq2.x * pq1.x - pq2.y * pq1.y - pq2.z * pq1.z;\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Computes a unit length quaternion.                               |\n//+------------------------------------------------------------------+\nvoid DXQuaternionNormalize(DXQuaternion &out, const DXQuaternion &q) {\n  float norm = DXQuaternionLength(q);\n  if (!norm) {\n    out.x = 0.0f;\n    out.y = 0.0f;\n    out.z = 0.0f;\n    out.w = 0.0f;\n  } else {\n    out.x = q.x / norm;\n    out.y = q.y / norm;\n    out.z = q.z / norm;\n    out.w = q.w / norm;\n  }\n}\n//+------------------------------------------------------------------+\n//| Rotates a quaternion about an arbitrary axis.                    |\n//+------------------------------------------------------------------+\nvoid DXQuaternionRotationAxis(DXQuaternion &out, const DXVector3 &v, float angle) {\n  DXVector3 temp;\n  DXVec3Normalize(temp, v);\n  out.x = (float)sin(angle / 2.0f) * temp.x;\n  out.y = (float)sin(angle / 2.0f) * temp.y;\n  out.z = (float)sin(angle / 2.0f) * temp.z;\n  out.w = (float)cos(angle / 2.0f);\n}\n//+------------------------------------------------------------------+\n//| Builds a quaternion from a rotation _matrix.                      |\n//+------------------------------------------------------------------+\nvoid DXQuaternionRotationMatrix(DXQuaternion &out, const DXMatrix &m) {\n  float s;\n  float trace = m.m[0][0] + m.m[1][1] + m.m[2][2] + 1.0f;\n  if (trace > 1.0f) {\n    s = 2.0f * (float)sqrt(trace);\n    out.x = (m.m[1][2] - m.m[2][1]) / s;\n    out.y = (m.m[2][0] - m.m[0][2]) / s;\n    out.z = (m.m[0][1] - m.m[1][0]) / s;\n    out.w = 0.25f * s;\n  } else {\n    int maxi = 0;\n    for (int i = 1; i < 3; i++) {\n      if (m.m[i][i] > m.m[maxi][maxi]) maxi = i;\n    }\n    switch (maxi) {\n      case 0:\n        s = 2.0f * (float)sqrt(1.0f + m.m[0][0] - m.m[1][1] - m.m[2][2]);\n        out.x = 0.25f * s;\n        out.y = (m.m[0][1] + m.m[1][0]) / s;\n        out.z = (m.m[0][2] + m.m[2][0]) / s;\n        out.w = (m.m[1][2] - m.m[2][1]) / s;\n        break;\n\n      case 1:\n        s = 2.0f * (float)sqrt(1.0f + m.m[1][1] - m.m[0][0] - m.m[2][2]);\n        out.x = (m.m[0][1] + m.m[1][0]) / s;\n        out.y = 0.25f * s;\n        out.z = (m.m[1][2] + m.m[2][1]) / s;\n        out.w = (m.m[2][0] - m.m[0][2]) / s;\n        break;\n\n      case 2:\n        s = 2.0f * (float)sqrt(1.0f + m.m[2][2] - m.m[0][0] - m.m[1][1]);\n        out.x = (m.m[0][2] + m.m[2][0]) / s;\n        out.y = (m.m[1][2] + m.m[2][1]) / s;\n        out.z = 0.25f * s;\n        out.w = (m.m[0][1] - m.m[1][0]) / s;\n        break;\n    }\n  }\n}\n//+------------------------------------------------------------------+\n//| Builds a quaternion with the given yaw, pitch, and roll.         |\n//+------------------------------------------------------------------+\nvoid DXQuaternionRotationYawPitchRoll(DXQuaternion &out, float yaw, float pitch, float roll) {\n  float syaw = (float)sin(yaw / 2.0f);\n  float cyaw = (float)cos(yaw / 2.0f);\n  float spitch = (float)sin(pitch / 2.0f);\n  float cpitch = (float)cos(pitch / 2.0f);\n  float sroll = (float)sin(roll / 2.0f);\n  float croll = (float)cos(roll / 2.0f);\n  //---\n  out.x = syaw * cpitch * sroll + cyaw * spitch * croll;\n  out.y = syaw * cpitch * croll - cyaw * spitch * sroll;\n  out.z = cyaw * cpitch * sroll - syaw * spitch * croll;\n  out.w = cyaw * cpitch * croll + syaw * spitch * sroll;\n}\n//+------------------------------------------------------------------+\n//| Interpolates between two quaternions, using spherical linear     |\n//| interpolation.                                                   |\n//+------------------------------------------------------------------+\nvoid DXQuaternionSlerp(DXQuaternion &out, DXQuaternion &q1, DXQuaternion &q2, float t) {\n  float temp = 1.0f - t;\n  float dot = DXQuaternionDot(q1, q2);\n  if (dot < 0.0f) {\n    t = -t;\n    dot = -dot;\n  }\n  if (1.0f - dot > 0.001f) {\n    float theta = (float)acos(dot);\n    temp = (float)sin(theta * temp) / (float)sin(theta);\n    t = (float)sin(theta * t) / (float)sin(theta);\n  }\n  out.x = temp * q1.x + t * q2.x;\n  out.y = temp * q1.y + t * q2.y;\n  out.z = temp * q1.z + t * q2.z;\n  out.w = temp * q1.w + t * q2.w;\n}\n//+------------------------------------------------------------------+\n//| Interpolates between quaternions, using spherical quadrangle     |\n//| interpolation.                                                   |\n//+------------------------------------------------------------------+\nvoid DXQuaternionSquad(DXQuaternion &pout, DXQuaternion &pq1, DXQuaternion &pq2, DXQuaternion &pq3, DXQuaternion &pq4,\n                       float t) {\n  DXQuaternion temp1, temp2;\n  DXQuaternionSlerp(temp1, pq1, pq4, t);\n  DXQuaternionSlerp(temp2, pq2, pq3, t);\n  DXQuaternionSlerp(pout, temp1, temp2, 2.0f * t * (1.0f - t));\n}\n//+------------------------------------------------------------------+\n//| add_diff                                                         |\n//+------------------------------------------------------------------+\nDXQuaternion add_diff(const DXQuaternion &q1, const DXQuaternion &q2, const float add) {\n  DXQuaternion temp;\n  temp.x = q1.x + add * q2.x;\n  temp.y = q1.y + add * q2.y;\n  temp.z = q1.z + add * q2.z;\n  temp.w = q1.w + add * q2.w;\n  //---\n  return (temp);\n}\n//+------------------------------------------------------------------+\n//| Sets up control points for spherical quadrangle interpolation.   |\n//+------------------------------------------------------------------+\nvoid DXQuaternionSquadSetup(DXQuaternion &paout, DXQuaternion &pbout, DXQuaternion &pcout, DXQuaternion &pq0,\n                            DXQuaternion &pq1, DXQuaternion &pq2, DXQuaternion &pq3) {\n  DXQuaternion q, temp1, temp2, temp3, zero;\n  DXQuaternion aout, cout;\n  zero.x = 0.0f;\n  zero.y = 0.0f;\n  zero.z = 0.0f;\n  zero.w = 0.0f;\n  //---\n  if (DXQuaternionDot(pq0, pq1) < 0.0f)\n    temp2 = add_diff(zero, pq0, -1.0f);\n  else\n    temp2 = pq0;\n  //---\n  if (DXQuaternionDot(pq1, pq2) < 0.0f)\n    cout = add_diff(zero, pq2, -1.0f);\n  else\n    cout = pq2;\n  //---\n  if (DXQuaternionDot(cout, pq3) < 0.0f)\n    temp3 = add_diff(zero, pq3, -1.0f);\n  else\n    temp3 = pq3;\n  //---\n  DXQuaternionInverse(temp1, pq1);\n  DXQuaternionMultiply(temp2, temp1, temp2);\n  DXQuaternionLn(temp2, temp2);\n  DXQuaternionMultiply(q, temp1, cout);\n  DXQuaternionLn(q, q);\n  temp1 = add_diff(temp2, q, 1.0f);\n  temp1.x *= -0.25f;\n  temp1.y *= -0.25f;\n  temp1.z *= -0.25f;\n  temp1.w *= -0.25f;\n  DXQuaternionExp(temp1, temp1);\n  DXQuaternionMultiply(aout, pq1, temp1);\n  //---\n  DXQuaternionInverse(temp1, cout);\n  DXQuaternionMultiply(temp2, temp1, pq1);\n  DXQuaternionLn(temp2, temp2);\n  DXQuaternionMultiply(q, temp1, temp3);\n  DXQuaternionLn(q, q);\n  temp1 = add_diff(temp2, q, 1.0f);\n  temp1.x *= -0.25f;\n  temp1.y *= -0.25f;\n  temp1.z *= -0.25f;\n  temp1.w *= -0.25f;\n  DXQuaternionExp(temp1, temp1);\n  DXQuaternionMultiply(pbout, cout, temp1);\n  paout = aout;\n  pcout = cout;\n}\n//+------------------------------------------------------------------+\n//| Computes a quaternion's axis and angle of rotation.              |\n//+------------------------------------------------------------------+\nvoid DXQuaternionToAxisAngle(const DXQuaternion &pq, DXVector3 &paxis, float &pangle) {\n  //--- paxis\n  paxis.x = pq.x;\n  paxis.y = pq.y;\n  paxis.z = pq.z;\n  //--- pangle\n  pangle = 2.0f * (float)acos(pq.w);\n}\n//+------------------------------------------------------------------+\n//| DXMatrixIdentity creates an identity _matrix                      |\n//+------------------------------------------------------------------+\nvoid DXMatrixIdentity(DXMatrix &out) {\n  for (int j = 0; j < 4; j++)\n    for (int i = 0; i < 4; i++) {\n      if (i == j)\n        out.m[j, i] = 1.0f;\n      else\n        out.m[j, i] = 0.0f;\n    }\n}\n//+------------------------------------------------------------------+\n//| Determines if a _matrix is an identity _matrix.                    |\n//+------------------------------------------------------------------+\nbool DXMatrixIsIdentity(DXMatrix &pm) {\n  for (int j = 0; j < 4; j++)\n    for (int i = 0; i < 4; i++) {\n      if (i == j) {\n        if (fabs(pm.m[j, i] - 1.0f) > 1e-6f) return (false);\n      } else if (fabs(pm.m[j, i]) > 1e-6f)\n        return (false);\n    }\n  //---\n  return (true);\n}\n//+------------------------------------------------------------------+\n//| Builds a 3D affine transformation _matrix.                        |\n//+------------------------------------------------------------------+\n//| This function calculates the affine transformation _matrix        |\n//| with the following formula, with _matrix concatenation            |\n//| evaluated in left-to-right order:                                |\n//|             Mout = Ms * (Mrc)-1 * Mr * Mrc * Mt                  |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Ms = scaling _matrix (Scaling)                                    |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (pRotation)                                 |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixAffineTransformation(DXMatrix &out, float scaling, const DXVector3 &rotationcenter,\n                                  const DXQuaternion &rotation, const DXVector3 &translation) {\n  DXMatrixIdentity(out);\n  //--- rotation\n  float temp00 = 1.0f - 2.0f * (rotation.y * rotation.y + rotation.z * rotation.z);\n  float temp01 = 2.0f * (rotation.x * rotation.y + rotation.z * rotation.w);\n  float temp02 = 2.0f * (rotation.x * rotation.z - rotation.y * rotation.w);\n  float temp10 = 2.0f * (rotation.x * rotation.y - rotation.z * rotation.w);\n  float temp11 = 1.0f - 2.0f * (rotation.x * rotation.x + rotation.z * rotation.z);\n  float temp12 = 2.0f * (rotation.y * rotation.z + rotation.x * rotation.w);\n  float temp20 = 2.0f * (rotation.x * rotation.z + rotation.y * rotation.w);\n  float temp21 = 2.0f * (rotation.y * rotation.z - rotation.x * rotation.w);\n  float temp22 = 1.0f - 2.0f * (rotation.x * rotation.x + rotation.y * rotation.y);\n  //--- scaling\n  out.m[0][0] = scaling * temp00;\n  out.m[0][1] = scaling * temp01;\n  out.m[0][2] = scaling * temp02;\n  out.m[1][0] = scaling * temp10;\n  out.m[1][1] = scaling * temp11;\n  out.m[1][2] = scaling * temp12;\n  out.m[2][0] = scaling * temp20;\n  out.m[2][1] = scaling * temp21;\n  out.m[2][2] = scaling * temp22;\n  //--- rotationcenter\n  out.m[3][0] = rotationcenter.x * (1.0f - temp00) - rotationcenter.y * temp10 - rotationcenter.z * temp20;\n  out.m[3][1] = rotationcenter.y * (1.0f - temp11) - rotationcenter.x * temp01 - rotationcenter.z * temp21;\n  out.m[3][2] = rotationcenter.z * (1.0f - temp22) - rotationcenter.x * temp02 - rotationcenter.y * temp12;\n  //--- translation\n  out.m[3][0] += translation.x;\n  out.m[3][1] += translation.y;\n  out.m[3][2] += translation.z;\n}\n//+------------------------------------------------------------------+\n//| Builds a 2D affine transformation _matrix in the xy plane.        |\n//+------------------------------------------------------------------+\n//| This function calculates the affine transformation _matrix        |\n//| with the following formula, with _matrix concatenation evaluated  |\n//| in left-to-right order:                                          |\n//|             Mout = Ms * (Mrc)^(-1) * Mr * Mrc * Mt               |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Ms = scaling _matrix (Scaling)                                    |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (Rotation)                                  |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixAffineTransformation2D(DXMatrix &out, float scaling, const DXVector2 &rotationcenter, float rotation,\n                                    const DXVector2 &translation) {\n  float s = (float)sin(rotation / 2.0f);\n  float tmp1 = 1.0f - 2.0f * s * s;\n  float tmp2 = 2.0f * s * (float)cos(rotation / 2.0f);\n  //---\n  DXMatrixIdentity(out);\n  out.m[0][0] = scaling * tmp1;\n  out.m[0][1] = scaling * tmp2;\n  out.m[1][0] = -scaling * tmp2;\n  out.m[1][1] = scaling * tmp1;\n  //--- rotationcenter\n  float x = rotationcenter.x;\n  float y = rotationcenter.y;\n  out.m[3][0] = y * tmp2 - x * tmp1 + x;\n  out.m[3][1] = -x * tmp2 - y * tmp1 + y;\n  //--- translation\n  out.m[3][0] += translation.x;\n  out.m[3][1] += translation.y;\n}\n#define D3DERR_INVALIDCALL -2005530516\n//#define S_OK                 0;\n//+------------------------------------------------------------------+\n//| Breaks down a general 3D transformation _matrix into its scalar,  |\n//| rotational, and translational components.                        |\n//+------------------------------------------------------------------+\nint DXMatrixDecompose(DXVector3 &poutscale, DXQuaternion &poutrotation, DXVector3 &pouttranslation,\n                      const DXMatrix &pm) {\n  DXMatrix normalized;\n  DXVector3 vec;\n  //--- Compute the scaling part\n  vec.x = pm.m[0][0];\n  vec.y = pm.m[0][1];\n  vec.z = pm.m[0][2];\n  poutscale.x = DXVec3Length(vec);\n  vec.x = pm.m[1][0];\n  vec.y = pm.m[1][1];\n  vec.z = pm.m[1][2];\n  poutscale.y = DXVec3Length(vec);\n  vec.x = pm.m[2][0];\n  vec.y = pm.m[2][1];\n  vec.z = pm.m[2][2];\n  poutscale.z = DXVec3Length(vec);\n  //--- compute the translation part\n  pouttranslation.x = pm.m[3][0];\n  pouttranslation.y = pm.m[3][1];\n  pouttranslation.z = pm.m[3][2];\n  //--- let's calculate the rotation now\n  if ((poutscale.x == 0.0f) || (poutscale.y == 0.0f) || (poutscale.z == 0.0f)) return (D3DERR_INVALIDCALL);\n  //---\n  normalized.m[0][0] = pm.m[0][0] / poutscale.x;\n  normalized.m[0][1] = pm.m[0][1] / poutscale.x;\n  normalized.m[0][2] = pm.m[0][2] / poutscale.x;\n  normalized.m[1][0] = pm.m[1][0] / poutscale.y;\n  normalized.m[1][1] = pm.m[1][1] / poutscale.y;\n  normalized.m[1][2] = pm.m[1][2] / poutscale.y;\n  normalized.m[2][0] = pm.m[2][0] / poutscale.z;\n  normalized.m[2][1] = pm.m[2][1] / poutscale.z;\n  normalized.m[2][2] = pm.m[2][2] / poutscale.z;\n  DXQuaternionRotationMatrix(poutrotation, normalized);\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Returns the determinant of a _matrix.                             |\n//+------------------------------------------------------------------+\nfloat DXMatrixDeterminant(const DXMatrix &pm) {\n  float t[3], v[4];\n  t[0] = pm.m[2][2] * pm.m[3][3] - pm.m[2][3] * pm.m[3][2];\n  t[1] = pm.m[1][2] * pm.m[3][3] - pm.m[1][3] * pm.m[3][2];\n  t[2] = pm.m[1][2] * pm.m[2][3] - pm.m[1][3] * pm.m[2][2];\n  v[0] = pm.m[1][1] * t[0] - pm.m[2][1] * t[1] + pm.m[3][1] * t[2];\n  v[1] = -pm.m[1][0] * t[0] + pm.m[2][0] * t[1] - pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[1][0] * pm.m[2][1] - pm.m[2][0] * pm.m[1][1];\n  t[1] = pm.m[1][0] * pm.m[3][1] - pm.m[3][0] * pm.m[1][1];\n  t[2] = pm.m[2][0] * pm.m[3][1] - pm.m[3][0] * pm.m[2][1];\n  v[2] = pm.m[3][3] * t[0] - pm.m[2][3] * t[1] + pm.m[1][3] * t[2];\n  v[3] = -pm.m[3][2] * t[0] + pm.m[2][2] * t[1] - pm.m[1][2] * t[2];\n  //---\n  return (pm.m[0][0] * v[0] + pm.m[0][1] * v[1] + pm.m[0][2] * v[2] + pm.m[0][3] * v[3]);\n}\n//+------------------------------------------------------------------+\n//| Calculates the inverse of a _matrix.                              |\n//+------------------------------------------------------------------+\nvoid DXMatrixInverse(DXMatrix &pout, float &pdeterminant, const DXMatrix &pm) {\n  float t[3], v[16];\n  t[0] = pm.m[2][2] * pm.m[3][3] - pm.m[2][3] * pm.m[3][2];\n  t[1] = pm.m[1][2] * pm.m[3][3] - pm.m[1][3] * pm.m[3][2];\n  t[2] = pm.m[1][2] * pm.m[2][3] - pm.m[1][3] * pm.m[2][2];\n  v[0] = pm.m[1][1] * t[0] - pm.m[2][1] * t[1] + pm.m[3][1] * t[2];\n  v[4] = -pm.m[1][0] * t[0] + pm.m[2][0] * t[1] - pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[1][0] * pm.m[2][1] - pm.m[2][0] * pm.m[1][1];\n  t[1] = pm.m[1][0] * pm.m[3][1] - pm.m[3][0] * pm.m[1][1];\n  t[2] = pm.m[2][0] * pm.m[3][1] - pm.m[3][0] * pm.m[2][1];\n  v[8] = pm.m[3][3] * t[0] - pm.m[2][3] * t[1] + pm.m[1][3] * t[2];\n  v[12] = -pm.m[3][2] * t[0] + pm.m[2][2] * t[1] - pm.m[1][2] * t[2];\n  //---\n  float det = pm.m[0][0] * v[0] + pm.m[0][1] * v[4] + pm.m[0][2] * v[8] + pm.m[0][3] * v[12];\n  if (det == 0.0f) {\n    for (int j = 0; j < 4; j++)\n      for (int i = 0; i < 4; i++) {\n        pout.m[j, i] = 0.0;\n      }\n    //---\n    return;\n  }\n  if (pdeterminant) pdeterminant = det;\n  //---\n  t[0] = pm.m[2][2] * pm.m[3][3] - pm.m[2][3] * pm.m[3][2];\n  t[1] = pm.m[0][2] * pm.m[3][3] - pm.m[0][3] * pm.m[3][2];\n  t[2] = pm.m[0][2] * pm.m[2][3] - pm.m[0][3] * pm.m[2][2];\n  v[1] = -pm.m[0][1] * t[0] + pm.m[2][1] * t[1] - pm.m[3][1] * t[2];\n  v[5] = pm.m[0][0] * t[0] - pm.m[2][0] * t[1] + pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[0][0] * pm.m[2][1] - pm.m[2][0] * pm.m[0][1];\n  t[1] = pm.m[3][0] * pm.m[0][1] - pm.m[0][0] * pm.m[3][1];\n  t[2] = pm.m[2][0] * pm.m[3][1] - pm.m[3][0] * pm.m[2][1];\n  v[9] = -pm.m[3][3] * t[0] - pm.m[2][3] * t[1] - pm.m[0][3] * t[2];\n  v[13] = pm.m[3][2] * t[0] + pm.m[2][2] * t[1] + pm.m[0][2] * t[2];\n  //---\n  t[0] = pm.m[1][2] * pm.m[3][3] - pm.m[1][3] * pm.m[3][2];\n  t[1] = pm.m[0][2] * pm.m[3][3] - pm.m[0][3] * pm.m[3][2];\n  t[2] = pm.m[0][2] * pm.m[1][3] - pm.m[0][3] * pm.m[1][2];\n  v[2] = pm.m[0][1] * t[0] - pm.m[1][1] * t[1] + pm.m[3][1] * t[2];\n  v[6] = -pm.m[0][0] * t[0] + pm.m[1][0] * t[1] - pm.m[3][0] * t[2];\n  //---\n  t[0] = pm.m[0][0] * pm.m[1][1] - pm.m[1][0] * pm.m[0][1];\n  t[1] = pm.m[3][0] * pm.m[0][1] - pm.m[0][0] * pm.m[3][1];\n  t[2] = pm.m[1][0] * pm.m[3][1] - pm.m[3][0] * pm.m[1][1];\n  v[10] = pm.m[3][3] * t[0] + pm.m[1][3] * t[1] + pm.m[0][3] * t[2];\n  v[14] = -pm.m[3][2] * t[0] - pm.m[1][2] * t[1] - pm.m[0][2] * t[2];\n  //---\n  t[0] = pm.m[1][2] * pm.m[2][3] - pm.m[1][3] * pm.m[2][2];\n  t[1] = pm.m[0][2] * pm.m[2][3] - pm.m[0][3] * pm.m[2][2];\n  t[2] = pm.m[0][2] * pm.m[1][3] - pm.m[0][3] * pm.m[1][2];\n  v[3] = -pm.m[0][1] * t[0] + pm.m[1][1] * t[1] - pm.m[2][1] * t[2];\n  v[7] = pm.m[0][0] * t[0] - pm.m[1][0] * t[1] + pm.m[2][0] * t[2];\n  //---\n  v[11] = -pm.m[0][0] * (pm.m[1][1] * pm.m[2][3] - pm.m[1][3] * pm.m[2][1]) +\n          pm.m[1][0] * (pm.m[0][1] * pm.m[2][3] - pm.m[0][3] * pm.m[2][1]) -\n          pm.m[2][0] * (pm.m[0][1] * pm.m[1][3] - pm.m[0][3] * pm.m[1][1]);\n  //---\n  v[15] = pm.m[0][0] * (pm.m[1][1] * pm.m[2][2] - pm.m[1][2] * pm.m[2][1]) -\n          pm.m[1][0] * (pm.m[0][1] * pm.m[2][2] - pm.m[0][2] * pm.m[2][1]) +\n          pm.m[2][0] * (pm.m[0][1] * pm.m[1][2] - pm.m[0][2] * pm.m[1][1]);\n  //---\n  det = 1.0f / det;\n  for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++) pout.m[i][j] = v[4 * i + j] * det;\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed,look-at _matrix.                             |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//|                                                                  |\n//| zaxis = normal(At - Eye)                                         |\n//| xaxis = normal(cross(Up,zaxis))                                  |\n//| yaxis = cross(zaxis,xaxis)                                       |\n//|                                                                  |\n//| xaxis.x           yaxis.x           zaxis.x          0           |\n//| xaxis.y           yaxis.y           zaxis.y          0           |\n//| xaxis.z           yaxis.z           zaxis.z          0           |\n//| -dot(xaxis,eye)  -dot(yaxis,eye)  -dot(zaxis,eye)  1             |\n//+------------------------------------------------------------------+\nvoid DXMatrixLookAtLH(DXMatrix &out, const DXVector3 &eye, const DXVector3 &at, const DXVector3 &up) {\n  DXVector3 right, upn, vec;\n  DXVec3Subtract(vec, at, eye);\n  DXVec3Normalize(vec, vec);\n  DXVec3Cross(right, up, vec);\n  DXVec3Cross(upn, vec, right);\n  DXVec3Normalize(right, right);\n  DXVec3Normalize(upn, upn);\n  //---\n  out.m[0][0] = right.x;\n  out.m[1][0] = right.y;\n  out.m[2][0] = right.z;\n  out.m[3][0] = -DXVec3Dot(right, eye);\n  out.m[0][1] = upn.x;\n  out.m[1][1] = upn.y;\n  out.m[2][1] = upn.z;\n  out.m[3][1] = -DXVec3Dot(upn, eye);\n  out.m[0][2] = vec.x;\n  out.m[1][2] = vec.y;\n  out.m[2][2] = vec.z;\n  out.m[3][2] = -DXVec3Dot(vec, eye);\n  out.m[0][3] = 0.0f;\n  out.m[1][3] = 0.0f;\n  out.m[2][3] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed, look-at _matrix.                           |\n//+------------------------------------------------------------------+\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//|                                                                  |\n//| zaxis = normal(Eye - At)                                         |\n//| xaxis = normal(cross(Up,zaxis))                                  |\n//| yaxis = cross(zaxis,xaxis)                                       |\n//|                                                                  |\n//|  xaxis.x           yaxis.x           zaxis.x          0          |\n//|  xaxis.y           yaxis.y           zaxis.y          0          |\n//|  xaxis.z           yaxis.z           zaxis.z          0          |\n//|  dot(xaxis,eye)   dot(yaxis,eye)   dot(zaxis,eye)     1          |\n//+------------------------------------------------------------------+\nvoid DXMatrixLookAtRH(DXMatrix &out, const DXVector3 &eye, const DXVector3 &at, const DXVector3 &up) {\n  DXVector3 right, upn, vec;\n  DXVec3Subtract(vec, at, eye);\n  DXVec3Normalize(vec, vec);\n  DXVec3Cross(right, up, vec);\n  DXVec3Cross(upn, vec, right);\n  DXVec3Normalize(right, right);\n  DXVec3Normalize(upn, upn);\n  //---\n  out.m[0][0] = -right.x;\n  out.m[1][0] = -right.y;\n  out.m[2][0] = -right.z;\n  out.m[3][0] = DXVec3Dot(right, eye);\n  out.m[0][1] = upn.x;\n  out.m[1][1] = upn.y;\n  out.m[2][1] = upn.z;\n  out.m[3][1] = -DXVec3Dot(upn, eye);\n  out.m[0][2] = -vec.x;\n  out.m[1][2] = -vec.y;\n  out.m[2][2] = -vec.z;\n  out.m[3][2] = DXVec3Dot(vec, eye);\n  out.m[0][3] = 0.0f;\n  out.m[1][3] = 0.0f;\n  out.m[2][3] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Determines the product of two matrices.                          |\n//+------------------------------------------------------------------+\nvoid DXMatrixMultiply(DXMatrix &pout, const DXMatrix &pm1, const DXMatrix &pm2) {\n  DXMatrix out = {};\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 4; j++) {\n      out.m[i][j] =\n          pm1.m[i][0] * pm2.m[0][j] + pm1.m[i][1] * pm2.m[1][j] + pm1.m[i][2] * pm2.m[2][j] + pm1.m[i][3] * pm2.m[3][j];\n    }\n  }\n  pout = out;\n}\n//+------------------------------------------------------------------+\n//| Calculates the transposed product of two matrices.               |\n//+------------------------------------------------------------------+\nvoid DXMatrixMultiplyTranspose(DXMatrix &pout, const DXMatrix &pm1, const DXMatrix &pm2) {\n  DXMatrix temp = {};\n  for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++)\n      temp.m[j][i] =\n          pm1.m[i][0] * pm2.m[0][j] + pm1.m[i][1] * pm2.m[1][j] + pm1.m[i][2] * pm2.m[2][j] + pm1.m[i][3] * pm2.m[3][j];\n  pout = temp;\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed orthographic projection _matrix.             |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoLH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f / w;\n  pout.m[1][1] = 2.0f / h;\n  pout.m[2][2] = 1.0f / (zf - zn);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a customized,left-handed orthographic projection _matrix.  |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoOffCenterLH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f / (r - l);\n  pout.m[1][1] = 2.0f / (t - b);\n  pout.m[2][2] = 1.0f / (zf - zn);\n  pout.m[3][0] = -1.0f - 2.0f * l / (r - l);\n  pout.m[3][1] = 1.0f + 2.0f * t / (b - t);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a customized,right-handed orthographic projection _matrix. |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoOffCenterRH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f / (r - l);\n  pout.m[1][1] = 2.0f / (t - b);\n  pout.m[2][2] = 1.0f / (zn - zf);\n  pout.m[3][0] = -1.0f - 2.0f * l / (r - l);\n  pout.m[3][1] = 1.0f + 2.0f * t / (b - t);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed orthographic projection _matrix.            |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixOrthoRH function               |\n//| are distances in camera space. The parameters describe           |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix:                                             |\n//| 2/w  0    0           0                                          |\n//| 0    2/h  0           0                                          |\n//| 0    0    1/(zn-zf)   0                                          |\n//| 0    0    zn/(zn-zf)  1                                          |\n//+------------------------------------------------------------------+\nvoid DXMatrixOrthoRH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  pout.m[0][0] = 2.0f / w;\n  pout.m[1][1] = 2.0f / h;\n  pout.m[2][2] = 1.0f / (zn - zf);\n  pout.m[3][2] = zn / (zn - zf);\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed perspective projection _matrix               |\n//| based on a field of view.                                        |\n//+------------------------------------------------------------------+\n//| This function computes the returned _matrix as shown:             |\n//| xScale     0          0               0                          |\n//| 0        yScale       0               0                          |\n//| 0          0       zf/(zf-zn)         1                          |\n//| 0          0       -zn*zf/(zf-zn)     0                          |\n//| where:                                                           |\n//| yScale = cot(fovY/2)                                             |\n//| xScale = yScale / aspect ratio                                   |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveFovLH(DXMatrix &pout, float fovy, float aspect, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f / (aspect * (float)tan(fovy / 2.0f));\n  pout.m[1][1] = 1.0f / (float)tan(fovy / 2.0f);\n  pout.m[2][2] = zf / (zf - zn);\n  pout.m[2][3] = 1.0f;\n  pout.m[3][2] = (zf * zn) / (zn - zf);\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed perspective projection _matrix              |\n//| based on a field of view.                                        |\n//+------------------------------------------------------------------+\n//| This function computes the returned _matrix as shown.             |\n//| xScale     0          0              0                           |\n//| 0        yScale       0              0                           |\n//| 0        0        zf/(zn-zf)        -1                           |\n//| 0        0        zn*zf/(zn-zf)      0                           |\n//| where:                                                           |\n//| yScale = cot(fovY/2)                                             |\n//| xScale = yScale / aspect ratio                                   |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveFovRH(DXMatrix &pout, float fovy, float aspect, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f / (aspect * (float)tan(fovy / 2.0f));\n  pout.m[1][1] = 1.0f / (float)tan(fovy / 2.0f);\n  pout.m[2][2] = zf / (zn - zf);\n  pout.m[2][3] = -1.0f;\n  pout.m[3][2] = (zf * zn) / (zn - zf);\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a left-handed perspective projection _matrix               |\n//+------------------------------------------------------------------+\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/w  0       0              0                                 |\n//| 0       2*zn/h  0              0                                 |\n//| 0       0       zf/(zf-zn)     1                                 |\n//| 0       0       zn*zf/(zn-zf)  0                                 |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveLH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  pout.m[0][0] = 2.0f * zn / w;\n  pout.m[1][1] = 2.0f * zn / h;\n  pout.m[2][2] = zf / (zf - zn);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = 1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a customized, left-handed perspective projection _matrix.  |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixPerspectiveOffCenterLH         |\n//| function are distances in camera space. The parameters describe  |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/(r-l)   0            0              0                       |\n//| 0            2*zn/(t-b)   0              0                       |\n//| (l+r)/(l-r)  (t+b)/(b-t)  zf/(zf-zn)     1                       |\n//| 0            0            zn*zf/(zn-zf)  0                       |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveOffCenterLH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f * zn / (r - l);\n  pout.m[1][1] = -2.0f * zn / (b - t);\n  pout.m[2][0] = -1.0f - 2.0f * l / (r - l);\n  pout.m[2][1] = 1.0f + 2.0f * t / (b - t);\n  pout.m[2][2] = -zf / (zn - zf);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = 1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a customized, right-handed perspective projection _matrix. |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixPerspectiveOffCenterRH         |\n//| function are distances in camera space. The parameters describe  |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/(r-l)   0            0                0                     |\n//| 0            2*zn/(t-b)   0                0                     |\n//| (l+r)/(r-l)  (t+b)/(t-b)  zf/(zn-zf)      -1                     |\n//| 0            0            zn*zf/(zn-zf)    0                     |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveOffCenterRH(DXMatrix &pout, float l, float r, float b, float t, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f * zn / (r - l);\n  pout.m[1][1] = -2.0f * zn / (b - t);\n  pout.m[2][0] = 1.0f + 2.0f * l / (r - l);\n  pout.m[2][1] = -1.0f - 2.0f * t / (b - t);\n  pout.m[2][2] = zf / (zn - zf);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = -1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a right-handed perspective projection _matrix.             |\n//+------------------------------------------------------------------+\n//| All the parameters of the DXMatrixPerspectiveRH function         |\n//| are distances in camera space. The parameters describe           |\n//| the dimensions of the view volume.                               |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| 2*zn/w  0       0              0                                 |\n//| 0       2*zn/h  0              0                                 |\n//| 0       0       zf/(zn-zf)    -1                                 |\n//| 0       0       zn*zf/(zn-zf)  0                                 |\n//+------------------------------------------------------------------+\nvoid DXMatrixPerspectiveRH(DXMatrix &pout, float w, float h, float zn, float zf) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 2.0f * zn / w;\n  pout.m[1][1] = 2.0f * zn / h;\n  pout.m[2][2] = zf / (zn - zf);\n  pout.m[3][2] = (zn * zf) / (zn - zf);\n  pout.m[2][3] = -1.0f;\n  pout.m[3][3] = 0.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that reflects the coordinate system about a plane|\n//| This function normalizes the plane equation before it creates    |\n//| the reflected _matrix.                                            |\n//|                                                                  |\n//| This function uses the following formula to compute              |\n//| the returned _matrix.                                             |\n//| P = normalize(Plane);                                            |\n//| -2 * P.a * P.a + 1  -2 * P.b * P.a      -2 * P.c * P.a        0  |\n//| -2 * P.a * P.b      -2 * P.b * P.b + 1  -2 * P.c * P.b        0  |\n//| -2 * P.a * P.c      -2 * P.b * P.c      -2 * P.c * P.c + 1    0  |\n//| -2 * P.a * P.d      -2 * P.b * P.d      -2 * P.c * P.d        1  |\n//+------------------------------------------------------------------+\nvoid DXMatrixReflect(DXMatrix &pout, const DXPlane &pplane) {\n  DXPlane Nplane;\n  DXPlaneNormalize(Nplane, pplane);\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f - 2.0f * Nplane.a * Nplane.a;\n  pout.m[0][1] = -2.0f * Nplane.a * Nplane.b;\n  pout.m[0][2] = -2.0f * Nplane.a * Nplane.c;\n  pout.m[1][0] = -2.0f * Nplane.a * Nplane.b;\n  pout.m[1][1] = 1.0f - 2.0f * Nplane.b * Nplane.b;\n  pout.m[1][2] = -2.0f * Nplane.b * Nplane.c;\n  pout.m[2][0] = -2.0f * Nplane.c * Nplane.a;\n  pout.m[2][1] = -2.0f * Nplane.c * Nplane.b;\n  pout.m[2][2] = 1.0f - 2.0f * Nplane.c * Nplane.c;\n  pout.m[3][0] = -2.0f * Nplane.d * Nplane.a;\n  pout.m[3][1] = -2.0f * Nplane.d * Nplane.b;\n  pout.m[3][2] = -2.0f * Nplane.d * Nplane.c;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around an arbitrary axis.           |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationAxis(DXMatrix &out, const DXVector3 &v, float angle) {\n  DXVector3 nv;\n  DXVec3Normalize(nv, v);\n  //---\n  float sangle = (float)sin(angle);\n  float cangle = (float)cos(angle);\n  float cdiff = 1.0f - cangle;\n  //---\n  out.m[0][0] = cdiff * nv.x * nv.x + cangle;\n  out.m[1][0] = cdiff * nv.x * nv.y - sangle * nv.z;\n  out.m[2][0] = cdiff * nv.x * nv.z + sangle * nv.y;\n  out.m[3][0] = 0.0f;\n  out.m[0][1] = cdiff * nv.y * nv.x + sangle * nv.z;\n  out.m[1][1] = cdiff * nv.y * nv.y + cangle;\n  out.m[2][1] = cdiff * nv.y * nv.z - sangle * nv.x;\n  out.m[3][1] = 0.0f;\n  out.m[0][2] = cdiff * nv.z * nv.x - sangle * nv.y;\n  out.m[1][2] = cdiff * nv.z * nv.y + sangle * nv.x;\n  out.m[2][2] = cdiff * nv.z * nv.z + cangle;\n  out.m[3][2] = 0.0f;\n  out.m[0][3] = 0.0f;\n  out.m[1][3] = 0.0f;\n  out.m[2][3] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a rotation _matrix from a quaternion.                      |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationQuaternion(DXMatrix &pout, const DXQuaternion &pq) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = 1.0f - 2.0f * (pq.y * pq.y + pq.z * pq.z);\n  pout.m[0][1] = 2.0f * (pq.x * pq.y + pq.z * pq.w);\n  pout.m[0][2] = 2.0f * (pq.x * pq.z - pq.y * pq.w);\n  pout.m[1][0] = 2.0f * (pq.x * pq.y - pq.z * pq.w);\n  pout.m[1][1] = 1.0f - 2.0f * (pq.x * pq.x + pq.z * pq.z);\n  pout.m[1][2] = 2.0f * (pq.y * pq.z + pq.x * pq.w);\n  pout.m[2][0] = 2.0f * (pq.x * pq.z + pq.y * pq.w);\n  pout.m[2][1] = 2.0f * (pq.y * pq.z - pq.x * pq.w);\n  pout.m[2][2] = 1.0f - 2.0f * (pq.x * pq.x + pq.y * pq.y);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around the x-axis.                  |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationX(DXMatrix &pout, float angle) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[1][1] = (float)cos(angle);\n  pout.m[2][2] = (float)cos(angle);\n  pout.m[1][2] = (float)sin(angle);\n  pout.m[2][1] = -(float)sin(angle);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around the y-axis.                  |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationY(DXMatrix &pout, float angle) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = (float)cos(angle);\n  pout.m[2][2] = (float)cos(angle);\n  pout.m[0][2] = -(float)sin(angle);\n  pout.m[2][0] = (float)sin(angle);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix with a specified yaw, pitch, and roll.           |\n//+------------------------------------------------------------------+\n//| The order of transformations is roll first, then pitch, then yaw.|\n//| Relative to the object's local coordinate axis, this is          |\n//| equivalent to rotation around the z-axis, followed by rotation   |\n//| around the x-axis, followed by rotation around the y-axis.       |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationYawPitchRoll(DXMatrix &out, float yaw, float pitch, float roll) {\n  float sroll = (float)sin(roll);\n  float croll = (float)cos(roll);\n  float spitch = (float)sin(pitch);\n  float cpitch = (float)cos(pitch);\n  float syaw = (float)sin(yaw);\n  float cyaw = (float)cos(yaw);\n  //---\n  out.m[0][0] = sroll * spitch * syaw + croll * cyaw;\n  out.m[0][1] = sroll * cpitch;\n  out.m[0][2] = sroll * spitch * cyaw - croll * syaw;\n  out.m[0][3] = 0.0f;\n  out.m[1][0] = croll * spitch * syaw - sroll * cyaw;\n  out.m[1][1] = croll * cpitch;\n  out.m[1][2] = croll * spitch * cyaw + sroll * syaw;\n  out.m[1][3] = 0.0f;\n  out.m[2][0] = cpitch * syaw;\n  out.m[2][1] = -spitch;\n  out.m[2][2] = cpitch * cyaw;\n  out.m[2][3] = 0.0f;\n  out.m[3][0] = 0.0f;\n  out.m[3][1] = 0.0f;\n  out.m[3][2] = 0.0f;\n  out.m[3][3] = 1.0f;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that rotates around the z-axis.                  |\n//+------------------------------------------------------------------+\nvoid DXMatrixRotationZ(DXMatrix &pout, float angle) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[0][0] = (float)cos(angle);\n  pout.m[1][1] = (float)cos(angle);\n  pout.m[0][1] = (float)sin(angle);\n  pout.m[1][0] = -(float)sin(angle);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that scales along the x-axis,                    |\n//| the y-axis,and the z-axis.                                       |\n//+------------------------------------------------------------------+\nvoid DXMatrixScaling(DXMatrix &pout, float sx, float sy, float sz) {\n  DXMatrixIdentity(pout);\n  pout.m[0][0] = sx;\n  pout.m[1][1] = sy;\n  pout.m[2][2] = sz;\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix that flattens geometry into a plane.             |\n//+------------------------------------------------------------------+\n//| The DXMatrixShadow function flattens geometry into a plane, as   |\n//| if casting a shadow from a light.                                |\n//| This function uses the following formula to compute the returned |\n//| _matrix.                                                          |\n//|                                                                  |\n//| P = normalize(Plane);                                            |\n//| L = Light;                                                       |\n//| d = -dot(P,L)                                                    |\n//|                                                                  |\n//| P.a * L.x + d  P.a * L.y      P.a * L.z      P.a * L.w           |\n//| P.b * L.x      P.b * L.y + d  P.b * L.z      P.b * L.w           |\n//| P.c * L.x      P.c * L.y      P.c * L.z + d  P.c * L.w           |\n//| P.d * L.x      P.d * L.y      P.d * L.z      P.d * L.w + d       |\n//|                                                                  |\n//| If the light's w-component is 0, the ray from the origin to the  |\n//| light represents a directional light. If it is 1,the light is    |\n//| a point light.                                                   |\n//+------------------------------------------------------------------+\nvoid DXMatrixShadow(DXMatrix &pout, const DXVector4 &plight, const DXPlane &pplane) {\n  DXPlane Nplane;\n  DXPlaneNormalize(Nplane, pplane);\n  float dot = DXPlaneDot(Nplane, plight);\n  //---\n  pout.m[0][0] = dot - Nplane.a * plight.x;\n  pout.m[0][1] = -Nplane.a * plight.y;\n  pout.m[0][2] = -Nplane.a * plight.z;\n  pout.m[0][3] = -Nplane.a * plight.w;\n  pout.m[1][0] = -Nplane.b * plight.x;\n  pout.m[1][1] = dot - Nplane.b * plight.y;\n  pout.m[1][2] = -Nplane.b * plight.z;\n  pout.m[1][3] = -Nplane.b * plight.w;\n  pout.m[2][0] = -Nplane.c * plight.x;\n  pout.m[2][1] = -Nplane.c * plight.y;\n  pout.m[2][2] = dot - Nplane.c * plight.z;\n  pout.m[2][3] = -Nplane.c * plight.w;\n  pout.m[3][0] = -Nplane.d * plight.x;\n  pout.m[3][1] = -Nplane.d * plight.y;\n  pout.m[3][2] = -Nplane.d * plight.z;\n  pout.m[3][3] = dot - Nplane.d * plight.w;\n}\n//+------------------------------------------------------------------+\n//| Builds a transformation _matrix.                                  |\n//+------------------------------------------------------------------+\n//| This function calculates the transformation _matrix with the      |\n//| following formula, with _matrix concatenation evaluated           |\n//| in left-to-right order:                                          |\n//|                                                                  |\n//| Mout = (Msc)^(-1)*(Msr)^(-1)*Ms*Msr*Msc*(Mrc)^(-1)*Mr*Mrc*Mt     |\n//|                                                                  |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Msc = scaling center _matrix (pScalingCenter)                     |\n//| Msr = scaling rotation _matrix (pScalingRotation)                 |\n//| Ms = scaling _matrix (pScaling)                                   |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (pRotation)                                 |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixTransformation(DXMatrix &pout, const DXVector3 &pscalingcenter, const DXQuaternion &pscalingrotation,\n                            const DXVector3 &pscaling, const DXVector3 &protationcenter, const DXQuaternion &protation,\n                            const DXVector3 &ptranslation) {\n  DXMatrix m1, m2, m3, m4, m5, m6, m7;\n  DXQuaternion prc;\n  DXVector3 psc, pt;\n  //--- pscalingcenter\n  psc.x = pscalingcenter.x;\n  psc.y = pscalingcenter.y;\n  psc.z = pscalingcenter.z;\n  //--- protationcenter\n  prc.x = protationcenter.x;\n  prc.y = protationcenter.y;\n  prc.z = protationcenter.z;\n  //--- ptranslation\n  pt.x = ptranslation.x;\n  pt.y = ptranslation.y;\n  pt.z = ptranslation.z;\n  DXMatrixTranslation(m1, -psc.x, -psc.y, -psc.z);\n  //---\n  DXQuaternion temp;\n  DXMatrixRotationQuaternion(m4, pscalingrotation);\n  temp.w = pscalingrotation.w;\n  temp.x = -pscalingrotation.x;\n  temp.y = -pscalingrotation.y;\n  temp.z = -pscalingrotation.z;\n  DXMatrixRotationQuaternion(m2, temp);\n  //--- pscaling\n  DXMatrixScaling(m3, pscaling.x, pscaling.y, pscaling.z);\n  //--- protation\n  DXMatrixRotationQuaternion(m6, protation);\n  //---\n  DXMatrixTranslation(m5, psc.x - prc.x, psc.y - prc.y, psc.z - prc.z);\n  DXMatrixTranslation(m7, prc.x + pt.x, prc.y + pt.y, prc.z + pt.z);\n  DXMatrixMultiply(m1, m1, m2);\n  DXMatrixMultiply(m1, m1, m3);\n  DXMatrixMultiply(m1, m1, m4);\n  DXMatrixMultiply(m1, m1, m5);\n  DXMatrixMultiply(m1, m1, m6);\n  DXMatrixMultiply(pout, m1, m7);\n}\n//+------------------------------------------------------------------+\n//| Builds a 2D transformation _matrix that represents                |\n//| transformations in the xy plane.                                 |\n//+------------------------------------------------------------------+\n//| This function calculates the transformation _matrix with the      |\n//| following formula, with _matrix concatenation evaluated           |\n//| in left-to-right order:                                          |\n//|                                                                  |\n//| Mout = (Msc)^(-1)*(Msr)^(-1)*Ms*Msr*Msc*(Mrc)^(-1)*Mr*Mrc*Mt     |\n//|                                                                  |\n//| where:                                                           |\n//| Mout = output _matrix (pOut)                                      |\n//| Msc = scaling center _matrix (pScalingCenter)                     |\n//| Msr = scaling rotation _matrix (pScalingRotation)                 |\n//| Ms = scaling _matrix (pScaling)                                   |\n//| Mrc = center of rotation _matrix (pRotationCenter)                |\n//| Mr = rotation _matrix (Rotation)                                  |\n//| Mt = translation _matrix (pTranslation)                           |\n//+------------------------------------------------------------------+\nvoid DXMatrixTransformation2D(DXMatrix &pout, const DXVector2 &pscalingcenter, float scalingrotation,\n                              const DXVector2 &pscaling, const DXVector2 &protationcenter, float rotation,\n                              const DXVector2 &ptranslation) {\n  DXQuaternion rot, sca_rot;\n  DXVector3 rot_center, sca, sca_center, trans;\n  //--- pscalingcenter\n  sca_center.x = pscalingcenter.x;\n  sca_center.y = pscalingcenter.y;\n  sca_center.z = 0.0f;\n  //--- pscaling\n  sca.x = pscaling.x;\n  sca.y = pscaling.y;\n  sca.z = 1.0f;\n  //--- protationcenter\n  rot_center.x = protationcenter.x;\n  rot_center.y = protationcenter.y;\n  rot_center.z = 0.0f;\n  //--- ptranslation\n  trans.x = ptranslation.x;\n  trans.y = ptranslation.y;\n  trans.z = 0.0f;\n  //---\n  rot.w = (float)cos(rotation / 2.0f);\n  rot.x = 0.0f;\n  rot.y = 0.0f;\n  rot.z = (float)sin(rotation / 2.0f);\n  //---\n  sca_rot.w = (float)cos(scalingrotation / 2.0f);\n  sca_rot.x = 0.0f;\n  sca_rot.y = 0.0f;\n  sca_rot.z = (float)sin(scalingrotation / 2.0f);\n  DXMatrixTransformation(pout, sca_center, sca_rot, sca, rot_center, rot, trans);\n}\n//+------------------------------------------------------------------+\n//| Builds a _matrix using the specified offsets.                     |\n//+------------------------------------------------------------------+\nvoid DXMatrixTranslation(DXMatrix &pout, float x, float y, float z) {\n  DXMatrixIdentity(pout);\n  //---\n  pout.m[3][0] = x;\n  pout.m[3][1] = y;\n  pout.m[3][2] = z;\n}\n//+------------------------------------------------------------------+\n//| Returns the _matrix transpose of a _matrix.                        |\n//+------------------------------------------------------------------+\nvoid DXMatrixTranspose(DXMatrix &pout, const DXMatrix &pm) {\n  const DXMatrix m = pm;\n  for (int i = 0; i < 4; i++)\n    for (int j = 0; j < 4; j++) pout.m[i][j] = m.m[j][i];\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of a plane and a 4D vector.             |\n//+------------------------------------------------------------------+\nfloat DXPlaneDot(const DXPlane &p1, const DXVector4 &p2) {\n  return (p1.a * p2.x + p1.b * p2.y + p1.c * p2.z + p1.d * p2.w);\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of a plane and a 3D vector.             |\n//| The w parameter of the vector is assumed to be 1.                |\n//+------------------------------------------------------------------+\nfloat DXPlaneDotCoord(const DXPlane &pp, const DXVector4 &pv) {\n  return (pp.a * pv.x + pp.b * pv.y + pp.c * pv.z + pp.d);\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of a plane and a 3D vector.             |\n//| The w parameter of the vector is assumed to be 0.                |\n//+------------------------------------------------------------------+\nfloat DXPlaneDotNormal(const DXPlane &pp, const DXVector4 &pv) { return (pp.a * pv.x + pp.b * pv.y + pp.c * pv.z); }\n//+------------------------------------------------------------------+\n//| Constructs a plane from a point and a normal.                    |\n//+------------------------------------------------------------------+\nvoid DXPlaneFromPointNormal(DXPlane &pout, const DXVector3 &pvpoint, const DXVector3 &pvnormal) {\n  pout.a = pvnormal.x;\n  pout.b = pvnormal.y;\n  pout.c = pvnormal.z;\n  pout.d = -DXVec3Dot(pvpoint, pvnormal);\n}\n//+------------------------------------------------------------------+\n//| Constructs a plane from three points.                            |\n//+------------------------------------------------------------------+\nvoid DXPlaneFromPoints(DXPlane &pout, const DXVector3 &pv1, const DXVector3 &pv2, const DXVector3 &pv3) {\n  DXVector3 edge1, edge2, normal, Nnormal;\n  //---\n  edge1.x = 0.0f;\n  edge1.y = 0.0f;\n  edge1.z = 0.0f;\n  edge2.x = 0.0f;\n  edge2.y = 0.0f;\n  edge2.z = 0.0f;\n  //---\n  DXVec3Subtract(edge1, pv2, pv1);\n  DXVec3Subtract(edge2, pv3, pv1);\n  DXVec3Cross(normal, edge1, edge2);\n  DXVec3Normalize(Nnormal, normal);\n  DXPlaneFromPointNormal(pout, pv1, Nnormal);\n}\n//+------------------------------------------------------------------+\n//| Finds the intersection between a plane and a line.               |\n//| If the line is parallel to the plane, null vector is returned.   |\n//+------------------------------------------------------------------+\nvoid DXPlaneIntersectLine(DXVector3 &pout, const DXPlane &pp, const DXVector3 &pv1, const DXVector3 &pv2) {\n  DXVector3 direction, normal;\n  normal.x = pp.a;\n  normal.y = pp.b;\n  normal.z = pp.c;\n  direction.x = pv2.x - pv1.x;\n  direction.y = pv2.y - pv1.y;\n  direction.z = pv2.z - pv1.z;\n  //---\n  float dot = DXVec3Dot(normal, direction);\n  if (!dot) {\n    pout.x = 0.0f;\n    pout.y = 0.0f;\n    pout.z = 0.0f;\n  }\n  float temp = (pp.d + DXVec3Dot(normal, pv1)) / dot;\n  pout.x = pv1.x - temp * direction.x;\n  pout.y = pv1.y - temp * direction.y;\n  pout.z = pv1.z - temp * direction.z;\n}\n//+------------------------------------------------------------------+\n//| Normalizes the plane coefficients so that the plane normal       |\n//| has unit length.                                                 |\n//| This function normalizes a plane so that |a,b,c| == 1.           |\n//+------------------------------------------------------------------+\nvoid DXPlaneNormalize(DXPlane &out, const DXPlane &p) {\n  float norm = (float)sqrt(p.a * p.a + p.b * p.b + p.c * p.c);\n  if (norm) {\n    out.a = p.a / norm;\n    out.b = p.b / norm;\n    out.c = p.c / norm;\n    out.d = p.d / norm;\n  } else {\n    out.a = 0.0f;\n    out.b = 0.0f;\n    out.c = 0.0f;\n    out.d = 0.0f;\n  }\n}\n//+------------------------------------------------------------------+\n//| Scale the plane with the given scaling factor.                   |\n//+------------------------------------------------------------------+\nvoid DXPlaneScale(DXPlane &pout, const DXPlane &p, float s) {\n  pout.a = p.a * s;\n  pout.b = p.b * s;\n  pout.c = p.c * s;\n  pout.d = p.d * s;\n};\n//+------------------------------------------------------------------+\n//| Transforms a plane by a _matrix.                                  |\n//| The input _matrix is the inverse transpose of the actual          |\n//| transformation.                                                  |\n//+------------------------------------------------------------------+\nvoid DXPlaneTransform(DXPlane &pout, const DXPlane &pplane, const DXMatrix &pm) {\n  DXPlane plane = pplane;\n  //---\n  pout.a = pm.m[0][0] * plane.a + pm.m[1][0] * plane.b + pm.m[2][0] * plane.c + pm.m[3][0] * plane.d;\n  pout.b = pm.m[0][1] * plane.a + pm.m[1][1] * plane.b + pm.m[2][1] * plane.c + pm.m[3][1] * plane.d;\n  pout.c = pm.m[0][2] * plane.a + pm.m[1][2] * plane.b + pm.m[2][2] * plane.c + pm.m[3][2] * plane.d;\n  pout.d = pm.m[0][3] * plane.a + pm.m[1][3] * plane.b + pm.m[2][3] * plane.c + pm.m[3][3] * plane.d;\n}\n//+------------------------------------------------------------------+\n//| Adds two spherical harmonic (SH) vectors; in other words,        |\n//| out[i] = a[i] + b[i].                                            |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m) is stored          |\n//| at memory location l^2 + m + l,where:                            |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHAdd(float &out[], int order, const float &a[], const float &b[]) {\n  for (int i = 0; i < order * order; i++) out[i] = a[i] + b[i];\n}\n//+------------------------------------------------------------------+\n//| Computes the dot product of two spherical harmonic (SH) vectors. |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m) is stored          |\n//| at memory location l^2 + m + l,where:                            |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l,inclusive.                             |\n//+------------------------------------------------------------------+\nfloat DXSHDot(int order, const float &a[], const float &b[]) {\n  float s = a[0] * b[0];\n  for (int i = 1; i < order * order; i++) s += a[i] * b[i];\n  //---\n  return (s);\n}\n//+------------------------------------------------------------------+\n//| weightedcapintegrale                                             |\n//+------------------------------------------------------------------+\nvoid weightedcapintegrale(float &out[], unsigned int order, float angle) {\n  float coeff[3];\n  coeff[0] = (float)cos(angle);\n\n  out[0] = 2.0f * DX_PI * (1.0f - coeff[0]);\n  out[1] = DX_PI * (float)sin(angle) * (float)sin(angle);\n  if (order <= 2) return;\n\n  out[2] = coeff[0] * out[1];\n  if (order == 3) return;\n\n  coeff[1] = coeff[0] * coeff[0];\n  coeff[2] = coeff[1] * coeff[1];\n\n  out[3] = DX_PI * (-1.25f * coeff[2] + 1.5f * coeff[1] - 0.25f);\n  if (order == 4) return;\n\n  out[4] = -0.25f * DX_PI * coeff[0] * (7.0f * coeff[2] - 10.0f * coeff[1] + 3.0f);\n  if (order == 5) return;\n\n  out[5] = DX_PI * (-2.625f * coeff[2] * coeff[1] + 4.375f * coeff[2] - 1.875f * coeff[1] + 0.125f);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a light that is a cone of constant intensity           |\n//| and returns spectral spherical harmonic (SH) data.               |\n//+------------------------------------------------------------------+\n//| Evaluates a light that is a cone of constant intensity and       |\n//| returns spectral SH data.                                        |\n//| The output vector is computed so that if the intensity ratio     |\n//| R/G/B is equal to 1, the exit radiance of a point                |\n//| directly under the light (oriented in the cone direction         |\n//| on a diffuse object with an albedo of 1) would be 1.0.           |\n//| This will compute three spectral samples;                        |\n//| rout[], gout[] and bout[] will be computed.                      |\n//+------------------------------------------------------------------+\nint DXSHEvalConeLight(int order, const DXVector3 &dir, float radius, float Rintensity, float Gintensity,\n                      float Bintensity, float &rout[], float &gout[], float &bout[]) {\n  float cap[6];\n  //---\n  if (radius <= 0.0f)\n    return (DXSHEvalDirectionalLight(order, dir, Rintensity, Gintensity, Bintensity, rout, gout, bout));\n  //---\n  float clamped_angle = (radius > DX_PI / 2.0f) ? (DX_PI / 2.0f) : radius;\n  float norm = (float)sin(clamped_angle) * (float)sin(clamped_angle);\n  if (order > DXSH_MAXORDER) {\n    //--- order clamped at DXSH_MAXORDER\n    order = DXSH_MAXORDER;\n  }\n  //---\n  weightedcapintegrale(cap, order, radius);\n  DXSHEvalDirection(rout, order, dir);\n  //---\n  for (int i = 0; i < order; i++) {\n    float scale = cap[i] / norm;\n    for (int j = 0; j < 2 * i + 1; j++) {\n      int index = i * i + j;\n      float temp = rout[index] * scale;\n      rout[index] = temp * Rintensity;\n      gout[index] = temp * Gintensity;\n      bout[index] = temp * Bintensity;\n    }\n  }\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Evaluates the spherical harmonic (SH) basis functions            |\n//| from an input direction vector.                                  |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m) is stored          |\n//| at memory location l^2 + m + l, where:                           |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHEvalDirection(float &out[], int order, const DXVector3 &dir) {\n  const float dirxx = dir.x * dir.x;\n  const float dirxy = dir.x * dir.y;\n  const float dirxz = dir.x * dir.z;\n  const float diryy = dir.y * dir.y;\n  const float diryz = dir.y * dir.z;\n  const float dirzz = dir.z * dir.z;\n  const float dirxxxx = dirxx * dirxx;\n  const float diryyyy = diryy * diryy;\n  const float dirzzzz = dirzz * dirzz;\n  const float dirxyxy = dirxy * dirxy;\n  //---\n  if ((order < DXSH_MINORDER) || (order > DXSH_MAXORDER)) return;\n\n  out[0] = 0.5f / (float)sqrt(DX_PI);\n  out[1] = -0.5f / (float)sqrt(DX_PI / 3.0f) * dir.y;\n  out[2] = 0.5f / (float)sqrt(DX_PI / 3.0f) * dir.z;\n  out[3] = -0.5f / (float)sqrt(DX_PI / 3.0f) * dir.x;\n  if (order == 2) return;\n\n  out[4] = 0.5f / (float)sqrt(DX_PI / 15.0f) * dirxy;\n  out[5] = -0.5f / (float)sqrt(DX_PI / 15.0f) * diryz;\n  out[6] = 0.25f / (float)sqrt(DX_PI / 5.0f) * (3.0f * dirzz - 1.0f);\n  out[7] = -0.5f / (float)sqrt(DX_PI / 15.0f) * dirxz;\n  out[8] = 0.25f / (float)sqrt(DX_PI / 15.0f) * (dirxx - diryy);\n  if (order == 3) return;\n\n  out[9] = -(float)sqrt(70.0f / DX_PI) / 8.0f * dir.y * (3.0f * dirxx - diryy);\n  out[10] = (float)sqrt(105.0f / DX_PI) / 2.0f * dirxy * dir.z;\n  out[11] = -(float)sqrt(42.0f / DX_PI) / 8.0f * dir.y * (-1.0f + 5.0f * dirzz);\n  out[12] = (float)sqrt(7.0f / DX_PI) / 4.0f * dir.z * (5.0f * dirzz - 3.0f);\n  out[13] = (float)sqrt(42.0f / DX_PI) / 8.0f * dir.x * (1.0f - 5.0f * dirzz);\n  out[14] = (float)sqrt(105.0f / DX_PI) / 4.0f * dir.z * (dirxx - diryy);\n  out[15] = -(float)sqrt(70.0f / DX_PI) / 8.0f * dir.x * (dirxx - 3.0f * diryy);\n  if (order == 4) return;\n\n  out[16] = 0.75f * float(sqrt(35.0f / DX_PI)) * dirxy * (dirxx - diryy);\n  out[17] = 3.0f * dir.z * out[9];\n  out[18] = 0.75f * (float)sqrt(5.0f / DX_PI) * dirxy * (7.0f * dirzz - 1.0f);\n  out[19] = 0.375f * (float)sqrt(10.0f / DX_PI) * diryz * (3.0f - 7.0f * dirzz);\n  out[20] = 3.0f / (16.0f * (float)sqrt(DX_PI)) * (35.0f * dirzzzz - 30.f * dirzz + 3.0f);\n  out[21] = 0.375f * (float)sqrt(10.0f / DX_PI) * dirxz * (3.0f - 7.0f * dirzz);\n  out[22] = 0.375f * (float)sqrt(5.0f / DX_PI) * (dirxx - diryy) * (7.0f * dirzz - 1.0f);\n  out[23] = 3.0f * dir.z * out[15];\n  out[24] = 3.0f / 16.0f * float(sqrt(35.0f / DX_PI)) * (dirxxxx - 6.0f * dirxyxy + diryyyy);\n  if (order == 5) return;\n\n  out[25] = -3.0f / 32.0f * (float)sqrt(154.0f / DX_PI) * dir.y * (5.0f * dirxxxx - 10.0f * dirxyxy + diryyyy);\n  out[26] = 0.75f * (float)sqrt(385.0f / DX_PI) * dirxy * dir.z * (dirxx - diryy);\n  out[27] = (float)sqrt(770.0f / DX_PI) / 32.0f * dir.y * (3.0f * dirxx - diryy) * (1.0f - 9.0f * dirzz);\n  out[28] = (float)sqrt(1155.0f / DX_PI) / 4.0f * dirxy * dir.z * (3.0f * dirzz - 1.0f);\n  out[29] = (float)sqrt(165.0f / DX_PI) / 16.0f * dir.y * (14.0f * dirzz - 21.0f * dirzzzz - 1.0f);\n  out[30] = (float)sqrt(11.0f / DX_PI) / 16.0f * dir.z * (63.0f * dirzzzz - 70.0f * dirzz + 15.0f);\n  out[31] = (float)sqrt(165.0f / DX_PI) / 16.0f * dir.x * (14.0f * dirzz - 21.0f * dirzzzz - 1.0f);\n  out[32] = (float)sqrt(1155.0f / DX_PI) / 8.0f * dir.z * (dirxx - diryy) * (3.0f * dirzz - 1.0f);\n  out[33] = (float)sqrt(770.0f / DX_PI) / 32.0f * dir.x * (dirxx - 3.0f * diryy) * (1.0f - 9.0f * dirzz);\n  out[34] = 3.0f / 16.0f * (float)sqrt(385.0f / DX_PI) * dir.z * (dirxxxx - 6.0f * dirxyxy + diryyyy);\n  out[35] = -3.0f / 32.0f * (float)sqrt(154.0f / DX_PI) * dir.x * (dirxxxx - 10.0f * dirxyxy + 5.0f * diryyyy);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a directional light and                                |\n//| returns spectral spherical harmonic (SH) data.                   |\n//+------------------------------------------------------------------+\n//| The output vector is computed so that if the intensity ratio     |\n//| R/G/B is equal to 1 ,the resulting exit radiance of a point      |\n//| directly under the light on a diffuse object with an albedo      |\n//| of 1 would be 1.0. This will compute three spectral samples;     |\n//| rout[], gout[] and bout[] will be returned.                      |\n//+------------------------------------------------------------------+\nint DXSHEvalDirectionalLight(int order, const DXVector3 &dir, float Rintensity, float Gintensity, float Bintensity,\n                             float &rout[], float &gout[], float &bout[]) {\n  float s = 0.75f;\n  if (order > 2) s += 5.0f / 16.0f;\n  if (order > 4) s -= 3.0f / 32.0f;\n  s /= DX_PI;\n\n  DXSHEvalDirection(rout, order, dir);\n  for (int j = 0; j < order * order; j++) {\n    float temp = rout[j] / s;\n    rout[j] = Rintensity * temp;\n    gout[j] = Gintensity * temp;\n    bout[j] = Bintensity * temp;\n  }\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a light that is a linear interpolation                 |\n//| between two colors over the sphere.                              |\n//+------------------------------------------------------------------+\n//| The interpolation is done linearly between the two points,       |\n//| not over the surface of the sphere (that is, if the axis was     |\n//| (0,0,1) it is linear in Z, not in the azimuthal angle).          |\n//| The resulting spherical lighting function is normalized so that  |\n//| a point on a perfectly diffuse surface with no shadowing         |\n//| and a normal pointed in the direction pDir would result in exit  |\n//| radiance with a value of 1 (if the top color was white           |\n//| and the bottom color was black). This is a very simple model     |\n//| where Top represents the intensity of the \"sky\"                  |\n//| and Bottom represents the intensity of the \"ground\".             |\n//+------------------------------------------------------------------+\nint DXSHEvalHemisphereLight(int order, const DXVector3 &dir, DXColor &top, DXColor &bottom, float &rout[],\n                            float &gout[], float &bout[]) {\n  float a[2], temp[4];\n  DXSHEvalDirection(temp, 2, dir);\n  //--- rout\n  a[0] = (top.r + bottom.r) * 3.0f * DX_PI;\n  a[1] = (top.r - bottom.r) * DX_PI;\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++)\n      if (i < 2)\n        rout[i * i + j] = temp[i * i + j] * a[i];\n      else\n        rout[i * i + j] = 0.0f;\n  //--- gout\n  a[0] = (top.g + bottom.g) * 3.0f * DX_PI;\n  a[1] = (top.g - bottom.g) * DX_PI;\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++)\n      if (i < 2)\n        gout[i * i + j] = temp[i * i + j] * a[i];\n      else\n        gout[i * i + j] = 0.0f;\n  //--- bout\n  a[0] = (top.b + bottom.b) * 3.0f * DX_PI;\n  a[1] = (top.b - bottom.b) * DX_PI;\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++)\n      if (i < 2)\n        bout[i * i + j] = temp[i * i + j] * a[i];\n      else\n        bout[i * i + j] = 0.0f;\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Evaluates a spherical light and returns                          |\n//| spectral spherical harmonic (SH) data.                           |\n//+------------------------------------------------------------------+\n//| There is no normalization of the intensity of the light like     |\n//| there is for directional lights, so care has to be taken when    |\n//| specifying the intensities.                                      |\n//| This will compute three spectral samples;                        |\n//| rout[], gout[], bout[] will be returned.                         |\n//+------------------------------------------------------------------+\nint DXSHEvalSphericalLight(int order, const DXVector3 &dir, float radius, float Rintensity, float Gintensity,\n                           float Bintensity, float &rout[], float &gout[], float &bout[]) {\n  DXVector3 normal;\n  float cap[6];\n  //--- check order\n  if (order > DXSH_MAXORDER) order = DXSH_MAXORDER;\n  //--- check radius\n  if (radius < 0.0f) radius = -radius;\n\n  float dist = DXVec3Length(dir);\n  float clamped_angle = (dist <= radius) ? DX_PI / 2.0f : (float)asin(radius / dist);\n\n  weightedcapintegrale(cap, order, clamped_angle);\n  DXVec3Normalize(normal, dir);\n  DXSHEvalDirection(rout, order, normal);\n\n  for (int i = 0; i < order; i++)\n    for (int j = 0; j < 2 * i + 1; j++) {\n      int index = i * i + j;\n      float temp = rout[index] * cap[i];\n      rout[index] = temp * Rintensity;\n      gout[index] = temp * Gintensity;\n      bout[index] = temp * Bintensity;\n    }\n  //---\n  return (0);\n}\n//+------------------------------------------------------------------+\n//| Computes the product of two functions represented                |\n//| using Spherical Harmonics (f and g).                             |\n//+------------------------------------------------------------------+\n//| The order is a number between 2 and 6 inclusive.                 |\n//| So it's the same for the several functions:                      |\n//| DXSHMultiply2, DXSHMultiply3, ... DXSHMultiply6.                 |\n//|                                                                  |\n//| Computes the product of two functions represented                |\n//| using SH (f and g),where                                         |\n//|               out[i] = int(y_i(s) * f(s) * g(s)),                |\n//| where                                                            |\n//|       y_i(s) is the ith SH basis function,                       |\n//|       f(s) and g(s) are SH functions (sum_i(y_i(s)*c_i)).        |\n//| The order determines the lengths of the arrays, where there      |\n//| should always be l^2 coefficients.                               |\n//|                                                                  |\n//| In general the product of two SH functions of order l generates  |\n//| an SH function of order 2*l - 1, but the results are truncated.  |\n//|                                                                  |\n//| This means that the product commutes (f*g == g*f)                |\n//| but doesn't associate (f*(g*h) != (f*g)*h.                       |\n//+------------------------------------------------------------------+\nvoid DXSHMultiply2(float &out[], const float &a[], const float &b[]) {\n  float ta = 0.28209479f * a[0];\n  float tb = 0.28209479f * b[0];\n  out[0] = 0.28209479f * DXSHDot(2, a, b);\n  out[1] = ta * b[1] + tb * a[1];\n  out[2] = ta * b[2] + tb * a[2];\n  out[3] = ta * b[3] + tb * a[3];\n}\n//+------------------------------------------------------------------+\n//| Computes the product of two functions represented using          |\n//| Spherical Harmonics (f and g). Both functions are of order N=3.  |\n//+------------------------------------------------------------------+\n//| The order is a number between 2 and 6 inclusive.                 |\n//| So it's the same for the several functions:                      |\n//| DXSHMultiply2, DXSHMultiply3, ... DXSHMultiply6.                 |\n//|                                                                  |\n//| Computes the product of two functions represented                |\n//| using SH (f and g),where                                         |\n//|               out[i] = int(y_i(s) * f(s) * g(s)),                |\n//| where                                                            |\n//|       y_i(s) is the ith SH basis function,                       |\n//|       f(s) and g(s) are SH functions (sum_i(y_i(s)*c_i)).        |\n//| The order determines the lengths of the arrays,where there       |\n//| should always be l^2 coefficients.                               |\n//|                                                                  |\n//| In general the product of two SH functions of order l generates  |\n//| an SH function of order 2*l - 1, but the results are truncated.  |\n//|                                                                  |\n//| This means that the product commutes (f*g == g*f)                |\n//| but doesn't associate (f*(g*h) != (f*g)*h.                       |\n//+------------------------------------------------------------------+\nvoid DXSHMultiply3(float &out[], const float &a[], const float &b[]) {\n  out[0] = 0.28209479f * a[0] * b[0];\n  float ta = 0.28209479f * a[0] - 0.12615663f * a[6] - 0.21850969f * a[8];\n  float tb = 0.28209479f * b[0] - 0.12615663f * b[6] - 0.21850969f * b[8];\n  out[1] = ta * b[1] + tb * a[1];\n  float t = a[1] * b[1];\n  out[0] += 0.28209479f * t;\n  out[6] = -0.12615663f * t;\n  out[8] = -0.21850969f * t;\n\n  ta = 0.21850969f * a[5];\n  tb = 0.21850969f * b[5];\n  out[1] += ta * b[2] + tb * a[2];\n  out[2] = ta * b[1] + tb * a[1];\n  t = a[1] * b[2] + a[2] * b[1];\n  out[5] = 0.21850969f * t;\n\n  ta = 0.21850969f * a[4];\n  tb = 0.21850969f * b[4];\n  out[1] += ta * b[3] + tb * a[3];\n  out[3] = ta * b[1] + tb * a[1];\n  t = a[1] * b[3] + a[3] * b[1];\n  out[4] = 0.21850969f * t;\n\n  ta = 0.28209480f * a[0] + 0.25231326f * a[6];\n  tb = 0.28209480f * b[0] + 0.25231326f * b[6];\n  out[2] += ta * b[2] + tb * a[2];\n  t = a[2] * b[2];\n  out[0] += 0.28209480f * t;\n  out[6] += 0.25231326f * t;\n\n  ta = 0.21850969f * a[7];\n  tb = 0.21850969f * b[7];\n  out[2] += ta * b[3] + tb * a[3];\n  out[3] += ta * b[2] + tb * a[2];\n  t = a[2] * b[3] + a[3] * b[2];\n  out[7] = 0.21850969f * t;\n\n  ta = 0.28209479f * a[0] - 0.12615663f * a[6] + 0.21850969f * a[8];\n  tb = 0.28209479f * b[0] - 0.12615663f * b[6] + 0.21850969f * b[8];\n  out[3] += ta * b[3] + tb * a[3];\n  t = a[3] * b[3];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.12615663f * t;\n  out[8] += 0.21850969f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[4] += ta * b[4] + tb * a[4];\n  t = a[4] * b[4];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n\n  ta = 0.15607835f * a[7];\n  tb = 0.15607835f * b[7];\n  out[4] += ta * b[5] + tb * a[5];\n  out[5] += ta * b[4] + tb * a[4];\n  t = a[4] * b[5] + a[5] * b[4];\n  out[7] += 0.15607835f * t;\n\n  ta = 0.28209479f * a[0] + 0.09011188f * a[6] - 0.15607835f * a[8];\n  tb = 0.28209479f * b[0] + 0.09011188f * b[6] - 0.15607835f * b[8];\n  out[5] += ta * b[5] + tb * a[5];\n  t = a[5] * b[5];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.09011188f * t;\n  out[8] -= 0.15607835f * t;\n\n  ta = 0.28209480f * a[0];\n  tb = 0.28209480f * b[0];\n  out[6] += ta * b[6] + tb * a[6];\n  t = a[6] * b[6];\n  out[0] += 0.28209480f * t;\n  out[6] += 0.18022376f * t;\n\n  ta = 0.28209479f * a[0] + 0.09011188f * a[6] + 0.15607835f * a[8];\n  tb = 0.28209479f * b[0] + 0.09011188f * b[6] + 0.15607835f * b[8];\n  out[7] += ta * b[7] + tb * a[7];\n  t = a[7] * b[7];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.09011188f * t;\n  out[8] += 0.15607835f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[8] += ta * b[8] + tb * a[8];\n  t = a[8] * b[8];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n}\n//+------------------------------------------------------------------+\n//| Computes the product of two functions represented using          |\n//| Spherical Harmonics (f and g). Both functions are of order N=4.  |\n//+------------------------------------------------------------------+\n//| The order is a number between 2 and 6 inclusive.                 |\n//| So it's the same for the several functions:                      |\n//| DXSHMultiply2, DXSHMultiply3, ... DXSHMultiply6.                 |\n//|                                                                  |\n//| Computes the product of two functions represented                |\n//| using SH (f and g), where                                        |\n//|               out[i] = int(y_i(s) * f(s) * g(s)),                |\n//| where                                                            |\n//|       y_i(s) is the ith SH basis function,                       |\n//|       f(s) and g(s) are SH functions (sum_i(y_i(s)*c_i)).        |\n//| The order determines the lengths of the arrays,where there       |\n//| should always be l^2 coefficients.                               |\n//|                                                                  |\n//| In general the product of two SH functions of order l generates  |\n//| an SH function of order 2*l - 1, but the results are truncated.  |\n//|                                                                  |\n//| This means that the product commutes (f*g == g*f)                |\n//| but doesn't associate (f*(g*h) != (f*g)*h.                       |\n//+------------------------------------------------------------------+\nvoid DXSHMultiply4(float &out[], const float &a[], const float &b[]) {\n  out[0] = 0.28209479f * a[0] * b[0];\n  float ta = 0.28209479f * a[0] - 0.12615663f * a[6] - 0.21850969f * a[8];\n  float tb = 0.28209479f * b[0] - 0.12615663f * b[6] - 0.21850969f * b[8];\n  out[1] = ta * b[1] + tb * a[1];\n  float t = a[1] * b[1];\n  out[0] += 0.28209479f * t;\n  out[6] = -0.12615663f * t;\n  out[8] = -0.21850969f * t;\n\n  ta = 0.21850969f * a[3] - 0.05839917f * a[13] - 0.22617901f * a[15];\n  tb = 0.21850969f * b[3] - 0.05839917f * b[13] - 0.22617901f * b[15];\n  out[1] += ta * b[4] + tb * a[4];\n  out[4] = ta * b[1] + tb * a[1];\n  t = a[1] * b[4] + a[4] * b[1];\n  out[3] = 0.21850969f * t;\n  out[13] = -0.05839917f * t;\n  out[15] = -0.22617901f * t;\n\n  ta = 0.21850969f * a[2] - 0.14304817f * a[12] - 0.18467439f * a[14];\n  tb = 0.21850969f * b[2] - 0.14304817f * b[12] - 0.18467439f * b[14];\n  out[1] += ta * b[5] + tb * a[5];\n  out[5] = ta * b[1] + tb * a[1];\n  t = a[1] * b[5] + a[5] * b[1];\n  out[2] = 0.21850969f * t;\n  out[12] = -0.14304817f * t;\n  out[14] = -0.18467439f * t;\n\n  ta = 0.20230066f * a[11];\n  tb = 0.20230066f * b[11];\n  out[1] += ta * b[6] + tb * a[6];\n  out[6] += ta * b[1] + tb * a[1];\n  t = a[1] * b[6] + a[6] * b[1];\n  out[11] = 0.20230066f * t;\n\n  ta = 0.22617901f * a[9] + 0.05839917f * a[11];\n  tb = 0.22617901f * b[9] + 0.05839917f * b[11];\n  out[1] += ta * b[8] + tb * a[8];\n  out[8] += ta * b[1] + tb * a[1];\n  t = a[1] * b[8] + a[8] * b[1];\n  out[9] = 0.22617901f * t;\n  out[11] += 0.05839917f * t;\n\n  ta = 0.28209480f * a[0] + 0.25231326f * a[6];\n  tb = 0.28209480f * b[0] + 0.25231326f * b[6];\n  out[2] += ta * b[2] + tb * a[2];\n  t = a[2] * b[2];\n  out[0] += 0.28209480f * t;\n  out[6] += 0.25231326f * t;\n\n  ta = 0.24776671f * a[12];\n  tb = 0.24776671f * b[12];\n  out[2] += ta * b[6] + tb * a[6];\n  out[6] += ta * b[2] + tb * a[2];\n  t = a[2] * b[6] + a[6] * b[2];\n  out[12] += 0.24776671f * t;\n\n  ta = 0.28209480f * a[0] - 0.12615663f * a[6] + 0.21850969f * a[8];\n  tb = 0.28209480f * b[0] - 0.12615663f * b[6] + 0.21850969f * b[8];\n  out[3] += ta * b[3] + tb * a[3];\n  t = a[3] * b[3];\n  out[0] += 0.28209480f * t;\n  out[6] -= 0.12615663f * t;\n  out[8] += 0.21850969f * t;\n\n  ta = 0.20230066f * a[13];\n  tb = 0.20230066f * b[13];\n  out[3] += ta * b[6] + tb * a[6];\n  out[6] += ta * b[3] + tb * a[3];\n  t = a[3] * b[6] + a[6] * b[3];\n  out[13] += 0.20230066f * t;\n\n  ta = 0.21850969f * a[2] - 0.14304817f * a[12] + 0.18467439f * a[14];\n  tb = 0.21850969f * b[2] - 0.14304817f * b[12] + 0.18467439f * b[14];\n  out[3] += ta * b[7] + tb * a[7];\n  out[7] = ta * b[3] + tb * a[3];\n  t = a[3] * b[7] + a[7] * b[3];\n  out[2] += 0.21850969f * t;\n  out[12] -= 0.14304817f * t;\n  out[14] += 0.18467439f * t;\n\n  ta = -0.05839917f * a[13] + 0.22617901f * a[15];\n  tb = -0.05839917f * b[13] + 0.22617901f * b[15];\n  out[3] += ta * b[8] + tb * a[8];\n  out[8] += ta * b[3] + tb * a[3];\n  t = a[3] * b[8] + a[8] * b[3];\n  out[13] -= 0.05839917f * t;\n  out[15] += 0.22617901f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[4] += ta * b[4] + tb * a[4];\n  t = a[4] * b[4];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n\n  ta = 0.15607835f * a[7];\n  tb = 0.15607835f * b[7];\n  out[4] += ta * b[5] + tb * a[5];\n  out[5] += ta * b[4] + tb * a[4];\n  t = a[4] * b[5] + a[5] * b[4];\n  out[7] += 0.15607835f * t;\n\n  ta = 0.22617901f * a[3] - 0.09403160f * a[13];\n  tb = 0.22617901f * b[3] - 0.09403160f * b[13];\n  out[4] += ta * b[9] + tb * a[9];\n  out[9] += ta * b[4] + tb * a[4];\n  t = a[4] * b[9] + a[9] * b[4];\n  out[3] += 0.22617901f * t;\n  out[13] -= 0.09403160f * t;\n\n  ta = 0.18467439f * a[2] - 0.18806319f * a[12];\n  tb = 0.18467439f * b[2] - 0.18806319f * b[12];\n  out[4] += ta * b[10] + tb * a[10];\n  out[10] = ta * b[4] + tb * a[4];\n  t = a[4] * b[10] + a[10] * b[4];\n  out[2] += 0.18467439f * t;\n  out[12] -= 0.18806319f * t;\n\n  ta = -0.05839917f * a[3] + 0.14567312f * a[13] + 0.09403160f * a[15];\n  tb = -0.05839917f * b[3] + 0.14567312f * b[13] + 0.09403160f * b[15];\n  out[4] += ta * b[11] + tb * a[11];\n  out[11] += ta * b[4] + tb * a[4];\n  t = a[4] * b[11] + a[11] * b[4];\n  out[3] -= 0.05839917f * t;\n  out[13] += 0.14567312f * t;\n  out[15] += 0.09403160f * t;\n\n  ta = 0.28209479f * a[0] + 0.09011186f * a[6] - 0.15607835f * a[8];\n  tb = 0.28209479f * b[0] + 0.09011186f * b[6] - 0.15607835f * b[8];\n  out[5] += ta * b[5] + tb * a[5];\n  t = a[5] * b[5];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.09011186f * t;\n  out[8] -= 0.15607835f * t;\n\n  ta = 0.14867701f * a[14];\n  tb = 0.14867701f * b[14];\n  out[5] += ta * b[9] + tb * a[9];\n  out[9] += ta * b[5] + tb * a[5];\n  t = a[5] * b[9] + a[9] * b[5];\n  out[14] += 0.14867701f * t;\n\n  ta = 0.18467439f * a[3] + 0.11516472f * a[13] - 0.14867701f * a[15];\n  tb = 0.18467439f * b[3] + 0.11516472f * b[13] - 0.14867701f * b[15];\n  out[5] += ta * b[10] + tb * a[10];\n  out[10] += ta * b[5] + tb * a[5];\n  t = a[5] * b[10] + a[10] * b[5];\n  out[3] += 0.18467439f * t;\n  out[13] += 0.11516472f * t;\n  out[15] -= 0.14867701f * t;\n\n  ta = 0.23359668f * a[2] + 0.05947080f * a[12] - 0.11516472f * a[14];\n  tb = 0.23359668f * b[2] + 0.05947080f * b[12] - 0.11516472f * b[14];\n  out[5] += ta * b[11] + tb * a[11];\n  out[11] += ta * b[5] + tb * a[5];\n  t = a[5] * b[11] + a[11] * b[5];\n  out[2] += 0.23359668f * t;\n  out[12] += 0.05947080f * t;\n  out[14] -= 0.11516472f * t;\n\n  ta = 0.28209479f * a[0];\n  tb = 0.28209479f * b[0];\n  out[6] += ta * b[6] + tb * a[6];\n  t = a[6] * b[6];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.18022376f * t;\n\n  ta = 0.09011186f * a[6] + 0.28209479f * a[0] + 0.15607835f * a[8];\n  tb = 0.09011186f * b[6] + 0.28209479f * b[0] + 0.15607835f * b[8];\n  out[7] += ta * b[7] + tb * a[7];\n  t = a[7] * b[7];\n  out[6] += 0.09011186f * t;\n  out[0] += 0.28209479f * t;\n  out[8] += 0.15607835f * t;\n\n  ta = 0.14867701f * a[9] + 0.18467439f * a[1] + 0.11516472f * a[11];\n  tb = 0.14867701f * b[9] + 0.18467439f * b[1] + 0.11516472f * b[11];\n  out[7] += ta * b[10] + tb * a[10];\n  out[10] += ta * b[7] + tb * a[7];\n  t = a[7] * b[10] + a[10] * b[7];\n  out[9] += 0.14867701f * t;\n  out[1] += 0.18467439f * t;\n  out[11] += 0.11516472f * t;\n\n  ta = 0.05947080f * a[12] + 0.23359668f * a[2] + 0.11516472f * a[14];\n  tb = 0.05947080f * b[12] + 0.23359668f * b[2] + 0.11516472f * b[14];\n  out[7] += ta * b[13] + tb * a[13];\n  out[13] += ta * b[7] + tb * a[7];\n  t = a[7] * b[13] + a[13] * b[7];\n  out[12] += 0.05947080f * t;\n  out[2] += 0.23359668f * t;\n  out[14] += 0.11516472f * t;\n\n  ta = 0.14867701f * a[15];\n  tb = 0.14867701f * b[15];\n  out[7] += ta * b[14] + tb * a[14];\n  out[14] += ta * b[7] + tb * a[7];\n  t = a[7] * b[14] + a[14] * b[7];\n  out[15] += 0.14867701f * t;\n\n  ta = 0.28209479f * a[0] - 0.18022375f * a[6];\n  tb = 0.28209479f * b[0] - 0.18022375f * b[6];\n  out[8] += ta * b[8] + tb * a[8];\n  t = a[8] * b[8];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.18022375f * t;\n\n  ta = -0.09403160f * a[11];\n  tb = -0.09403160f * b[11];\n  out[8] += ta * b[9] + tb * a[9];\n  out[9] += ta * b[8] + tb * a[8];\n  t = a[8] * b[9] + a[9] * b[8];\n  out[11] -= 0.09403160f * t;\n\n  ta = -0.09403160f * a[15];\n  tb = -0.09403160f * b[15];\n  out[8] += ta * b[13] + tb * a[13];\n  out[13] += ta * b[8] + tb * a[8];\n  t = a[8] * b[13] + a[13] * b[8];\n  out[15] -= 0.09403160f * t;\n\n  ta = 0.18467439f * a[2] - 0.18806319f * a[12];\n  tb = 0.18467439f * b[2] - 0.18806319f * b[12];\n  out[8] += ta * b[14] + tb * a[14];\n  out[14] += ta * b[8] + tb * a[8];\n  t = a[8] * b[14] + a[14] * b[8];\n  out[2] += 0.18467439f * t;\n  out[12] -= 0.18806319f * t;\n\n  ta = -0.21026104f * a[6] + 0.28209479f * a[0];\n  tb = -0.21026104f * b[6] + 0.28209479f * b[0];\n  out[9] += ta * b[9] + tb * a[9];\n  t = a[9] * b[9];\n  out[6] -= 0.21026104f * t;\n  out[0] += 0.28209479f * t;\n\n  ta = 0.28209479f * a[0];\n  tb = 0.28209479f * b[0];\n  out[10] += ta * b[10] + tb * a[10];\n  t = a[10] * b[10];\n  out[0] += 0.28209479f * t;\n\n  ta = 0.28209479f * a[0] + 0.12615663f * a[6] - 0.14567312f * a[8];\n  tb = 0.28209479f * b[0] + 0.12615663f * b[6] - 0.14567312f * b[8];\n  out[11] += ta * b[11] + tb * a[11];\n  t = a[11] * b[11];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.12615663f * t;\n  out[8] -= 0.14567312f * t;\n\n  ta = 0.28209479f * a[0] + 0.16820885f * a[6];\n  tb = 0.28209479f * b[0] + 0.16820885f * b[6];\n  out[12] += ta * b[12] + tb * a[12];\n  t = a[12] * b[12];\n  out[0] += 0.28209479f * t;\n  out[6] += 0.16820885f * t;\n\n  ta = 0.28209479f * a[0] + 0.14567312f * a[8] + 0.12615663f * a[6];\n  tb = 0.28209479f * b[0] + 0.14567312f * b[8] + 0.12615663f * b[6];\n  out[13] += ta * b[13] + tb * a[13];\n  t = a[13] * b[13];\n  out[0] += 0.28209479f * t;\n  out[8] += 0.14567312f * t;\n  out[6] += 0.12615663f * t;\n\n  ta = 0.28209479f * a[0];\n  tb = 0.28209479f * b[0];\n  out[14] += ta * b[14] + tb * a[14];\n  t = a[14] * b[14];\n  out[0] += 0.28209479f * t;\n\n  ta = 0.28209479f * a[0] - 0.21026104f * a[6];\n  tb = 0.28209479f * b[0] - 0.21026104f * b[6];\n  out[15] += ta * b[15] + tb * a[15];\n  t = a[15] * b[15];\n  out[0] += 0.28209479f * t;\n  out[6] -= 0.21026104f * t;\n}\n//+------------------------------------------------------------------+\n//| rotate_X                                                         |\n//+------------------------------------------------------------------+\nvoid rotate_X(float &out[], unsigned int order, float a, float &in[]) {\n  out[0] = in[0];\n  out[1] = a * in[2];\n  out[2] = -a * in[1];\n  out[3] = in[3];\n  out[4] = a * in[7];\n  out[5] = -in[5];\n  out[6] = -0.5f * in[6] - 0.8660253882f * in[8];\n  out[7] = -a * in[4];\n  out[8] = -0.8660253882f * in[6] + 0.5f * in[8];\n  out[9] = -a * 0.7905694842f * in[12] + a * 0.6123724580f * in[14];\n  out[10] = -in[10];\n  out[11] = -a * 0.6123724580f * in[12] - a * 0.7905694842f * in[14];\n  out[12] = a * 0.7905694842f * in[9] + a * 0.6123724580f * in[11];\n  out[13] = -0.25f * in[13] - 0.9682458639f * in[15];\n  out[14] = -a * 0.6123724580f * in[9] + a * 0.7905694842f * in[11];\n  out[15] = -0.9682458639f * in[13] + 0.25f * in[15];\n  if (order == 4) return;\n\n  out[16] = -a * 0.9354143739f * in[21] + a * 0.3535533845f * in[23];\n  out[17] = -0.75f * in[17] + 0.6614378095f * in[19];\n  out[18] = -a * 0.3535533845f * in[21] - a * 0.9354143739f * in[23];\n  out[19] = 0.6614378095f * in[17] + 0.75f * in[19];\n  out[20] = 0.375f * in[20] + 0.5590170026f * in[22] + 0.7395099998f * in[24];\n  out[21] = a * 0.9354143739f * in[16] + a * 0.3535533845f * in[18];\n  out[22] = 0.5590170026f * in[20] + 0.5f * in[22] - 0.6614378691f * in[24];\n  out[23] = -a * 0.3535533845f * in[16] + a * 0.9354143739f * in[18];\n  out[24] = 0.7395099998f * in[20] - 0.6614378691f * in[22] + 0.125f * in[24];\n  if (order == 5) return;\n\n  out[25] = a * 0.7015607357f * in[30] - a * 0.6846531630f * in[32] + a * 0.1976423711f * in[34];\n  out[26] = -0.5f * in[26] + 0.8660253882f * in[28];\n  out[27] = a * 0.5229125023f * in[30] + a * 0.3061861992f * in[32] - a * 0.7954951525f * in[34];\n  out[28] = 0.8660253882f * in[26] + 0.5f * in[28];\n  out[29] = a * 0.4841229022f * in[30] + a * 0.6614378691f * in[32] + a * 0.5728219748f * in[34];\n  out[30] = -a * 0.7015607357f * in[25] - a * 0.5229125023f * in[27] - a * 0.4841229022f * in[29];\n  out[31] = 0.125f * in[31] + 0.4050463140f * in[33] + 0.9057110548f * in[35];\n  out[32] = a * 0.6846531630f * in[25] - a * 0.3061861992f * in[27] - a * 0.6614378691f * in[29];\n  out[33] = 0.4050463140f * in[31] + 0.8125f * in[33] - 0.4192627370f * in[35];\n  out[34] = -a * 0.1976423711f * in[25] + a * 0.7954951525f * in[27] - a * 0.5728219748f * in[29];\n  out[35] = 0.9057110548f * in[31] - 0.4192627370f * in[33] + 0.0624999329f * in[35];\n}\n//+------------------------------------------------------------------+\n//| Rotates the spherical harmonic (SH) vector by the given _matrix.  |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m)                    |\n//| is stored at memory location l^2 + m + l, where:                 |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHRotate(float &out[], int order, const DXMatrix &_matrix, const float &in[]) {\n  float alpha, beta, gamma, sinb, temp[36], temp1[36];\n  out[0] = in[0];\n\n  if ((order > DXSH_MAXORDER) || (order < DXSH_MINORDER)) return;\n\n  if (order <= 3) {\n    out[1] = _matrix.m[1][1] * in[1] - _matrix.m[2][1] * in[2] + _matrix.m[0][1] * in[3];\n    out[2] = -_matrix.m[1][2] * in[1] + _matrix.m[2][2] * in[2] - _matrix.m[0][2] * in[3];\n    out[3] = _matrix.m[1][0] * in[1] - _matrix.m[2][0] * in[2] + _matrix.m[0][0] * in[3];\n\n    if (order == 3) {\n      float coeff[12] = {};\n      coeff[0] = _matrix.m[1][0] * _matrix.m[0][0];\n      coeff[1] = _matrix.m[1][1] * _matrix.m[0][1];\n      coeff[2] = _matrix.m[1][1] * _matrix.m[2][1];\n      coeff[3] = _matrix.m[1][0] * _matrix.m[2][0];\n      coeff[4] = _matrix.m[2][0] * _matrix.m[2][0];\n      coeff[5] = _matrix.m[2][1] * _matrix.m[2][1];\n      coeff[6] = _matrix.m[0][0] * _matrix.m[2][0];\n      coeff[7] = _matrix.m[0][1] * _matrix.m[2][1];\n      coeff[8] = _matrix.m[0][1] * _matrix.m[0][1];\n      coeff[9] = _matrix.m[1][0] * _matrix.m[1][0];\n      coeff[10] = _matrix.m[1][1] * _matrix.m[1][1];\n      coeff[11] = _matrix.m[0][0] * _matrix.m[0][0];\n\n      out[4] = (_matrix.m[1][1] * _matrix.m[0][0] + _matrix.m[0][1] * _matrix.m[1][0]) * in[4];\n      out[4] -= (_matrix.m[1][0] * _matrix.m[2][1] + _matrix.m[1][1] * _matrix.m[2][0]) * in[5];\n      out[4] += 1.7320508076f * _matrix.m[2][0] * _matrix.m[2][1] * in[6];\n      out[4] -= (_matrix.m[0][1] * _matrix.m[2][0] + _matrix.m[0][0] * _matrix.m[2][1]) * in[7];\n      out[4] += (_matrix.m[0][0] * _matrix.m[0][1] - _matrix.m[1][0] * _matrix.m[1][1]) * in[8];\n\n      out[5] = (_matrix.m[1][1] * _matrix.m[2][2] + _matrix.m[1][2] * _matrix.m[2][1]) * in[5];\n      out[5] -= (_matrix.m[1][1] * _matrix.m[0][2] + _matrix.m[1][2] * _matrix.m[0][1]) * in[4];\n      out[5] -= 1.7320508076f * _matrix.m[2][2] * _matrix.m[2][1] * in[6];\n      out[5] += (_matrix.m[0][2] * _matrix.m[2][1] + _matrix.m[0][1] * _matrix.m[2][2]) * in[7];\n      out[5] -= (_matrix.m[0][1] * _matrix.m[0][2] - _matrix.m[1][1] * _matrix.m[1][2]) * in[8];\n\n      out[6] = (_matrix.m[2][2] * _matrix.m[2][2] - 0.5f * (coeff[4] + coeff[5])) * in[6];\n      out[6] -= (0.5773502692f * (coeff[0] + coeff[1]) - 1.1547005384f * _matrix.m[1][2] * _matrix.m[0][2]) * in[4];\n      out[6] += (0.5773502692f * (coeff[2] + coeff[3]) - 1.1547005384f * _matrix.m[1][2] * _matrix.m[2][2]) * in[5];\n      out[6] += (0.5773502692f * (coeff[6] + coeff[7]) - 1.1547005384f * _matrix.m[0][2] * _matrix.m[2][2]) * in[7];\n      out[6] += (0.2886751347f * (coeff[9] - coeff[8] + coeff[10] - coeff[11]) -\n                 0.5773502692f * (_matrix.m[1][2] * _matrix.m[1][2] - _matrix.m[0][2] * _matrix.m[0][2])) *\n                in[8];\n\n      out[7] = (_matrix.m[0][0] * _matrix.m[2][2] + _matrix.m[0][2] * _matrix.m[2][0]) * in[7];\n      out[7] -= (_matrix.m[1][0] * _matrix.m[0][2] + _matrix.m[1][2] * _matrix.m[0][0]) * in[4];\n      out[7] += (_matrix.m[1][0] * _matrix.m[2][2] + _matrix.m[1][2] * _matrix.m[2][0]) * in[5];\n      out[7] -= 1.7320508076f * _matrix.m[2][2] * _matrix.m[2][0] * in[6];\n      out[7] -= (_matrix.m[0][0] * _matrix.m[0][2] - _matrix.m[1][0] * _matrix.m[1][2]) * in[8];\n\n      out[8] = 0.5f * (coeff[11] - coeff[8] - coeff[9] + coeff[10]) * in[8];\n      out[8] += (coeff[0] - coeff[1]) * in[4];\n      out[8] += (coeff[2] - coeff[3]) * in[5];\n      out[8] += 0.86602540f * (coeff[4] - coeff[5]) * in[6];\n      out[8] += (coeff[7] - coeff[6]) * in[7];\n    }\n    return;\n  }\n\n#ifdef __MQL5__\n  if ((float)fabs(_matrix.m[2][2]) != 1.0f) {\n    sinb = (float)sqrt(1.0f - _matrix.m[2][2] * _matrix.m[2][2]);\n    alpha = (float)atan2(_matrix.m[2][1] / sinb, _matrix.m[2][0] / sinb);\n    beta = (float)atan2(sinb, _matrix.m[2][2]);\n    gamma = (float)atan2(_matrix.m[1][2] / sinb, -_matrix.m[0][2] / sinb);\n  } else {\n    alpha = (float)atan2(_matrix.m[0][1], _matrix.m[0][0]);\n    beta = 0.0f;\n    gamma = 0.0f;\n  }\n#else\n  alpha = 0.0f;\n  beta = 0.0f;\n  gamma = 0.0f;\n  sinb = 0.0f;\n#endif\n\n  //---\n  DXSHRotateZ(temp, order, gamma, in);\n  rotate_X(temp1, order, 1.0f, temp);\n  DXSHRotateZ(temp, order, beta, temp1);\n  rotate_X(temp1, order, -1.0f, temp);\n  DXSHRotateZ(out, order, alpha, temp1);\n}\n//+------------------------------------------------------------------+\n//| Rotates the spherical harmonic (SH) vector                       |\n//| in the z-axis by the given angle.                                |\n//+------------------------------------------------------------------+\n//| Each coefficient of the basis function Y(l,m)                    |\n//| is stored at memory location l^2 + m + l, where:                 |\n//| l is the degree of the basis function.                           |\n//| m is the basis function index for the given l value              |\n//|   and ranges from -l to l, inclusive.                            |\n//+------------------------------------------------------------------+\nvoid DXSHRotateZ(float &out[], int order, float angle, const float &in[]) {\n  int sum = 0;\n  float c[5], s[5];\n  order = (int)fmin(fmax(order, DXSH_MINORDER), DXSH_MAXORDER);\n  out[0] = in[0];\n  //---\n  for (int i = 1; i < order; i++) {\n    c[i - 1] = (float)cos(i * angle);\n    s[i - 1] = (float)sin(i * angle);\n    sum += i * 2;\n    //---\n    out[sum - i] = c[i - 1] * in[sum - i];\n    out[sum - i] += s[i - 1] * in[sum + i];\n    for (int j = i - 1; j > 0; j--) {\n      out[sum - j] = 0.0f;\n      out[sum - j] = c[j - 1] * in[sum - j];\n      out[sum - j] += s[j - 1] * in[sum + j];\n    }\n    out[sum] = in[sum];\n    //---\n    for (int j = 1; j < i; j++) {\n      out[sum + j] = 0.0f;\n      out[sum + j] = -s[j - 1] * in[sum - j];\n      out[sum + j] += c[j - 1] * in[sum + j];\n    }\n    out[sum + i] = -s[i - 1] * in[sum - i];\n    out[sum + i] += c[i - 1] * in[sum + i];\n  }\n}\n//+------------------------------------------------------------------+\n//| Scales a spherical harmonic (SH) vector;                         |\n//| in other words, out[i] = a[i]*scale.                             |\n//+------------------------------------------------------------------+\nvoid DXSHScale(float &out[], int order, const float &a[], const float scale) {\n  for (int i = 0; i < order * order; i++) out[i] = a[i] * scale;\n}\n//+---------------------------------------------------------------------+\n//| Interpolates y0 to y1 according to value from 0.0 to 1.0            |\n//+---------------------------------------------------------------------+\nfloat DXScalarLerp(const float val1, const float val2, float s) { return ((1 - s) * val1 + s * val2); }\n//+---------------------------------------------------------------------+\n//| Interpolates y0 to y1 according to value from 0.0 to 1.0            |\n//+---------------------------------------------------------------------+\nfloat DXScalarBiasScale(const float val, const float bias, const float scale) { return ((val + bias) * scale); }\n//+------------------------------------------------------------------+\n"}, {"filename": "Mesh.h", "path": "new_knowledge/EA31337-classes-master/3D/Mesh.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics mesh.\n */\n\n#include \"../Dict.mqh\"\n#include \"../Refs.mqh\"\n#include \"../Util.h\"\n#include \"Face.h\"\n#include \"IndexBuffer.h\"\n#include \"Material.h\"\n#include \"Math.h\"\n#include \"TSR.h\"\n#include \"VertexBuffer.h\"\n\nclass Device;\n\n#define GFX_MESH_LOOKUP_PRECISION 0.001f\n\n// Point with a key for faster vertices' lookup by their position.\ntemplate <typename T>\nstruct PointEntry {\n  T point;\n  long key;\n\n  PointEntry() {}\n\n  PointEntry(const T& _point) {\n    point = _point;\n    key = MakeKey(_point.Position.x, _point.Position.y, _point.Position.z);\n  }\n\n  bool operator==(const PointEntry<T>& _r) {\n    return key == MakeKey(_r.point.Position.x, _r.point.Position.y, _r.point.Position.z);\n  }\n\n  static long MakeKey(float x, float y, float z) {\n    return long(x / GFX_MESH_LOOKUP_PRECISION) + 4194304 * long(y / GFX_MESH_LOOKUP_PRECISION) +\n           17592186044416 * long(z / GFX_MESH_LOOKUP_PRECISION);\n  }\n};\n\n// Mesh points type.\nenum ENUM_MESH_TYPE { MESH_TYPE_CONNECTED_POINTS, MESH_TYPE_SEPARATE_POINTS };\n\ntemplate <typename T>\nclass Mesh : public Dynamic {\n  Ref<VertexBuffer> vbuff;\n  Ref<IndexBuffer> ibuff;\n  Ref<Shader> shader_ps;\n  Ref<Shader> shader_vs;\n  Face<T> faces[];\n  TSR tsr;\n  ENUM_MESH_TYPE type;\n  bool initialized;\n  Material material;\n\n public:\n  /**\n   * Constructor.\n   */\n  Mesh(ENUM_MESH_TYPE _type = MESH_TYPE_SEPARATE_POINTS) {\n    type = _type;\n    initialized = false;\n  }\n\n  /**\n   * Initializes graphics device-related things.\n   */\n  virtual void Initialize(Device* _device) {}\n\n  TSR* GetTSR() { return &tsr; }\n\n  void SetTSR(const TSR& _tsr) { tsr = _tsr; }\n\n  /**\n   * Adds a single 3 or 4-vertex face.\n   */\n  void AddFace(Face<T>& face) {\n    face.UpdateNormal();\n    Util::ArrayPush(faces, face, 16);\n  }\n\n  /**\n   * Returns material assigned to mesh.\n   */\n  Material* GetMaterial() { return &material; }\n\n  /**\n   * Assigns material to mesh.\n   */\n  void SetMaterial(Material& _material) { material = _material; }\n\n  /**\n   * Returns vertex shader for mesh rendering.\n   */\n  Shader* GetShaderVS() { return shader_vs.Ptr(); }\n\n  /**\n   * Sets pixel shader for mesh rendering.\n   */\n  void SetShaderVS(Shader* _shader_vs) { shader_vs = _shader_vs; }\n\n  /**\n   * Returns pixel shader for mesh rendering.\n   */\n  Shader* GetShaderPS() { return shader_ps.Ptr(); }\n\n  /**\n   * Sets pixel shader for mesh rendering.\n   */\n  void SetShaderPS(Shader* _shader_ps) { shader_ps = _shader_ps; }\n\n  /**\n   * Returns vertex and index buffers for this mesh.\n   *\n   * @todo Buffers should be invalidated if mesh has changed.\n   */\n  bool GetBuffers(Device* _device, VertexBuffer*& _vbuff, IndexBuffer*& _ibuff) {\n    if (!initialized) {\n      Initialize(_device);\n      initialized = true;\n    }\n\n#ifdef __debug__\n    Print(\"Getting buffers. Mesh type = \", EnumToString(type));\n#endif\n    if (vbuff.IsSet() && ibuff.IsSet()) {\n      _vbuff = vbuff.Ptr();\n      _ibuff = ibuff.Ptr();\n      return true;\n    }\n\n    DictStruct<int, PointEntry<T>> _points;\n    T _vertices[];\n    unsigned int _indices[];\n    int i, k;\n\n    for (i = 0; i < ArraySize(faces); ++i) {\n      Face<T> _face = faces[i];\n      int _face_indices[4];\n\n      // Adding first triangle.\n      for (k = 0; k < 3; ++k) {\n        PointEntry<T> _point1(_face.points[k]);\n        _face_indices[k] = type == MESH_TYPE_SEPARATE_POINTS ? -1 : _points.IndexOf(_point1);\n\n        if (_face_indices[k] == -1) {\n          // Point not yet added.\n          _points.Push(_point1);\n          _face_indices[k] = (int)_points.Size() - 1;\n        }\n\n        Util::ArrayPush(_indices, _face_indices[k]);\n      }\n\n      // Adding second triangle if needed.\n      if ((_face.flags & FACE_FLAGS_QUAD) == FACE_FLAGS_QUAD) {\n        if (type == MESH_TYPE_CONNECTED_POINTS) {\n          PointEntry<T> _point3(_face.points[3]);\n          _face_indices[3] = _points.IndexOf(_point3);\n\n          if (_face_indices[3] == -1) {\n            // Point not yet added.\n            _points.Push(_point3);\n            _face_indices[3] = (int)_points.Size() - 1;\n          }\n\n          Util::ArrayPush(_indices, _face_indices[0]);\n          Util::ArrayPush(_indices, _face_indices[2]);\n          Util::ArrayPush(_indices, _face_indices[3]);\n        } else {\n          int _i1 = ArraySize(_indices) + 0;\n          int _i2 = ArraySize(_indices) + 1;\n          int _i3 = ArraySize(_indices) + 2;\n\n          Util::ArrayPush(_indices, _i1);\n          Util::ArrayPush(_indices, _i2);\n          Util::ArrayPush(_indices, _i3);\n\n          PointEntry<T> _point0(_face.points[0]);\n          PointEntry<T> _point2(_face.points[2]);\n          PointEntry<T> _point3(_face.points[3]);\n\n          _points.Push(_point0);\n          _points.Push(_point2);\n          _points.Push(_point3);\n        }\n      }\n    }\n\n    ArrayResize(_vertices, _points.Size());\n\n    for (DictIteratorBase<int, PointEntry<T>> iter(_points.Begin()); iter.IsValid(); ++iter) {\n      _vertices[iter.Index()] = iter.Value().point;\n    }\n\n    string _s_vertices = \"[\";\n\n    for (i = 0; i < ArraySize(_vertices); ++i) {\n      _s_vertices += \"[\";\n      _s_vertices += \"  Pos = \" + DoubleToString(_vertices[i].Position.x) + \", \" +\n                     DoubleToString(_vertices[i].Position.y) + \",\" + DoubleToString(_vertices[i].Position.z) + \" | \";\n      _s_vertices += \"  Clr = \" + DoubleToString(_vertices[i].Color.r) + \", \" + DoubleToString(_vertices[i].Color.g) +\n                     \",\" + DoubleToString(_vertices[i].Color.b) + \",\" + DoubleToString(_vertices[i].Color.a);\n      _s_vertices += \"]\";\n      if (i != ArraySize(_vertices) - 1) {\n        _s_vertices += \", \";\n      }\n    }\n\n    _s_vertices += \"]\";\n\n    string _s_indices = \"[\";\n\n    for (i = 0; i < ArraySize(_indices); ++i) {\n      _s_indices += DoubleToString(_indices[i]);\n      if (i != ArraySize(_indices) - 1) {\n        _s_indices += \", \";\n      }\n    }\n\n    _s_indices += \"]\";\n\n#ifdef __debug__\n    Print(\"Vertices: \", _s_vertices);\n    Print(\"Indices: \", _s_indices);\n#endif\n\n    vbuff = _vbuff = _device.VertexBuffer<T>(_vertices);\n    ibuff = _ibuff = _device.IndexBuffer(_indices);\n    return true;\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * Generic graphics mesh.\n */\n\n#include \"../Dict.mqh\"\n#include \"../Refs.mqh\"\n#include \"../Util.h\"\n#include \"Face.h\"\n#include \"IndexBuffer.h\"\n#include \"Material.h\"\n#include \"Math.h\"\n#include \"TSR.h\"\n#include \"VertexBuffer.h\"\n\nclass Device;\n\n#define GFX_MESH_LOOKUP_PRECISION 0.001f\n\n// Point with a key for faster vertices' lookup by their position.\ntemplate <typename T>\nstruct PointEntry {\n  T point;\n  long key;\n\n  PointEntry() {}\n\n  PointEntry(const T& _point) {\n    point = _point;\n    key = MakeKey(_point.Position.x, _point.Position.y, _point.Position.z);\n  }\n\n  bool operator==(const PointEntry<T>& _r) {\n    return key == MakeKey(_r.point.Position.x, _r.point.Position.y, _r.point.Position.z);\n  }\n\n  static long MakeKey(float x, float y, float z) {\n    return long(x / GFX_MESH_LOOKUP_PRECISION) + 4194304 * long(y / GFX_MESH_LOOKUP_PRECISION) +\n           17592186044416 * long(z / GFX_MESH_LOOKUP_PRECISION);\n  }\n};\n\n// Mesh points type.\nenum ENUM_MESH_TYPE { MESH_TYPE_CONNECTED_POINTS, MESH_TYPE_SEPARATE_POINTS };\n\ntemplate <typename T>\nclass Mesh : public Dynamic {\n  Ref<VertexBuffer> vbuff;\n  Ref<IndexBuffer> ibuff;\n  Ref<Shader> shader_ps;\n  Ref<Shader> shader_vs;\n  Face<T> faces[];\n  TSR tsr;\n  ENUM_MESH_TYPE type;\n  bool initialized;\n  Material material;\n\n public:\n  /**\n   * Constructor.\n   */\n  Mesh(ENUM_MESH_TYPE _type = MESH_TYPE_SEPARATE_POINTS) {\n    type = _type;\n    initialized = false;\n  }\n\n  /**\n   * Initializes graphics device-related things.\n   */\n  virtual void Initialize(Device* _device) {}\n\n  TSR* GetTSR() { return &tsr; }\n\n  void SetTSR(const TSR& _tsr) { tsr = _tsr; }\n\n  /**\n   * Adds a single 3 or 4-vertex face.\n   */\n  void AddFace(Face<T>& face) {\n    face.UpdateNormal();\n    Util::ArrayPush(faces, face, 16);\n  }\n\n  /**\n   * Returns material assigned to mesh.\n   */\n  Material* GetMaterial() { return &material; }\n\n  /**\n   * Assigns material to mesh.\n   */\n  void SetMaterial(Material& _material) { material = _material; }\n\n  /**\n   * Returns vertex shader for mesh rendering.\n   */\n  Shader* GetShaderVS() { return shader_vs.Ptr(); }\n\n  /**\n   * Sets pixel shader for mesh rendering.\n   */\n  void SetShaderVS(Shader* _shader_vs) { shader_vs = _shader_vs; }\n\n  /**\n   * Returns pixel shader for mesh rendering.\n   */\n  Shader* GetShaderPS() { return shader_ps.Ptr(); }\n\n  /**\n   * Sets pixel shader for mesh rendering.\n   */\n  void SetShaderPS(Shader* _shader_ps) { shader_ps = _shader_ps; }\n\n  /**\n   * Returns vertex and index buffers for this mesh.\n   *\n   * @todo Buffers should be invalidated if mesh has changed.\n   */\n  bool GetBuffers(Device* _device, VertexBuffer*& _vbuff, IndexBuffer*& _ibuff) {\n    if (!initialized) {\n      Initialize(_device);\n      initialized = true;\n    }\n\n#ifdef __debug__\n    Print(\"Getting buffers. Mesh type = \", EnumToString(type));\n#endif\n    if (vbuff.IsSet() && ibuff.IsSet()) {\n      _vbuff = vbuff.Ptr();\n      _ibuff = ibuff.Ptr();\n      return true;\n    }\n\n    DictStruct<int, PointEntry<T>> _points;\n    T _vertices[];\n    unsigned int _indices[];\n    int i, k;\n\n    for (i = 0; i < ArraySize(faces); ++i) {\n      Face<T> _face = faces[i];\n      int _face_indices[4];\n\n      // Adding first triangle.\n      for (k = 0; k < 3; ++k) {\n        PointEntry<T> _point1(_face.points[k]);\n        _face_indices[k] = type == MESH_TYPE_SEPARATE_POINTS ? -1 : _points.IndexOf(_point1);\n\n        if (_face_indices[k] == -1) {\n          // Point not yet added.\n          _points.Push(_point1);\n          _face_indices[k] = (int)_points.Size() - 1;\n        }\n\n        Util::ArrayPush(_indices, _face_indices[k]);\n      }\n\n      // Adding second triangle if needed.\n      if ((_face.flags & FACE_FLAGS_QUAD) == FACE_FLAGS_QUAD) {\n        if (type == MESH_TYPE_CONNECTED_POINTS) {\n          PointEntry<T> _point3(_face.points[3]);\n          _face_indices[3] = _points.IndexOf(_point3);\n\n          if (_face_indices[3] == -1) {\n            // Point not yet added.\n            _points.Push(_point3);\n            _face_indices[3] = (int)_points.Size() - 1;\n          }\n\n          Util::ArrayPush(_indices, _face_indices[0]);\n          Util::ArrayPush(_indices, _face_indices[2]);\n          Util::ArrayPush(_indices, _face_indices[3]);\n        } else {\n          int _i1 = ArraySize(_indices) + 0;\n          int _i2 = ArraySize(_indices) + 1;\n          int _i3 = ArraySize(_indices) + 2;\n\n          Util::ArrayPush(_indices, _i1);\n          Util::ArrayPush(_indices, _i2);\n          Util::ArrayPush(_indices, _i3);\n\n          PointEntry<T> _point0(_face.points[0]);\n          PointEntry<T> _point2(_face.points[2]);\n          PointEntry<T> _point3(_face.points[3]);\n\n          _points.Push(_point0);\n          _points.Push(_point2);\n          _points.Push(_point3);\n        }\n      }\n    }\n\n    ArrayResize(_vertices, _points.Size());\n\n    for (DictIteratorBase<int, PointEntry<T>> iter(_points.Begin()); iter.IsValid(); ++iter) {\n      _vertices[iter.Index()] = iter.Value().point;\n    }\n\n    string _s_vertices = \"[\";\n\n    for (i = 0; i < ArraySize(_vertices); ++i) {\n      _s_vertices += \"[\";\n      _s_vertices += \"  Pos = \" + DoubleToString(_vertices[i].Position.x) + \", \" +\n                     DoubleToString(_vertices[i].Position.y) + \",\" + DoubleToString(_vertices[i].Position.z) + \" | \";\n      _s_vertices += \"  Clr = \" + DoubleToString(_vertices[i].Color.r) + \", \" + DoubleToString(_vertices[i].Color.g) +\n                     \",\" + DoubleToString(_vertices[i].Color.b) + \",\" + DoubleToString(_vertices[i].Color.a);\n      _s_vertices += \"]\";\n      if (i != ArraySize(_vertices) - 1) {\n        _s_vertices += \", \";\n      }\n    }\n\n    _s_vertices += \"]\";\n\n    string _s_indices = \"[\";\n\n    for (i = 0; i < ArraySize(_indices); ++i) {\n      _s_indices += DoubleToString(_indices[i]);\n      if (i != ArraySize(_indices) - 1) {\n        _s_indices += \", \";\n      }\n    }\n\n    _s_indices += \"]\";\n\n#ifdef __debug__\n    Print(\"Vertices: \", _s_vertices);\n    Print(\"Indices: \", _s_indices);\n#endif\n\n    vbuff = _vbuff = _device.VertexBuffer<T>(_vertices);\n    ibuff = _ibuff = _device.IndexBuffer(_indices);\n    return true;\n  }\n};\n"}, {"filename": "Chart3DCandles.h", "path": "new_knowledge/EA31337-classes-master/3D/Chart3DCandles.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart candles renderer.\n */\n\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Vertex.h\"\n\nclass Chart3D;\n\n/**\n * 3D chart candles renderer.\n */\nclass Chart3DCandles : public Chart3DType {\n  Ref<Cube<Vertex>> cube1;\n  Ref<Cube<Vertex>> cube2;\n  Ref<Cube<Vertex>> cube3;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DCandles(Chart3D* _chart3d, Device* _device) : Chart3DType(_chart3d, _device) {\n    cube1 = new Cube<Vertex>(1.0f, 1.0f, 1.0f);\n    cube2 = new Cube<Vertex>(0.10f, 1.0f, 0.10f);\n    cube3 = new Cube<Vertex>(1.0f, 0.075f, 0.075f);\n  }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {\n    TSR _tsr;\n\n    for (int _shift = chart3d.GetBarsVisibleShiftStart(); _shift != chart3d.GetBarsVisibleShiftEnd(); --_shift) {\n      BarOHLC _ohlc = chart3d.GetPrice(PERIOD_CURRENT, _shift);\n\n      float _height = chart3d.GetPriceScale(_ohlc.GetMaxOC()) - chart3d.GetPriceScale(_ohlc.GetMinOC());\n      float higher = _ohlc.IsBear();\n\n      cube1.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      cube1.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetMinOC()) + _height / 2;\n      cube1.Ptr().GetTSR().scale.y = _height;\n\n      // Print(cube1.Ptr().GetTSR().translation.y);\n\n      cube1.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube1.Ptr());\n\n      cube2.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      float _line_height = chart3d.GetPriceScale(_ohlc.GetHigh()) - chart3d.GetPriceScale(_ohlc.GetLow());\n      cube2.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetLow()) + _line_height / 2;\n      cube2.Ptr().GetTSR().scale.y = _line_height;\n      cube2.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube2.Ptr());\n    }\n\n    int _digits = (int)MarketInfo(Symbol(), MODE_DIGITS);\n    float _pip_pow = (float)MathPow(10, _digits);\n    float _pip_size = 1.0f / (float)MathPow(10, _digits);\n    float _pip_size_m1 = 1.0f / (float)MathPow(10, _digits - 1);\n    float _start = float(int(chart3d.GetMinBarsPrice() * _pip_pow) * _pip_size);\n    float _end = float(int(chart3d.GetMaxBarsPrice() * _pip_pow) * _pip_size);\n\n    // Rendering price lines.\n    for (double _s = _start; _s < _end + _pip_size_m1; _s += _pip_size * 10) {\n      float _y = chart3d.GetPriceScale((float)_s);\n\n      cube3.Ptr().GetTSR().translation.y = _y;\n      cube3.Ptr().GetTSR().scale.x = 200.0f;\n\n      _device.DrawText(5, _y, StringFormat(\"%.\" + IntegerToString(_digits) + \"f\", _s), 0x90FFFFFF, TA_LEFT | TA_VCENTER,\n                       GFX_DRAW_TEXT_FLAG_2D_COORD_X);\n\n      cube3.Ptr().GetMaterial().SetColor(0x333333);\n      _device.Render(cube3.Ptr());\n    }\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * 3D chart candles renderer.\n */\n\n#include \"Chart3DType.h\"\n#include \"Cube.h\"\n#include \"Device.h\"\n#include \"Vertex.h\"\n\nclass Chart3D;\n\n/**\n * 3D chart candles renderer.\n */\nclass Chart3DCandles : public Chart3DType {\n  Ref<Cube<Vertex>> cube1;\n  Ref<Cube<Vertex>> cube2;\n  Ref<Cube<Vertex>> cube3;\n\n public:\n  /**\n   * Constructor.\n   */\n  Chart3DCandles(Chart3D* _chart3d, Device* _device) : Chart3DType(_chart3d, _device) {\n    cube1 = new Cube<Vertex>(1.0f, 1.0f, 1.0f);\n    cube2 = new Cube<Vertex>(0.10f, 1.0f, 0.10f);\n    cube3 = new Cube<Vertex>(1.0f, 0.075f, 0.075f);\n  }\n\n  /**\n   * Renders chart.\n   */\n  virtual void Render(Device* _device) {\n    TSR _tsr;\n\n    for (int _shift = chart3d.GetBarsVisibleShiftStart(); _shift != chart3d.GetBarsVisibleShiftEnd(); --_shift) {\n      BarOHLC _ohlc = chart3d.GetPrice(PERIOD_CURRENT, _shift);\n\n      float _height = chart3d.GetPriceScale(_ohlc.GetMaxOC()) - chart3d.GetPriceScale(_ohlc.GetMinOC());\n      float higher = _ohlc.IsBear();\n\n      cube1.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      cube1.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetMinOC()) + _height / 2;\n      cube1.Ptr().GetTSR().scale.y = _height;\n\n      // Print(cube1.Ptr().GetTSR().translation.y);\n\n      cube1.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube1.Ptr());\n\n      cube2.Ptr().GetTSR().translation.x = chart3d.GetBarPositionX(_shift);\n      float _line_height = chart3d.GetPriceScale(_ohlc.GetHigh()) - chart3d.GetPriceScale(_ohlc.GetLow());\n      cube2.Ptr().GetTSR().translation.y = chart3d.GetPriceScale(_ohlc.GetLow()) + _line_height / 2;\n      cube2.Ptr().GetTSR().scale.y = _line_height;\n      cube2.Ptr().GetMaterial().SetColor(higher ? 0x22FF11 : 0xFF1122);\n      _device.Render(cube2.Ptr());\n    }\n\n    int _digits = (int)MarketInfo(Symbol(), MODE_DIGITS);\n    float _pip_pow = (float)MathPow(10, _digits);\n    float _pip_size = 1.0f / (float)MathPow(10, _digits);\n    float _pip_size_m1 = 1.0f / (float)MathPow(10, _digits - 1);\n    float _start = float(int(chart3d.GetMinBarsPrice() * _pip_pow) * _pip_size);\n    float _end = float(int(chart3d.GetMaxBarsPrice() * _pip_pow) * _pip_size);\n\n    // Rendering price lines.\n    for (double _s = _start; _s < _end + _pip_size_m1; _s += _pip_size * 10) {\n      float _y = chart3d.GetPriceScale((float)_s);\n\n      cube3.Ptr().GetTSR().translation.y = _y;\n      cube3.Ptr().GetTSR().scale.x = 200.0f;\n\n      _device.DrawText(5, _y, StringFormat(\"%.\" + IntegerToString(_digits) + \"f\", _s), 0x90FFFFFF, TA_LEFT | TA_VCENTER,\n                       GFX_DRAW_TEXT_FLAG_2D_COORD_X);\n\n      cube3.Ptr().GetMaterial().SetColor(0x333333);\n      _device.Render(cube3.Ptr());\n    }\n  }\n};\n"}, {"filename": "MT5Frontend.h", "path": "new_knowledge/EA31337-classes-master/3D/Frontends/MT5Frontend.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MT5 graphics front-end (display buffer target).\n */\n\n#include \"../Frontend.h\"\n\n/**\n * MetaTrader 5 chart target.\n */\nclass MT5Frontend : public Frontend {\n  // Target image pixel buffer.\n  unsigned int image[];\n\n  // Previous size of the window.\n  int last_width, last_height;\n\n  // Target image's resource name.\n  string resname;\n\n  // Target image's object name.\n  string objname;\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() {\n    // Hiding 2D chart.\n    ChartSetInteger(0, CHART_SHOW, false);\n    ChartRedraw();\n\n#ifdef __debug__\n    Print(\"MT5 Frontend: LastError: \", GetLastError());\n#endif\n\n    objname = \"MT5_Frontend_\" + IntegerToString(ChartID());\n    resname = \"::MT5_Frontend\" + IntegerToString(ChartID());\n    ObjectCreate(0, objname, OBJ_BITMAP_LABEL, 0, 0, 0);\n    ObjectSetInteger(0, objname, OBJPROP_XDISTANCE, 0);\n    ObjectSetInteger(0, objname, OBJPROP_YDISTANCE, 0);\n#ifdef __debug__\n    Print(\"MT5 Frontend: ObjectCreate/Set: LastError: \", GetLastError());\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n#endif\n    ObjectSetString(ChartID(), objname, OBJPROP_BMPFILE, resname);\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() {\n    ResourceFree(resname);\n    ObjectDelete(0, objname);\n    ChartSetInteger(0, CHART_SHOW, true);\n    ChartRedraw();\n    return true;\n  }\n\n  /**\n   * Resizes target image buffer if needed.\n   */\n  bool Resize() {\n    if (Width() == last_width && Height() == last_height) {\n      return false;\n    }\n\n    ArrayResize(image, Width() * Height());\n#ifdef __debug__\n    Print(\"resname = \", resname, \", image_size = \", ArraySize(image), \", width = \", Width(), \", height = \", Height());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n\n    last_width = Width();\n    last_height = Height();\n\n    return true;\n  }\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderBegin()\");\n    Print(\"Image resize: width = \", Width(), \", height = \", Height());\n#endif\n\n    if (Resize()) {\n      DXContextSetSize(context, Width(), Height());\n    }\n\n#ifdef __debug__\n    Print(\"DXContextSetSize: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderEnd()\");\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n    Print(\"MT5Frontend: DXContextGetColors()\");\n#endif\n    DXContextGetColors(context, image);\n    ProcessDrawText();\n#ifdef __debug__\n    Print(\"DXContextGetColors: LastError: \", GetLastError());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n    ChartRedraw();\n    Sleep(1);\n  }\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() { return (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS); }\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() { return (int)ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS); }\n\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    TextSetFont(\"Arial\", -80, FW_EXTRABOLD, 0);\n#ifdef __debug__\n    Print(\"TextSetFont: LastError = \", GetLastError());\n#endif\n\n    TextOut(_text, _x, _y, _align, image, Width(), Height(), _color, COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"TextOut: LastError = \", GetLastError());\n#endif\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MT5 graphics front-end (display buffer target).\n */\n\n#include \"../Frontend.h\"\n\n/**\n * MetaTrader 5 chart target.\n */\nclass MT5Frontend : public Frontend {\n  // Target image pixel buffer.\n  unsigned int image[];\n\n  // Previous size of the window.\n  int last_width, last_height;\n\n  // Target image's resource name.\n  string resname;\n\n  // Target image's object name.\n  string objname;\n\n public:\n  /**\n   * Initializes canvas.\n   */\n  virtual bool Init() {\n    // Hiding 2D chart.\n    ChartSetInteger(0, CHART_SHOW, false);\n    ChartRedraw();\n\n#ifdef __debug__\n    Print(\"MT5 Frontend: LastError: \", GetLastError());\n#endif\n\n    objname = \"MT5_Frontend_\" + IntegerToString(ChartID());\n    resname = \"::MT5_Frontend\" + IntegerToString(ChartID());\n    ObjectCreate(0, objname, OBJ_BITMAP_LABEL, 0, 0, 0);\n    ObjectSetInteger(0, objname, OBJPROP_XDISTANCE, 0);\n    ObjectSetInteger(0, objname, OBJPROP_YDISTANCE, 0);\n#ifdef __debug__\n    Print(\"MT5 Frontend: ObjectCreate/Set: LastError: \", GetLastError());\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n#endif\n    ObjectSetString(ChartID(), objname, OBJPROP_BMPFILE, resname);\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  /**\n   * Deinitializes canvas.\n   */\n  virtual bool Deinit() {\n    ResourceFree(resname);\n    ObjectDelete(0, objname);\n    ChartSetInteger(0, CHART_SHOW, true);\n    ChartRedraw();\n    return true;\n  }\n\n  /**\n   * Resizes target image buffer if needed.\n   */\n  bool Resize() {\n    if (Width() == last_width && Height() == last_height) {\n      return false;\n    }\n\n    ArrayResize(image, Width() * Height());\n#ifdef __debug__\n    Print(\"resname = \", resname, \", image_size = \", ArraySize(image), \", width = \", Width(), \", height = \", Height());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n\n    last_width = Width();\n    last_height = Height();\n\n    return true;\n  }\n\n  /**\n   * Executed before render starts.\n   */\n  virtual void RenderBegin(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderBegin()\");\n    Print(\"Image resize: width = \", Width(), \", height = \", Height());\n#endif\n\n    if (Resize()) {\n      DXContextSetSize(context, Width(), Height());\n    }\n\n#ifdef __debug__\n    Print(\"DXContextSetSize: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Executed after render ends.\n   */\n  virtual void RenderEnd(int context) {\n#ifdef __debug__\n    Print(\"MT5Frontend: RenderEnd()\");\n    Print(\"ResourceCreate: width = \", Width(), \", height = \", Height());\n    Print(\"MT5Frontend: DXContextGetColors()\");\n#endif\n    DXContextGetColors(context, image);\n    ProcessDrawText();\n#ifdef __debug__\n    Print(\"DXContextGetColors: LastError: \", GetLastError());\n#endif\n    ResourceCreate(resname, image, Width(), Height(), 0, 0, Width(), COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"ResourceCreate: LastError: \", GetLastError());\n#endif\n    ChartRedraw();\n    Sleep(1);\n  }\n\n  /**\n   * Returns canvas' width.\n   */\n  virtual int Width() { return (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS); }\n\n  /**\n   * Returns canvas' height.\n   */\n  virtual int Height() { return (int)ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS); }\n\n  /**\n   * Draws text directly into the pixel buffer. Should be executed after all 3d drawing.\n   */\n  virtual void DrawTextNow(int _x, int _y, string _text, unsigned int _color = 0xFFFFFFFF, unsigned int _align = 0) {\n    TextSetFont(\"Arial\", -80, FW_EXTRABOLD, 0);\n#ifdef __debug__\n    Print(\"TextSetFont: LastError = \", GetLastError());\n#endif\n\n    TextOut(_text, _x, _y, _align, image, Width(), Height(), _color, COLOR_FORMAT_ARGB_NORMALIZE);\n#ifdef __debug__\n    Print(\"TextOut: LastError = \", GetLastError());\n#endif\n  }\n};\n"}, {"filename": "MTDXDevice.h", "path": "new_knowledge/EA31337-classes-master/3D/Devices/MTDX/MTDXDevice.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device.\n */\n\n#include \"../../Device.h\"\n\nclass MTDXDevice : public Device {\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Init(Frontend* _frontend) {\n#ifdef __debug__\n    Print(\"MTDXDevice: DXContextCreate: width = \", _frontend.Width(), \", height = \", _frontend.Height());\n#endif\n    context = DXContextCreate(_frontend.Width(), _frontend.Height());\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n    Print(\"MTDXDevice: context = \", context);\n#endif\n    _frontend.Init();\n    return true;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  bool Deinit() {\n    DXRelease(context);\n    return true;\n  }\n\n  /**\n   * Starts rendering loop.\n   */\n  virtual bool RenderBegin() { return true; }\n\n  /**\n   * Ends rendering loop.\n   */\n  virtual bool RenderEnd() { return true; }\n\n  /**\n   * Returns DX context's id.\n   */\n  int Context() { return context; }\n\n  /**\n   * Clears color buffer.\n   */\n  /**\n   * Clears color buffer.\n   */\n  virtual void ClearBuffer(ENUM_CLEAR_BUFFER_TYPE _type, unsigned int _color = 0x000000) {\n    if (_type == CLEAR_BUFFER_TYPE_COLOR) {\n      DXVector _dx_color;\n      _dx_color.x = 1.0f / 255.0f * ((_color & 0x00FF0000) >> 16);\n      _dx_color.y = 1.0f / 255.0f * ((_color & 0x0000FF00) >> 8);\n      _dx_color.z = 1.0f / 255.0f * ((_color & 0x000000FF) >> 0);\n      _dx_color.w = 1.0f / 255.0f * ((_color & 0xFF000000) >> 24);\n      DXContextClearColors(context, _dx_color);\n#ifdef __debug__\n      Print(\"DXContextClearColors: LastError: \", GetLastError());\n#endif\n    } else if (_type == CLEAR_BUFFER_TYPE_DEPTH) {\n      DXContextClearDepth(context);\n#ifdef __debug__\n      Print(\"DXContextClearDepth: LastError: \", GetLastError());\n#endif\n    }\n  }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  IndexBuffer* IndexBuffer() { return NULL; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[], string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_VS, _source_code, _entry_point);\n    _shader.SetDataLayout(_layout);\n    return _shader;\n  }\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_PS, _source_code, _entry_point);\n    return _shader;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  VertexBuffer* VertexBuffer() { return new MTDXVertexBuffer(&this); }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) {\n    IndexBuffer* _buffer = new MTDXIndexBuffer(&this);\n    _buffer.Fill(_indices);\n    return _buffer;\n  }\n\n  /**\n   *\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) {\n    DXPrimiveTopologySet(context, DX_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    _vertices.Select();\n    if (_indices == NULL) {\n      if (!DXDraw(context)) {\n#ifdef __debug__\n        Print(\"Can't draw!\");\n#endif\n      }\n#ifdef __debug__\n      Print(\"DXDraw: LastError: \", GetLastError());\n#endif\n    } else {\n      _indices.Select();\n      DXDrawIndexed(context);\n#ifdef __debug__\n      Print(\"DXDrawIndexed: LastError: \", GetLastError());\n#endif\n    }\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device.\n */\n\n#include \"../../Device.h\"\n\nclass MTDXDevice : public Device {\n public:\n  /**\n   * Initializes graphics device.\n   */\n  bool Init(Frontend* _frontend) {\n#ifdef __debug__\n    Print(\"MTDXDevice: DXContextCreate: width = \", _frontend.Width(), \", height = \", _frontend.Height());\n#endif\n    context = DXContextCreate(_frontend.Width(), _frontend.Height());\n#ifdef __debug__\n    Print(\"LastError: \", GetLastError());\n    Print(\"MTDXDevice: context = \", context);\n#endif\n    _frontend.Init();\n    return true;\n  }\n\n  /**\n   * Deinitializes graphics device.\n   */\n  bool Deinit() {\n    DXRelease(context);\n    return true;\n  }\n\n  /**\n   * Starts rendering loop.\n   */\n  virtual bool RenderBegin() { return true; }\n\n  /**\n   * Ends rendering loop.\n   */\n  virtual bool RenderEnd() { return true; }\n\n  /**\n   * Returns DX context's id.\n   */\n  int Context() { return context; }\n\n  /**\n   * Clears color buffer.\n   */\n  /**\n   * Clears color buffer.\n   */\n  virtual void ClearBuffer(ENUM_CLEAR_BUFFER_TYPE _type, unsigned int _color = 0x000000) {\n    if (_type == CLEAR_BUFFER_TYPE_COLOR) {\n      DXVector _dx_color;\n      _dx_color.x = 1.0f / 255.0f * ((_color & 0x00FF0000) >> 16);\n      _dx_color.y = 1.0f / 255.0f * ((_color & 0x0000FF00) >> 8);\n      _dx_color.z = 1.0f / 255.0f * ((_color & 0x000000FF) >> 0);\n      _dx_color.w = 1.0f / 255.0f * ((_color & 0xFF000000) >> 24);\n      DXContextClearColors(context, _dx_color);\n#ifdef __debug__\n      Print(\"DXContextClearColors: LastError: \", GetLastError());\n#endif\n    } else if (_type == CLEAR_BUFFER_TYPE_DEPTH) {\n      DXContextClearDepth(context);\n#ifdef __debug__\n      Print(\"DXContextClearDepth: LastError: \", GetLastError());\n#endif\n    }\n  }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  IndexBuffer* IndexBuffer() { return NULL; }\n\n  /**\n   * Creates vertex shader to be used by current graphics device.\n   */\n  virtual Shader* VertexShader(string _source_code, const ShaderVertexLayout& _layout[], string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_VS, _source_code, _entry_point);\n    _shader.SetDataLayout(_layout);\n    return _shader;\n  }\n\n  /**\n   * Creates pixel shader to be used by current graphics device.\n   */\n  virtual Shader* PixelShader(string _source_code, string _entry_point = \"main\") {\n    MTDXShader* _shader = new MTDXShader(&this);\n    _shader.Create(SHADER_TYPE_PS, _source_code, _entry_point);\n    return _shader;\n  }\n\n  /**\n   * Creates vertex buffer to be used by current graphics device.\n   */\n  VertexBuffer* VertexBuffer() { return new MTDXVertexBuffer(&this); }\n\n  /**\n   * Creates index buffer to be used by current graphics device.\n   */\n  virtual IndexBuffer* IndexBuffer(unsigned int& _indices[]) {\n    IndexBuffer* _buffer = new MTDXIndexBuffer(&this);\n    _buffer.Fill(_indices);\n    return _buffer;\n  }\n\n  /**\n   *\n   */\n  virtual void RenderBuffers(VertexBuffer* _vertices, IndexBuffer* _indices = NULL) {\n    DXPrimiveTopologySet(context, DX_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    _vertices.Select();\n    if (_indices == NULL) {\n      if (!DXDraw(context)) {\n#ifdef __debug__\n        Print(\"Can't draw!\");\n#endif\n      }\n#ifdef __debug__\n      Print(\"DXDraw: LastError: \", GetLastError());\n#endif\n    } else {\n      _indices.Select();\n      DXDrawIndexed(context);\n#ifdef __debug__\n      Print(\"DXDrawIndexed: LastError: \", GetLastError());\n#endif\n    }\n  }\n};\n"}, {"filename": "MTDXIndexBuffer.h", "path": "new_knowledge/EA31337-classes-master/3D/Devices/MTDX/MTDXIndexBuffer.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device's index buffer.\n */\n\n#include \"../../IndexBuffer.h\"\n\nclass MTDXIndexBuffer : public IndexBuffer {\n public:\n  MTDXIndexBuffer(Device* _device) : IndexBuffer(_device) {}\n\n protected:\n  int handle;\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) {\n    // handle = DXBufferCreate(Device().Context(), DX_BUFFER_INDEX, &_data);\n    return handle != INVALID_HANDLE;\n  }\n\n  /**\n   * Destructor;\n   */\n  ~MTDXIndexBuffer() { DXRelease(handle); }\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_INDEX, _indices);\n  }\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting indices \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics device's index buffer.\n */\n\n#include \"../../IndexBuffer.h\"\n\nclass MTDXIndexBuffer : public IndexBuffer {\n public:\n  MTDXIndexBuffer(Device* _device) : IndexBuffer(_device) {}\n\n protected:\n  int handle;\n\n  /**\n   * Creates index buffer.\n   */\n  virtual bool Create(void*& _data[]) {\n    // handle = DXBufferCreate(Device().Context(), DX_BUFFER_INDEX, &_data);\n    return handle != INVALID_HANDLE;\n  }\n\n  /**\n   * Destructor;\n   */\n  ~MTDXIndexBuffer() { DXRelease(handle); }\n\n  /**\n   * Fills index buffer with indices.\n   */\n  virtual void Fill(unsigned int& _indices[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_INDEX, _indices);\n  }\n\n  /**\n   * Activates index buffer for rendering.\n   */\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting indices \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n"}, {"filename": "MTDXVertexBuffer.h", "path": "new_knowledge/EA31337-classes-master/3D/Devices/MTDX/MTDXVertexBuffer.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics vertex buffer.\n */\n\n#include \"../../VertexBuffer.h\"\n\nclass MTDXVertexBuffer : public VertexBuffer {\n  int handle;\n\n public:\n  MTDXVertexBuffer(Device* _device) : VertexBuffer(_device) {}\n\n  ~MTDXVertexBuffer() {\n    // DXRelease(handle);\n  }\n\n public:\n  /**\n   * Creates vertex buffer.\n   */\n  template <typename X>\n  bool Fill(X& _data[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_VERTEX, _data);\n#ifdef __debug__\n    Print(\"Created vb \", handle);\n    Print(\"Fill: LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting vb \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted graphics vertex buffer.\n */\n\n#include \"../../VertexBuffer.h\"\n\nclass MTDXVertexBuffer : public VertexBuffer {\n  int handle;\n\n public:\n  MTDXVertexBuffer(Device* _device) : VertexBuffer(_device) {}\n\n  ~MTDXVertexBuffer() {\n    // DXRelease(handle);\n  }\n\n public:\n  /**\n   * Creates vertex buffer.\n   */\n  template <typename X>\n  bool Fill(X& _data[]) {\n    handle = DXBufferCreate(GetDevice().Context(), DX_BUFFER_VERTEX, _data);\n#ifdef __debug__\n    Print(\"Created vb \", handle);\n    Print(\"Fill: LastError: \", GetLastError());\n#endif\n    return true;\n  }\n\n  virtual void Select() {\n#ifdef __debug__\n    Print(\"Selecting vb \", handle);\n#endif\n    DXBufferSet(GetDevice().Context(), handle);\n#ifdef __debug__\n    Print(\"Select: LastError: \", GetLastError());\n#endif\n  }\n};\n"}, {"filename": "MTDXShader.h", "path": "new_knowledge/EA31337-classes-master/3D/Devices/MTDX/MTDXShader.h", "content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted unversal graphics shader.\n */\n\n#include \"../../Shader.h\"\n\nclass MTDXShader : public Shader {\n  // DX context handle.\n  int handle;\n\n  // DX MVP's C-Buffer handle (register b0).\n  int cbuffer_mvp_handle;\n\n  MVPBuffer mvp_buffer;\n\n  // DX C-Buffer handle. (register b1).\n  int cbuffer_handle;\n\n public:\n  /**\n   * Constructor.\n   */\n  MTDXShader(Device* _device) : Shader(_device) {}\n\n  /**\n   * Destructor.\n   */\n  ~MTDXShader() {\n    DXRelease(cbuffer_handle);\n    DXRelease(cbuffer_mvp_handle);\n    DXRelease(handle);\n  }\n\n  /**\n   * Creates a shader.\n   */\n  bool Create(ENUM_SHADER_TYPE _type, string _source_code, string _entry_point = \"main\") {\n    string error_text;\n\n    handle = DXShaderCreate(GetDevice().Context(), _type == SHADER_TYPE_VS ? DX_SHADER_VERTEX : DX_SHADER_PIXEL,\n                            _source_code, _entry_point, error_text);\n\n#ifdef __debug__\n    Print(\"DXShaderCreate: LastError: \", GetLastError(), \", ErrorText: \", error_text);\n#endif\n\n    cbuffer_handle = 0;\n\n    // Creating MVP buffer.\n    cbuffer_mvp_handle = DXInputCreate(GetDevice().Context(), sizeof(MVPBuffer));\n#ifdef __debug__\n    Print(\"DXInputCreate (mvp): LastError: \", GetLastError());\n#endif\n\n    return true;\n  }\n\n  /**\n   * Sets vertex/pixel data layout to be used by shader.\n   */\n  virtual void SetDataLayout(const ShaderVertexLayout& _layout[]) {\n    // Converting generic layout into MT5 DX's one.\n\n    DXVertexLayout _target_layout[];\n    ArrayResize(_target_layout, ArraySize(_layout));\n\n#ifdef __debug__\n    Print(\"ArrayResize: LastError: \", GetLastError());\n#endif\n\n    int i;\n\n    for (i = 0; i < ArraySize(_layout); ++i) {\n      _target_layout[i].semantic_name = _layout[i].name;\n      _target_layout[i].semantic_index = _layout[i].index;\n      _target_layout[i].format = ParseFormat(_layout[i]);\n    }\n\n#ifdef __debug__\n    for (i = 0; i < ArraySize(_target_layout); ++i) {\n      Print(_target_layout[i].semantic_name, \", \", _target_layout[i].semantic_index, \", \",\n            EnumToString(_target_layout[i].format));\n    }\n\n    Print(\"before DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    DXShaderSetLayout(handle, _target_layout);\n\n#ifdef __debug__\n    Print(\"DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    ResetLastError();\n  }\n\n#ifdef __MQL5__\n  /**\n   * Converts vertex layout's item into required DX's color format.\n   */\n  ENUM_DX_FORMAT ParseFormat(const ShaderVertexLayout& _layout) {\n    if (_layout.type == GFX_VAR_TYPE_FLOAT) {\n      switch (_layout.num_components) {\n        case 1:\n          return DX_FORMAT_R32_FLOAT;\n        case 2:\n          return DX_FORMAT_R32G32_FLOAT;\n        case 3:\n          return DX_FORMAT_R32G32B32_FLOAT;\n        case 4:\n          return DX_FORMAT_R32G32B32A32_FLOAT;\n        default:\n          Alert(\"Too many components in vertex layout!\");\n      }\n    }\n\n    Alert(\"Wrong vertex layout!\");\n    return (ENUM_DX_FORMAT)0;\n  }\n#endif\n\n  /**\n   * Sets custom input buffer for shader.\n   */\n  template <typename X>\n  void SetCBuffer(const X& data) {\n    if (cbuffer_handle == 0) {\n      cbuffer_handle = DXInputCreate(GetDevice().Context(), sizeof(X));\n#ifdef __debug__\n      Print(\"DXInputCreate: LastError: \", GetLastError());\n#endif\n\n      int _input_handles[1];\n      _input_handles[0] = cbuffer_handle;\n\n      DXShaderInputsSet(handle, _input_handles);\n#ifdef __debug__\n      Print(\"DXShaderInputsSet: LastError: \", GetLastError());\n#endif\n    }\n\n    DXInputSet(cbuffer_handle, data);\n#ifdef __debug__\n    Print(\"DXInputSet: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Selectes shader to be used by graphics device for rendering.\n   */\n  virtual void Select() {\n    // Setting MVP transform and material information.\n\n    DXMatrixTranspose(mvp_buffer.world, GetDevice().GetWorldMatrix());\n    DXMatrixTranspose(mvp_buffer.view, GetDevice().GetViewMatrix());\n    DXMatrixTranspose(mvp_buffer.projection, GetDevice().GetProjectionMatrix());\n    mvp_buffer.lightdir = GetDevice().GetLightDirection();\n    mvp_buffer.mat_color = GetDevice().GetMaterial().Color;\n\n    if (cbuffer_handle == 0) {\n      int _input_handles[1];\n      _input_handles[0] = cbuffer_mvp_handle;\n      DXShaderInputsSet(handle, _input_handles);\n    } else {\n      int _input_handles[2];\n      _input_handles[0] = cbuffer_mvp_handle;\n      _input_handles[1] = cbuffer_handle;\n      DXShaderInputsSet(handle, _input_handles);\n    }\n\n#ifdef __debug__\n    Print(\"DXShaderInputsSet: LastError: \", GetLastError());\n#endif\n\n    DXInputSet(cbuffer_mvp_handle, mvp_buffer);\n    DXShaderSet(GetDevice().Context(), handle);\n  }\n};\n", "search_content": "//+------------------------------------------------------------------+\n//|                                                EA31337 framework |\n//|                                 Copyright 2016-2023, EA31337 Ltd |\n//|                                       https://github.com/EA31337 |\n//+------------------------------------------------------------------+\n\n/*\n * This file is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n/**\n * @file\n * MetaTrader DX-targeted unversal graphics shader.\n */\n\n#include \"../../Shader.h\"\n\nclass MTDXShader : public Shader {\n  // DX context handle.\n  int handle;\n\n  // DX MVP's C-Buffer handle (register b0).\n  int cbuffer_mvp_handle;\n\n  MVPBuffer mvp_buffer;\n\n  // DX C-Buffer handle. (register b1).\n  int cbuffer_handle;\n\n public:\n  /**\n   * Constructor.\n   */\n  MTDXShader(Device* _device) : Shader(_device) {}\n\n  /**\n   * Destructor.\n   */\n  ~MTDXShader() {\n    DXRelease(cbuffer_handle);\n    DXRelease(cbuffer_mvp_handle);\n    DXRelease(handle);\n  }\n\n  /**\n   * Creates a shader.\n   */\n  bool Create(ENUM_SHADER_TYPE _type, string _source_code, string _entry_point = \"main\") {\n    string error_text;\n\n    handle = DXShaderCreate(GetDevice().Context(), _type == SHADER_TYPE_VS ? DX_SHADER_VERTEX : DX_SHADER_PIXEL,\n                            _source_code, _entry_point, error_text);\n\n#ifdef __debug__\n    Print(\"DXShaderCreate: LastError: \", GetLastError(), \", ErrorText: \", error_text);\n#endif\n\n    cbuffer_handle = 0;\n\n    // Creating MVP buffer.\n    cbuffer_mvp_handle = DXInputCreate(GetDevice().Context(), sizeof(MVPBuffer));\n#ifdef __debug__\n    Print(\"DXInputCreate (mvp): LastError: \", GetLastError());\n#endif\n\n    return true;\n  }\n\n  /**\n   * Sets vertex/pixel data layout to be used by shader.\n   */\n  virtual void SetDataLayout(const ShaderVertexLayout& _layout[]) {\n    // Converting generic layout into MT5 DX's one.\n\n    DXVertexLayout _target_layout[];\n    ArrayResize(_target_layout, ArraySize(_layout));\n\n#ifdef __debug__\n    Print(\"ArrayResize: LastError: \", GetLastError());\n#endif\n\n    int i;\n\n    for (i = 0; i < ArraySize(_layout); ++i) {\n      _target_layout[i].semantic_name = _layout[i].name;\n      _target_layout[i].semantic_index = _layout[i].index;\n      _target_layout[i].format = ParseFormat(_layout[i]);\n    }\n\n#ifdef __debug__\n    for (i = 0; i < ArraySize(_target_layout); ++i) {\n      Print(_target_layout[i].semantic_name, \", \", _target_layout[i].semantic_index, \", \",\n            EnumToString(_target_layout[i].format));\n    }\n\n    Print(\"before DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    DXShaderSetLayout(handle, _target_layout);\n\n#ifdef __debug__\n    Print(\"DXShaderSetLayout: LastError: \", GetLastError());\n#endif\n\n    ResetLastError();\n  }\n\n#ifdef __MQL5__\n  /**\n   * Converts vertex layout's item into required DX's color format.\n   */\n  ENUM_DX_FORMAT ParseFormat(const ShaderVertexLayout& _layout) {\n    if (_layout.type == GFX_VAR_TYPE_FLOAT) {\n      switch (_layout.num_components) {\n        case 1:\n          return DX_FORMAT_R32_FLOAT;\n        case 2:\n          return DX_FORMAT_R32G32_FLOAT;\n        case 3:\n          return DX_FORMAT_R32G32B32_FLOAT;\n        case 4:\n          return DX_FORMAT_R32G32B32A32_FLOAT;\n        default:\n          Alert(\"Too many components in vertex layout!\");\n      }\n    }\n\n    Alert(\"Wrong vertex layout!\");\n    return (ENUM_DX_FORMAT)0;\n  }\n#endif\n\n  /**\n   * Sets custom input buffer for shader.\n   */\n  template <typename X>\n  void SetCBuffer(const X& data) {\n    if (cbuffer_handle == 0) {\n      cbuffer_handle = DXInputCreate(GetDevice().Context(), sizeof(X));\n#ifdef __debug__\n      Print(\"DXInputCreate: LastError: \", GetLastError());\n#endif\n\n      int _input_handles[1];\n      _input_handles[0] = cbuffer_handle;\n\n      DXShaderInputsSet(handle, _input_handles);\n#ifdef __debug__\n      Print(\"DXShaderInputsSet: LastError: \", GetLastError());\n#endif\n    }\n\n    DXInputSet(cbuffer_handle, data);\n#ifdef __debug__\n    Print(\"DXInputSet: LastError: \", GetLastError());\n#endif\n  }\n\n  /**\n   * Selectes shader to be used by graphics device for rendering.\n   */\n  virtual void Select() {\n    // Setting MVP transform and material information.\n\n    DXMatrixTranspose(mvp_buffer.world, GetDevice().GetWorldMatrix());\n    DXMatrixTranspose(mvp_buffer.view, GetDevice().GetViewMatrix());\n    DXMatrixTranspose(mvp_buffer.projection, GetDevice().GetProjectionMatrix());\n    mvp_buffer.lightdir = GetDevice().GetLightDirection();\n    mvp_buffer.mat_color = GetDevice().GetMaterial().Color;\n\n    if (cbuffer_handle == 0) {\n      int _input_handles[1];\n      _input_handles[0] = cbuffer_mvp_handle;\n      DXShaderInputsSet(handle, _input_handles);\n    } else {\n      int _input_handles[2];\n      _input_handles[0] = cbuffer_mvp_handle;\n      _input_handles[1] = cbuffer_handle;\n      DXShaderInputsSet(handle, _input_handles);\n    }\n\n#ifdef __debug__\n    Print(\"DXShaderInputsSet: LastError: \", GetLastError());\n#endif\n\n    DXInputSet(cbuffer_mvp_handle, mvp_buffer);\n    DXShaderSet(GetDevice().Context(), handle);\n  }\n};\n"}]